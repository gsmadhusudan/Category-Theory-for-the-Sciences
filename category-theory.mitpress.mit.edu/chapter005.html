<!DOCTYPE html>
<html>
<head>
<title>Category Theory for the Sciences</title>
<link rel="stylesheet" type="text/css" href="css/stylesheet.css"/>
</head>
<body>
<div class="body">
<a id="p161"></a>

<p><div class=navigation>[Go to <span><a href="index.html">first</a>, <a href="chapter004.html">previous</a></span><span>, <a href="chapter006.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="toc.html">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="bookindex.html">index</a></span>]</div><p>

<section title="Basic Category Theory" epub:type="bodymatter chapter">
<h1 class="chapter-number"><a href="toc.html#chap-5"><strong>Chapter 5</strong></a></h1>
<h1 class="chapter-title"><a href="toc.html#chap-5"><strong>Basic Category Theory</strong></a></h1>
<p class="noindent">&#x201C;<em>&#x2026;We know only a very few&#x2014;and, therefore, very precious&#x2014;schemes whose unifying powers cross many realms.</em>&#x201D;&#x2014;Marvin Minsky.<sup><a id="endnote_ref_1" href="chapter005.html#endnote_1">1</a></sup></p>
<p class="space-break-top">Categories, or an equivalent notion, have already been introduced as ologs, or equivalently, as database schemas. One can think of a category as a graph (as in Section <a href="chapter004.html#lev_4-3">4.3</a>) in which certain paths have been declared congruent. (Ologs demand an extra requirement that everything be readable in natural language, and this cannot be part of the mathematical definition of category.) The formal definition of category is given in Definition <a href="chapter005.html#Def_5-1-1-1">5.1.1.1</a>, but it will not appear obvious that it is equivalent to the graph &#x002B; congruence notion of schema, found in Definition <a href="chapter004.html#Def_4-5-2-7">4.5.2.7</a>. Once we know how different categories can be compared using functors (Definition <a href="chapter005.html#Def_5-1-2-1">5.1.2.1</a>), and how different schemas can be compared using schema mappings (Definition <a href="chapter005.html#Def_5-4-1-2">5.4.1.2</a>), we prove that the two notions are indeed equivalent (Theorem <a href="chapter005.html#The_5-4-2-3">5.4.2.3</a>).</p>



<section title="Categories and functors">
<h1 class="level1" id="lev_5-1"><a href="toc.html#Rlev_5-1"><strong>5.1&#160;&#160;&#160;Categories and functors</strong></a></h1>
<p class="noindent">This section gives the standard definition of categories and functors. These, together with natural transformations (Section <a href="chapter005.html#lev_5-3">5.3</a>), form the backbone of category theory. It also gives several examples.</p>
<a id="p162"></a>


<section title="Categories">
<h2 class="level2" id="lev_5-1-1"><strong>5.1.1&#160;&#160;&#160;Categories</strong></h2>
<p class="noindent">In everyday speech we think of a category as a kind of thing. A category consists of a collection of things, all of which are related in some way. In mathematics a category can also be construed as a collection of things and a type of relationship between pairs of such things. For this kind of thing-relationship duo to count as a category, we need to check two rules, which have the following flavor: every thing must be related to itself by simply being itself, and if one thing is related to another and the second is related to a third, then the first is related to the third. In a category the things are called <em>objects</em> and the relationships are called <em>morphisms</em>.</p>
<p>So far we have discussed things of various sorts, e.g., sets, monoids, graphs. In each case we discussed how such things should be appropriately compared as homomorphisms. In each case the things stand as the objects and the appropriate comparisons stand as the morphisms in the category. Here is the definition.</p>
<p class="noindent1-top-def" id="Def_5-1-1-1"><strong>Definition 5.1.1.1</strong>. A <em>category</em> <epub:switch id="mathmlSwitch321"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is defined as follows: One announces some constituents (A. objects, B. morphisms, C. identities, D. compositions) and shows that they conform to some laws (1. identity law, 2. associativity law). Specifically, one announces</p>
<p class="nl2-list">A. a collection Ob(<epub:switch id="mathmlSwitch322"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>), elements of which are called <em>objects</em>;</p>
<p class="nl2-list">B. for every pair <em>x</em>, <em>y</em> &#x2208; <epub:switch id="mathmlSwitch323"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, a set <epub:switch id="mathmlSwitch324"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo><mo>&#x2208;</mo><mtext mathvariant="bold">Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>; it is called the <em>hom-set from x to y</em>; its elements are called <em>morphisms from x to y</em>;<sup><a id="endnote_ref_2" href="chapter005.html#endnote_2">2</a></sup></p>
<p class="nl2-list">C. for every object <epub:switch id="mathmlSwitch325"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, a specified morphism, denoted <epub:switch id="mathmlSwitch326"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>id</mtext></mrow><mi>x</mi></msub><mo>&#x2208;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>(</mo><mi>x</mi><mo>,</mo><mi>x</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and called <em>the identity morphism on x</em>;</p>
<p class="nl2-list">D. for every three objects <epub:switch id="mathmlSwitch327"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, a function</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch328"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>&#x25CB;</mo><mo>:</mo><mtext>&#x2009;</mtext><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo stretchy='false'>(</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy='false'>)</mo><mo>&#x00D7;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo stretchy='false'>)</mo><mo>,</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="nl2-list-para">called <em>the composition formula</em>.</p>
<p class="noindent1-top">Given objects <em>x</em>, <em>y</em> &#x2208; Ob(<epub:switch id="mathmlSwitch329"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>), we can denote a morphism <epub:switch id="mathmlSwitch330"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo>&#x2208;</mo><msub><mrow>Hom</mrow><mi mathvariant="script">C</mi></msub><mo>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> by <em>f</em>: <em>x</em> &#x2192; <em>y</em>; we say that <em>x</em> is the <em>domain</em> of <em>f</em> and that <em>y</em> is the <em>codomain</em> of <em>f</em>. Given also <em>g</em>: <em>y</em> &#x2192; <em>z</em>, the composition formula is written using infix notation, so <em>g</em> &#x25CB; <em>f</em>: <em>x</em> &#x2192; <em>z</em> means <epub:switch id="mathmlSwitch331"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>&#x25CB;</mo><mo>(</mo><mi>g</mi><mo>,</mo><mi>f</mi><mo>)</mo><mo>&#x2208;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>(</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p>One must then show that the following <em>category laws</em> hold:</p>
<ol class="olnoindent">
<li class="litop">For every <em>x</em>, <em>y</em> &#x2208; Ob(<epub:switch id="mathmlSwitch332"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>) and every morphism <em>f</em>: <em>x</em> &#x2192; <em>y</em>, we have
<p class="disp-equ-no"><epub:switch id="mathmlSwitch333"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo>&#x25CB;</mo><msub><mrow><mtext>id</mtext></mrow><mi>x</mi></msub><mo>=</mo><mi>f</mi><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>and</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><msub><mrow><mtext>id</mtext></mrow><mi>y</mi></msub><mo>&#x25CB;</mo><mi>f</mi><mo>=</mo><mi>f</mi><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p></li>
<li class="litop"><a id="p163"></a>If <em>w</em>, <em>x</em>, <em>y</em>, <em>z</em> &#x2208; Ob(<epub:switch id="mathmlSwitch334"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>) are any objects, and <em>f</em>: <em>w</em> &#x2192; <em>x</em>, <em>g</em>: <em>x</em> &#x2192; <em>y</em>, and <em>h</em>: <em>y</em> &#x2192; <em>z</em> are any morphisms, then the two ways to compose yield the same element in <epub:switch id="mathmlSwitch335"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>(</mo><mi>w</mi><mo>,</mo><mi>z</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>:</li>
</ol>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch336"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mo stretchy='false'>(</mo><mi>h</mi><mo>&#x25CB;</mo><mi>g</mi><mo stretchy='false'>)</mo><mo>&#x25CB;</mo><mi>f</mi><mo>=</mo><mi>h</mi><mo>&#x25CB;</mo><mo stretchy='false'>(</mo><mi>g</mi><mo>&#x25CB;</mo><mi>f</mi><mo stretchy='false'>)</mo><mo>&#x2208;</mo><msub><mtext>Hom</mtext><mi mathvariant="script">C</mi></msub><mo stretchy='false'>(</mo><mi>w</mi><mo>,</mo><mi>z</mi><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top" id="Rem_5-1-1-2"><em>Remark</em> 5.1.1.2. There is perhaps much that is unfamiliar about Definition <a href="chapter005.html#Def_5-1-1-1">5.1.1.1</a>, but there is also one thing that is strange about it. The objects Ob(<epub:switch id="mathmlSwitch337"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>) of <epub:switch id="mathmlSwitch338"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> are said to be a collection rather than a set. This is because we sometimes want to talk about the category of all sets, in which every possible set is an object, and if we try to say that the collection of sets is itself a set, we run into <span class="underline">Russell&#x2019;s paradox</span>. Modeling this was a sticking point in the foundations of category theory, but it was eventually fixed by Grothendieck&#x2019;s notion of expanding universes. Roughly, the idea is to choose some huge set <em>&#x03BA;</em> (with certain properties making it a <em>universe</em>), to work entirely inside of it when possible, and to call anything in that world <em>&#x03BA;-small</em> (or just <em>small</em> if <em>&#x03BA;</em> is clear from context). When we need to look at <em>&#x03BA;</em> itself, we choose an even bigger universe <em>&#x03BA;</em>&#x2032; and work entirely within it.</p>
<p>A category in which the collection Ob(<epub:switch id="mathmlSwitch339"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>) is a set (or a small set) is called a <em>small category</em>. From here on I do not take note of the difference; I refer to Ob(<epub:switch id="mathmlSwitch340"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>) as a set. I do not think this will do any harm to scientists using category theory, at least not in the beginning phases of their learning.</p>
<p class="noindent1-top" id="Exa_5-1-1-3"><em>Example</em> 5.1.1.3 (The category <strong>Set</strong> of sets). Chapters <span class="underline">2</span> and <span class="underline">3</span> were about the category of sets, denoted <strong>Set</strong>. The objects are the sets and the morphisms are the functions; and the current notation Hom<strong><sub>Set</sub></strong>(<em>X</em>, <em>Y</em>) was used to refer to the set of functions <em>X</em> &#x2192; <em>Y</em>. The composition formula &#x25CB; is given by function composition, and for every set <em>X</em>, the identity function id<em><sub>X</sub></em>: <em>X</em> &#x2192; <em>X</em> serves as the identity morphism for <em>X</em> &#x2208; Ob(<strong>Set</strong>). The two laws clearly hold, so <strong>Set</strong> is indeed a category.</p>
<p class="noindent1-top" id="Exa_5-1-1-4"><em>Example</em> 5.1.1.4 (The category <strong>Fin</strong> of finite sets). Inside the category <strong>Set</strong> is a <em>subcategory</em> <strong>Fin</strong> &#x2286; <strong>Set</strong>, called the <em>category of finite sets</em>. Whereas an object <em>S</em> &#x2208; Ob(<strong>Set</strong>) is a set that can have arbitrary cardinality, <strong>Fin</strong> is defined such that Ob(<strong>Fin</strong>) includes all (and only) those sets <em>S</em> having finitely many elements, i.e., &#x007C;<em>S</em>&#x007C; &#x003D; <em>n</em> for some natural number <em>n</em> &#x2208; &#x2115;. Every object of <strong>Fin</strong> is an object of <strong>Set</strong>, but not vice versa.</p>
<p>Although <strong>Fin</strong> and <strong>Set</strong> have different collections of objects, their notions of morphism are in some sense the same. For any two finite sets <em>S</em>, <em>S</em>&#x2032; &#x2208; Ob(<strong>Fin</strong>), we can also think of <em>S</em>, <em>S</em>&#x2032; &#x2208; Ob(<strong>Set</strong>), and we have</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch341"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Fin</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>S</mi><mo>,</mo><mi>S</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo><mo>=</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Set</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>S</mi><mo>,</mo><mi>S</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top">That is, a morphism in <strong>Fin</strong> between finite sets <em>S</em> and <em>S</em>&#x2032; is simply a function <em>f</em>: <em>S</em> &#x2192; <em>S</em>&#x2032;.</p>
<p class="noindent1-top" id="Exa_5-1-1-5"><em>Example</em> 5.1.1.5 (The category <strong>Mon</strong> of monoids). Monoids were defined in Definition <a href="chapter004.html#Def_4-1-1-1">4.1.1.1</a>, and monoid homomorphisms in Definition <a href="chapter004.html#Def_4-1-4-1">4.1.4.1</a>. Every monoid <epub:switch id="mathmlSwitch342"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi><mo>&#x2254;</mo><mo>(</mo><mi>M</mi><mo>,</mo><mi>e</mi><mo>,</mo><msub><mrow><mo>&#x22C6;</mo></mrow><mi>M</mi></msub><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> <a id="p164"></a>has an identity homomorphism <epub:switch id="mathmlSwitch343"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>id</mtext></mrow><mi mathvariant="script">M</mi></msub><mo>:</mo><mi mathvariant="script">M</mi><mo>&#x2192;</mo><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, given by the identity function id<em><sub>M</sub></em>: <em>M</em> &#x2192; <em>M</em>. To compose two monoid homomorphisms <epub:switch id="mathmlSwitch344"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo>:</mo><mi mathvariant="script">M</mi><mo>&#x2192;</mo><mi mathvariant="script">M</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch345"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>g</mi><mo>:</mo><mi mathvariant="script">M</mi><mo>&#x2032;</mo><mo>&#x2192;</mo><mi mathvariant="script">M</mi><mo>&#x2033;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we compose their underlying functions <em>f</em>: <em>M</em> &#x2192; <em>M</em>&#x2032; and <em>g</em>: <em>M</em>&#x2032; &#x2192; <em>M</em>&#x2033;, and check that the result <em>g</em> &#x25CB; <em>f</em> is a monoid homomorphism. Indeed,</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch346"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>g</mi><mo>&#x25CB;</mo><mi>f</mi><mo stretchy='false'>(</mo><mi>e</mi><mo stretchy='false'>)</mo><mo>&#x003D;</mo><mi>g</mi><mo stretchy='false'>(</mo><mi>e</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo><mo>&#x003D;</mo><mi>e</mi><mo>&#x2033;</mo><mo>,</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch347"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>g</mi><mo>&#x25CB;</mo><mi>f</mi><mo stretchy='false'>(</mo><msub><mi>m</mi><mn>1</mn></msub><mtext>&#x2009;</mtext><msub><mo>&#x22C6;</mo><mi>M</mi></msub><mtext>&#x2009;</mtext><msub><mi>m</mi><mn>2</mn></msub><mo stretchy='false'>)</mo><mo>=</mo><mi>g</mi><mo stretchy='false'>(</mo><mi>f</mi><mo stretchy='false'>(</mo><msub><mi>m</mi><mn>1</mn></msub><mo stretchy='false'>)</mo><msub><mo>&#x22C6;</mo><mrow><mi>M</mi><mo>&#x2032;</mo></mrow></msub><mtext>&#x2009;</mtext><mi>f</mi><mo stretchy='false'>(</mo><msub><mi>m</mi><mn>2</mn></msub><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>=</mo><mi>g</mi><mo>&#x25CB;</mo><mi>f</mi><mo stretchy='false'>(</mo><msub><mi>m</mi><mn>1</mn></msub><mo stretchy='false'>)</mo><msub><mo>&#x22C6;</mo><mrow><mi>M</mi><mo>&#x2033;</mo></mrow> </msub><mi>g</mi><mo>&#x25CB;</mo><mi>f</mi><mo stretchy='false'>(</mo><msub><mi>m</mi><mn>2</mn></msub><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top">It is clear that the two category laws (unit and associativity) hold, because monoid morphisms are special kinds of functions, and functions compose unitally and associatively. So <strong>Mon</strong> is a category.</p>
<p class="noindent1-top" id="Rem_5-1-1-6"><em>Remark</em> 5.1.1.6. The following will be informal, but it can be formalized. Let&#x2019;s define a <em>questionable category</em> to be the specification of A, B, C, D from Definition <a href="chapter005.html#Def_5-1-1-1">5.1.1.1</a>, without enforcing either of the category laws (1, 2). Suppose that <epub:switch id="mathmlSwitch348"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">Q</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a questionable category and <epub:switch id="mathmlSwitch349"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a category. If <epub:switch id="mathmlSwitch350"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">Q</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> sits somehow inside of <epub:switch id="mathmlSwitch351"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, in the precise sense that</p>
<p class="nl2-list">A. there is a function <epub:switch id="mathmlSwitch352"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>U</mi><mo>:</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">Q</mi><mo>)</mo><mo>&#x2192;</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>,</p>
<p class="nl2-list">B. for all <epub:switch id="mathmlSwitch353"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>a</mi><mo>,</mo><mi>b</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">Q</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we have an injection <epub:switch id="mathmlSwitch354"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>U</mi><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">Q</mi></msub><mo stretchy='false'>(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy='false'>)</mo><mo>&#x21AA;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo stretchy='false'>(</mo><mi>U</mi><mo stretchy='false'>(</mo><mi>a</mi><mo stretchy='false'>)</mo><mo>,</mo><mi>U</mi><mo stretchy='false'>(</mo><mi>b</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>,</p>
<p class="nl2-list">C. for all <epub:switch id="mathmlSwitch355"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>a</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">Q</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, both <epub:switch id="mathmlSwitch356"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">Q</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch357"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> have the same version of the identity on <em>a</em>, i.e., <em>U</em>(id<em><sub>a</sub></em>) &#x003D; id<sub><em>U</em>(<em>a</em>)</sub>,</p>
<p class="nl2-list">D. for all <em>f</em>: <em>a</em> &#x2192; <em>b</em> and <em>g</em>: <em>b</em> &#x2192; <em>c</em> in <epub:switch id="mathmlSwitch358"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">Q</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, both <epub:switch id="mathmlSwitch359"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">Q</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch360"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> have the same version of composition <em>g</em> &#x25CB; <em>f</em>, i.e., <em>U</em>(<em>g</em> &#x25CB; <em>f</em>) &#x003D; <em>U</em>(<em>g</em>) &#x25CB; <em>U</em>(<em>f</em>),</p>
<p class="noindent1-top">then <epub:switch id="mathmlSwitch361"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">Q</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a category (no longer questionable).</p>
<p>This fact was used in Example <a href="chapter005.html#Exa_5-1-1-5">5.1.1.5</a> for <strong>Mon</strong> &#x2286; <strong>Set</strong>.</p>
<p class="noindent1-top" id="Exe_5-1-1-7"><em>Exercise</em> 5.1.1.7.</p>
<p class="space-break">Suppose we set out to define a category <strong>Grp</strong>, having groups as objects and group homomorphisms as morphisms (see Definition <a href="chapter004.html#Def_4-2-1-16">4.2.1.16</a>). Show that the rest of the conditions for <strong>Grp</strong> to be a category are satisfied.</p>

<p class="noindent1-top" id="Exe_5-1-1-8"><em>Exercise</em> 5.1.1.8.</p>
<p class="space-break">Suppose we set out to define a category <strong>PrO</strong>, having preorders as objects and preorder homomorphisms as morphisms (see Definition <a href="chapter004.html#Def_4-4-4-1">4.4.4.1</a>). Show (to the level of detail of Example <a href="chapter005.html#Exa_5-1-1-5">5.1.1.5</a>) that the rest of the conditions for <strong>PrO</strong> to be a category are satisfied.</p>
<a id="p165"></a>
<p class="noindent1-top" id="Exa_5-1-1-9"><em>Example</em> 5.1.1.9 (Noncategory 1). What is not a category? Two things can go wrong: either one fails to specify all the relevant constituents (A, B, C, D from Definition <a href="chapter005.html#Def_5-1-1-1">5.1.1.1</a>), or the constituents do not obey the category laws (1, 2).</p>
<p>Let <em>G</em> be the following graph:</p>
<p class="fig-img"><img src="images/Art_P144.jpg" alt="art"/></p>
<p class="noindent">Suppose we try to define a category <epub:switch id="mathmlSwitch362"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">G</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> by faithfully recording vertices as objects and arrows as morphisms. Will that be a category?</p>
<p>Following that scheme, we put <epub:switch id="mathmlSwitch363"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">G</mi><mo>)</mo><mo>&#x003D;</mo><mo>&#x007B;</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>&#x007D;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. For all nine pairs of objects we need a hom-set. Since the only things we are calling morphisms are the arrows of <em>G</em>, we put</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch364"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mtable><mtr><mtd columnalign='left'><mtable><mtr><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x2205;</mo></mrow></mtd><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x007B;</mo><mi>f</mi><mo>&#x007D;</mo></mrow></mtd><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x2205;</mo></mrow></mtd></mtr><mtr><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>b</mi><mo>,</mo><mi>a</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x2205;</mo></mrow></mtd><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>b</mi><mo>,</mo><mi>b</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x2205;</mo></mrow></mtd><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x007B;</mo><mi>g</mi><mo>&#x007D;</mo></mrow></mtd></mtr><mtr><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>a</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x2205;</mo></mrow></mtd><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>b</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x2205;</mo></mrow></mtd><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x2205;</mo></mrow></mtd></mtr></mtable></mtd><mtd columnalign='left'><mo>(</mo><mn>5</mn><mo>.</mo><mn>1</mn><mo>&#x002A;</mo><mo>)</mo></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top">If we say we are done, the listener should object that we have given neither identities (C) nor a composition formula (D), and these are necessary constituents. Now we are at a loss: it is impossible to give identities under this scheme, because, e.g., <epub:switch id="mathmlSwitch365"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow>Hom</mrow><mi mathvariant="script">G</mi></msub><mo>(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo>)</mo><mo>&#x003D;</mo><mo>&#x2205;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. So what we have for <epub:switch id="mathmlSwitch366"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">G</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is not a category.</p>
<p>Suppose we fix that problem, adding an element to each of the diagonals so that</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch367"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x007B;</mo><msub><mrow><mtext>id</mtext></mrow><mi>a</mi></msub><mo>&#x007D;</mo><mo>,</mo><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>b</mi><mo>,</mo><mi>b</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x007B;</mo><msub><mrow><mtext>id</mtext></mrow><mi>b</mi></msub><mo>&#x007D;</mo><mo>,</mo><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>and</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x007B;</mo><msub><mrow><mtext>id</mtext></mrow><mi>c</mi></msub><mo>&#x007D;</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>

<p class="noindent1-top">But the listener still demands a composition formula. In particular, we need a function</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch368"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>&#x00D7;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>,</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top">but the domain is nonempty (it is {(<em>f</em>, <em>g</em>)}) and the codomain <epub:switch id="mathmlSwitch369"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mtext>Hom</mtext><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x2205;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is empty; there is no such function. In other words, to satisfy the listener we need to add a composite for the arrows <em>f</em> and <em>g</em>.</p>
<p>So again we must make a change, adding an element to make <epub:switch id="mathmlSwitch370"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mtext>Hom</mtext><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x007B;</mo><mi>h</mi><mo>&#x007D;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. We can now say <em>g</em> &#x25CB; <em>f</em> &#x003D; <em>h</em>. Finally, this does the trick and we have a category with the following morphisms:</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch371"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>a</mi><mo>,</mo><mi>a</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x007B;</mo><msub><mrow><mtext>id</mtext></mrow><mi>a</mi></msub><mo>&#x007D;</mo></mrow></mtd><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x007B;</mo><mi>f</mi><mo>&#x007D;</mo></mrow></mtd><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x007B;</mo><mi>h</mi><mo>&#x007D;</mo></mrow></mtd></mtr><mtr><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>b</mi><mo>,</mo><mi>a</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x2205;</mo></mrow></mtd><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>b</mi><mo>,</mo><mi>b</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x007B;</mo><msub><mrow><mtext>id</mtext></mrow><mi>b</mi></msub><mo>&#x007D;</mo></mrow></mtd><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x007B;</mo><mi>g</mi><mo>&#x007D;</mo></mrow></mtd></mtr><mtr><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>a</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x2205;</mo></mrow></mtd><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>b</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x2205;</mo></mrow></mtd><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">G</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x007B;</mo><msub><mrow><mtext>id</mtext></mrow><mi>c</mi></msub><mo>&#x007D;</mo></mrow></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">A computer could check this quickly, as can someone with good intuition for categories; for everyone else, it may be a painstaking process involving determining whether there <a id="p166"></a>is a unique composition formula for each of the 27 pairs of hom-sets and whether the associative law holds in the 81 necessary cases. Luckily this computation is sparse (lots of &#x2205;&#x2019;s).</p>
<p>If all the morphisms are drawn as arrows, the graph becomes:</p>
<p class="fig-img"><img src="images/Art_P145.jpg" alt="art"/></p>
<p class="noindent1-top" id="Exa_5-1-1-10"><em>Example</em> 5.1.1.10 (Noncategory 2). In this example, we make a faux category <epub:switch id="mathmlSwitch372"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">F</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> with one object and many morphisms. The problem here is the composition formula.</p>
<p>Define <epub:switch id="mathmlSwitch373"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">F</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> to have one object <epub:switch id="mathmlSwitch374"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">F</mi><mo>)</mo><mo>&#x003D;</mo><mo>&#x007B;</mo><mo>&#x263A;</mo><mo>&#x007D;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and <epub:switch id="mathmlSwitch375"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">F</mi></msub><mo>(</mo><mo>&#x263A;</mo><mo>,</mo><mo>&#x263A;</mo><mo>)</mo><mo>&#x003D;</mo><mo>&#x2115;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>
. Define id<sub>&#x263A;</sub>&#x003D; 1 &#x2208; &#x2115;. Define the composition formula &#x25CB;: &#x2115; &#x00D7; &#x2115; &#x2192; &#x2115; by the usual exponentiation function for natural numbers, <em>m</em> &#x25CB; <em>n</em> &#x003D; <em>m<sup>n</sup></em>. This is a perfectly cromulent function, but it does not work right as a composition formula. Indeed, for the identity law to hold, we would need <em>m</em><sup>1</sup> &#x003D; <em>m</em> &#x003D; 1<em><sup>m</sup></em>, and one side of this is false. For the associativity law to hold, we would need <epub:switch id="mathmlSwitch376"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msup><mrow><mo stretchy='false'>(</mo><msup><mi>m</mi><mi>n</mi></msup><mo stretchy='false'>)</mo></mrow><mi>p</mi></msup><mo>=</mo><msup><mi>m</mi><mrow><mo stretchy='false'>(</mo><msup><mi>n</mi><mi>p</mi></msup><mo stretchy='false'>)</mo></mrow></msup></mrow></math></epub:case><epub:default></epub:default></epub:switch>, but this is also not the case.</p>
<p>To fix this problem we must completely revamp the composition formula. It would work to use multiplication, <em>m</em> &#x25CB; <em>n</em> &#x003D; <em>m</em> &#x002A; <em>n</em>. Then the identity law would read 1 &#x002A; <em>m</em> &#x003D; <em>m</em> &#x003D; <em>m</em> &#x002A; 1, and that holds; and the associativity law would read (<em>m</em> &#x002A; <em>n</em>) &#x002A; <em>p</em> &#x003D; <em>m</em> &#x002A; (<em>n</em> &#x002A; <em>p</em>), and that holds.</p>

<p class="noindent1-top" id="Exa_5-1-1-11"><em>Example</em> 5.1.1.11 (The category of preorders with joins). Suppose we are only interested in preorders (<em>X</em>,  &#x2A7D;) for which every pair of elements has a join. We saw in Exercise <a href="chapter004.html#Exe_4-4-2-3">4.4.2.3</a> that not all preorders have this property. However, we can create a category <epub:switch id="mathmlSwitch377"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> in which every object does have this property. To begin, let&#x2019;s put</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch378"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi><mo>&#x2254;</mo><mo>&#x007B;</mo><mo stretchy='false'>(</mo><mi>X</mi><mo>,</mo><mo> &#x2A7D;</mo><mo stretchy='false'>)</mo><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mtext mathvariant="bold">PrO</mtext><mo stretchy='false'>)</mo><mo>&#x007C;</mo><mo stretchy='false'>(</mo><mi>X</mi><mo>,</mo><mo> &#x2A7D;</mo><mo stretchy='false'>)</mo><mtext>&#x2009;</mtext><mtext>has</mtext><mtext>&#x2009;</mtext><mtext>all</mtext><mtext>&#x2009;</mtext><mtext>joins</mtext><mo>&#x007D;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top">for the set of objects. What about morphisms?</p>
<p>One option would be to put in no morphisms (other than identities) and to just consider this collection of objects as having no structure other than a set. In other words, we can take <epub:switch id="mathmlSwitch379"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> to be the discrete category on the preceding set <epub:switch id="mathmlSwitch380"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo><mo>&#x003D;</mo><mi>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p>Another option, say, <epub:switch id="mathmlSwitch381"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> with objects <epub:switch id="mathmlSwitch382"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>&#x2032;</mo><mo>)</mo><mo>&#x2254;</mo><mi>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, would be to put in exactly the same morphisms as in <strong>PrO</strong>: for any objects <em>a</em>, <em>b</em> &#x2208; <em>C</em>, we consider <em>a</em> and <em>b</em> as ordinary preorders and put <epub:switch id="mathmlSwitch383"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant="script">C</mi><mo>&#x2032;</mo></mrow></msub><mo stretchy='false'>(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy='false'>)</mo><mo>&#x2254;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">PrO</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. The resulting category <epub:switch id="mathmlSwitch384"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> of preorders with joins is called the <em>full subcategory of</em> <strong>PrO</strong> <em>spanned by the preorders with joins</em>.<sup><a id="endnote_ref_3" href="chapter005.html#endnote_3">3</a></sup></p>
<a id="p167"></a>
<p>A third option, say, <epub:switch id="mathmlSwitch385"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi><mo>&#x2033;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> with objects <epub:switch id="mathmlSwitch386"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>&#x2033;</mo><mo>)</mo><mo>&#x2254;</mo><mi>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, would stand out to a category theorist. That is, the conscientious modeler takes the choice about how we define objects as a clue to how we should define morphisms.</p>
<p class="noindent1-top"><em>Slogan</em> 5.1.1.12.</p>
<div class="pull-quote">
<p class="pq-indent"><em>If you like joins so much, why don&#x2019;t you marry them?</em></p>
</div>
<p>Morphisms are often billed as preserving all the structure we care about, so it is worth asking whether we want to enforce that constraint on morphisms. That is, suppose <em>f</em>: (<em>X</em>,  &#x2A7D;<em><sub>X</sub></em>) &#x2192; (<em>Y</em>,  &#x2A7D;<em><sub>Y</sub></em>) is a morphism of preorders. We might want to condition the decision of whether to include <em>f</em> as a morphism in <epub:switch id="mathmlSwitch387"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi><mo>&#x2033;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> on whether, for any join <em>w</em> &#x003D; <em>x</em> &#x2228; <em>x</em>&#x2032; in <em>X</em>, it is the case that <em>f</em>(<em>w</em>) &#x003D; <em>f</em>(<em>x</em>) &#x2228; <em>f</em>(<em>x</em>&#x2032;) in <em>Y</em>. Concisely, we could define the morphisms in <epub:switch id="mathmlSwitch388"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi><mo>&#x2033;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> by</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch389"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo stretchy='false'>(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy='false'>)</mo><mo>&#x2254;</mo><mo>&#x007B;</mo><mi>f</mi><mo>&#x2208;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">PrO</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy='false'>)</mo><mo>&#x007C;</mo><mi>f</mi><mtext>&#x2009;</mtext><mtext>preserves</mtext><mtext>&#x2009;</mtext><mtext>joins</mtext><mo>&#x007D;</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top">One can check easily that the identity morphisms preserve joins and that compositions of join-preserving morphisms are join-preserving, so this version of homomorphisms makes <epub:switch id="mathmlSwitch390"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi><mo>&#x2033;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> a well defined category.</p>
<p>These options are by no means comprehensive, and none of these options is better than any other. Which category to use is decided by whatever fits the situation being modeled.</p>

<p class="noindent1-top" id="Exa_5-1-1-13"><em>Example</em> 5.1.1.13 (Category <strong>FLin</strong> of finite linear orders). We have a category <strong>PrO</strong> of preorders, and some of its objects are finite linear orders. Let <strong>FLin</strong> be the full subcategory of <strong>PrO</strong> spanned by the linear orders. That is, following Definition <a href="chapter004.html#Def_4-4-4-1">4.4.4.1</a>, given linear orders <em>X</em>, <em>Y</em> &#x2208; Ob(<strong>FLin</strong>), every morphism of preorders <em>X</em> &#x2192; <em>Y</em> counts as a morphism in <strong>FLin</strong>:</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch391"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">FLin</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy='false'>)</mo><mo>=</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">PrO</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top-exe" id="Exe_5-1-1-14"><em>Exercise</em> 5.1.1.14.</p>
<p class="space-break">Let <strong>FLin</strong> be the category of finite linear orders, defined in Example <a href="chapter005.html#Exa_5-1-1-13">5.1.1.13</a>. For <em>n</em> &#x2208; &#x2115;, let [<em>n</em>] be the linear order defined in Example <a href="chapter004.html#Exa_4-4-1-7">4.4.1.7</a>. What are the cardinalities of the following sets?</p>
<p class="nl1-list">a. Hom<strong><sub>FLin</sub></strong>([0], [3])</p>
<p class="nl1-list">b. Hom<strong><sub>FLin</sub></strong>([3], [0])</p>
<p class="nl1-list">c. Hom<strong><sub>FLin</sub></strong>([2], [3])</p>
<p class="nl1-list">d. Hom<strong><sub>FLin</sub></strong>([1], [<em>n</em>])</p>
<a id="p168"></a>
<p class="nl1-list">e. (Challenge) Hom<strong><sub>FLin</sub></strong>([<em>m</em>], [<em>n</em>])</p>
<p class="space-break">It turns out that the category <strong>FLin</strong> of linear orders is sufficiently rich that much of algebraic topology (the study of arbitrary spaces, such as Mobius strips and seven-dimensional spheres) can be understood in its terms. See Example <a href="chapter006.html#Exa_6-2-1-7">6.2.1.7</a>.</p>

<p class="noindent1-top" id="Exa_5-1-1-15"><em>Example</em> 5.1.1.15 (Category of graphs). Graphs were defined in Definition <a href="chapter004.html#Def_4-3-1-1">4.3.1.1</a> and graph homomorphisms in Definition <a href="chapter004.html#Def_4-3-3-1">4.3.3.1</a>. To see that these are sufficient to form a category is considered routine to a seasoned category theorist, so let&#x2019;s see why.</p>
<p>Since a morphism from <epub:switch id="mathmlSwitch392"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">G</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> &#x003D; (<em>V</em>, <em>A</em>, <em>src</em>, <em>tgt</em>) to <epub:switch id="mathmlSwitch393"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">G</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> &#x003D; (<em>V</em>&#x2032;, <em>A</em>&#x2032;, <em>src</em>&#x2032;, <em>tgt</em>&#x2032;) involves two functions <em>f</em><sub>0</sub>: <em>V</em> &#x2192; <em>V</em>&#x2032; and <em>f</em><sub>1</sub>: <em>A</em> &#x2192; <em>A</em>&#x2032;, the identity and composition formulas simply arise from the identity and composition formulas for sets. Associativity follow similarly. The only thing that needs to be checked is that the composition of two such morphisms, each satisfying (4.5), will itself satisfy (4.5). For completeness, we check that now.</p>
<p>Suppose that <epub:switch id="mathmlSwitch394"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo>=</mo><mo stretchy='false'>(</mo><msub><mi>f</mi><mn>0</mn></msub><mo>,</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy='false'>)</mo><mo>:</mo><mi mathvariant="script">G</mi><mo>&#x2192;</mo><mi mathvariant="script">G</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch395"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>g</mi><mo>=</mo><mo stretchy='false'>(</mo><msub><mi>g</mi><mn>0</mn></msub><mo>,</mo><msub><mi>g</mi><mn>1</mn></msub><mo stretchy='false'>)</mo><mo>:</mo><mi mathvariant="script">G</mi><mo>&#x2032;</mo><mo>&#x2192;</mo><mi mathvariant="script">G</mi><mo>&#x2033;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> are graph homomorphisms, where <epub:switch id="mathmlSwitch396"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">G</mi><mo>&#x2033;</mo><mo>=</mo><mo stretchy='false'>(</mo><mi>V</mi><mo>&#x2033;</mo><mo>,</mo><mi>A</mi><mo>&#x2033;</mo><mo>,</mo><mi>s</mi><mi>r</mi><mi>c</mi><mo>&#x2033;</mo><mo>,</mo><mi>t</mi><mi>g</mi><mi>t</mi><mo>&#x2033;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Then in each diagram in (<a href="chapter005.html#eq_5-2">5.2</a>)</p>
<p class="fig-img" id="eq_5-2"><img src="images/Art_P146.jpg" alt="art"/></p>
<p class="noindent">the left-hand square commutes because <em>f</em> is a graph homomorphism and the right-hand square commutes because <em>g</em> is a graph homomorphism. Thus the whole rectangle commutes, meaning that <em>g</em> &#x25CB; <em>f</em> is a graph homomorphism, as desired.</p>
<p>We denote the category of graphs and graph homomorphisms <strong>Grph</strong>.</p>
<p class="noindent1-top" id="Rem_5-1-1-16"><em>Remark</em> 5.1.1.16. When one is struggling to understand basic definitions, notation, and style, a phase that naturally occurs when learning new mathematics (or any new language), the preceding example will probably appear long and tiring. I would say the reader has mastered the basics when the example seems straightforward. Around this time, I hope the reader will get a sense of the remarkable organizational potential of the categorical way of thinking.</p>
<p class="noindent1-top-exe" id="Exe_5-1-1-17"><em>Exercise</em> 5.1.1.17.</p>
<p class="space-break">Let <em>F</em> be a vector field defined on all of &#x211D;<sup>2</sup>. <span class="underline">Recall</span> that for two points <em>x</em>, <em>x</em>&#x2032; &#x2208; &#x211D;<sup>2</sup>, any curve <em>C</em> with endpoints <em>x</em> and <em>x</em>&#x2032;, and any parameterization <em>r</em>: [<em>a</em>, <em>b</em>] &#x2192; <em>C</em>, the line integral &#x222B;<em><sub>C</sub> F</em>(<em>r</em>)&#x00B7;<em>dr</em> returns a real number. It does not depend on <em>r</em>, except its orientation (direction). Therefore, if we think of <em>C</em> has having an orientation, say, going from <em>x</em> to <em>x</em>&#x2032;, then &#x222B;<em><sub>C</sub> F</em> is a well defined real number. If <em>C</em> goes from <em>x</em> to <em>x</em>&#x2032;, let&#x2019;s write <em>C</em>: <em>x</em> &#x2192; <em>x</em>&#x2032;. Define an equivalence relation &#x223C; on the set of oriented curves in &#x211D;<sup>2</sup> by saying <em>C</em> &#x223C; <em>C</em>&#x2032; if</p>
<a id="p169"></a>
<ul class="ulindent">
<li><em>C</em> and <em>C</em>&#x2032; start at the same point;</li>
<li class="litop"><em>C</em> and <em>C</em>&#x2032; end at the same point;</li>
<li class="litop">&#x222B;<em><sub>C</sub> F</em> &#x003D; &#x222B;<em><sub>C&#x2032;</sub></em> <em>F</em>.</li>
</ul>
<p>Suppose we try to make a category <epub:switch id="mathmlSwitch397"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant="script">C</mi><mrow><mi>F</mi></mrow></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> as follows. Put <epub:switch id="mathmlSwitch398"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo>(</mo><msub><mrow><mi mathvariant="script">C</mi></mrow><mi>F</mi></msub><mo>)</mo><mo>&#x003D;</mo><msup><mrow><mo>&#x211D;</mo></mrow><mtext>2</mtext></msup></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and for every pair of points <em>x</em>, <em>x</em>&#x2032; &#x2208; &#x211D;<sup>2</sup>, let <epub:switch id="mathmlSwitch399"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><msub><mtext>C</mtext><mi>F</mi></msub></mrow></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>,</mo><mi>x</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x007B;</mo><mi>C</mi><mo>:</mo><mi>x</mi><mo>&#x2192;</mo><mi>x</mi><mo>&#x2032;</mo><mo>&#x007D;</mo><mo>/</mo><mo>~</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, where <em>C</em>: <em>x</em> &#x2192; <em>x</em>&#x2032; is an oriented curve and &#x223C; means &#x201C;same line integral,&#x201D; as explained.</p>
<p>Is there an identity morphism and a composition formula that will make <epub:switch id="mathmlSwitch400"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mi mathvariant="script">C</mi></mrow><mi>F</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> into a category?</p>

<p class="noindent1-top-sol"><em>Solution</em> 5.1.1.17.</p>
<p>Yes. For every object <em>x</em> &#x2208; &#x211D;<sup>2</sup>, the constant curve at <em>x</em> serves as the identity on <em>x</em>. If <em>C</em>: <em>x</em> &#x2192; <em>y</em> and <em>C</em>&#x2032;: <em>y</em> &#x2192; <em>z</em> are curves, their composition is given by joining them to get a curve <em>x</em> &#x2192; <em>z</em>.</p>


<section title="Isomorphisms">
<h3 class="level3" id="lev_5-1-1-18"><strong>5.1.1.18&#160;&#160;&#160;Isomorphisms</strong></h3>
<p class="noindent">In any category we have a notion of isomorphism between objects.</p>
<p class="noindent1-top-def" id="Def_5-1-1-19"><strong>Definition 5.1.1.19</strong>. Let <epub:switch id="mathmlSwitch401"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> be a category, and let <epub:switch id="mathmlSwitch402"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi><mo>,</mo><mi>Y</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be objects. An <em>isomorphism f from X to Y</em> is a morphism <em>f</em>: <em>X</em> &#x2192; <em>Y</em> in <epub:switch id="mathmlSwitch403"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> such that there exists a morphism <em>g</em>: <em>Y</em> &#x2192; <em>X</em> in <epub:switch id="mathmlSwitch404"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> with</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch405"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>g</mi><mo>&#x25CB;</mo><mi>f</mi><mo>=</mo><msub><mrow><mtext>id</mtext></mrow><mi>X</mi></msub><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>and</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mtext>&#x2009;</mtext><mi>f</mi><mo>&#x25CB;</mo><mi>g</mi><mo>=</mo><msub><mrow><mtext>id</mtext></mrow><mi>Y</mi></msub><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top">In this case we say that the morphism <em>f</em> is <em>invertible</em> and that <em>g</em> is the <em>inverse</em> of <em>f</em>. We may also say that the objects <em>X</em> and <em>Y</em> are <em>isomorphic</em>.</p>
<p class="noindent1-top" id="Exa_5-1-1-20"><em>Example</em> 5.1.1.20. If <epub:switch id="mathmlSwitch406"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi><mo>&#x003D;</mo><mtext mathvariant="bold">Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> is the category of sets, then Definition <a href="chapter005.html#Def_5-1-1-19">5.1.1.19</a> coincides precisely with the one given in Definition <a href="chapter002.html#Def_2-1-2-14">2.1.2.14</a>.</p>
<p class="noindent1-top-exe" id="Exe_5-1-1-21"><em>Exercise</em> 5.1.1.21.</p>
<p>Let <epub:switch id="mathmlSwitch407"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> be a category, and let <em>c</em> &#x2208; Ob(<epub:switch id="mathmlSwitch408"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>) be an object. Show that id<em><sub>c</sub></em> is an isomorphism.</p>
<p class="noindent1-top-sol"><em>Solution</em> 5.1.1.21.</p>
<p>We have a morphism id<em><sub>c</sub></em>: <em>c</em> &#x2192; <em>c</em>. To show it is an isomorphism we just need to find a morphism <em>f</em>: <em>c</em> &#x2192; <em>c</em> such that <em>f</em> &#x25CB; id<em><sub>c</sub></em> &#x003D; id<em><sub>c</sub></em> and id<em><sub>c</sub></em> &#x25CB; <em>f</em> &#x003D; id<em><sub>c</sub></em>. Taking <em>f</em> &#x003D; id<em><sub>c</sub></em> works.</p>
<a id="p170"></a>
<p class="noindent1-top-exe" id="Exe_5-1-1-22"><em>Exercise</em> 5.1.1.22.</p>
<p class="space-break">Let <epub:switch id="mathmlSwitch409"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> be a category, and let <em>f</em>: <em>X</em> &#x2192; <em>Y</em> be a morphism. Suppose that both <em>g</em>: <em>Y</em> &#x2192; <em>X</em> and <em>g</em>&#x2032;: <em>Y</em> &#x2192; <em>X</em> are inverses of <em>f</em>. Show that they are the same morphism, <em>g</em> &#x003D; <em>g</em>&#x2032;.</p>

<p class="noindent1-top-exe" id="Exe_5-1-1-23"><em>Exercise</em> 5.1.1.23.</p>
<p>Suppose that <em>G</em> &#x003D; (<em>V</em>, <em>A</em>, <em>src</em>, <em>tgt</em>) and <em>G</em>&#x2032; &#x003D; (<em>V</em>&#x2032;, <em>A</em>&#x2032;, <em>src</em>&#x2032;, <em>tgt</em>&#x2032;) are graphs and that <em>f</em> &#x003D; (<em>f</em><sub>0</sub>, <em>f</em><sub>1</sub>): <em>G</em> &#x2192; <em>G</em>&#x2032; is a graph homomorphism (as in Definition <a href="chapter004.html#Def_4-3-3-1">4.3.3.1</a>).</p>
<p class="nl1-list">a. If <em>f</em> is an isomorphism in <strong>Grph</strong>, does this imply that <em>f</em><sub>0</sub>: <em>V</em> &#x2192; <em>V</em>&#x2032; and <em>f</em><sub>1</sub>: <em>A</em> &#x2192; <em>A</em>&#x2032; are isomorphisms in <strong>Set</strong>?</p>
<p class="nl1-list">b. If so, why; if not, show a counterexample (where <em>f</em> is an isomorphism but either <em>f</em><sub>0</sub> or <em>f</em><sub>1</sub> is not).</p>
<p class="noindent1-top-exe" id="Exe_5-1-1-24"><em>Exercise</em> 5.1.1.24.</p>
<p>Suppose that <em>G</em> &#x003D; (<em>V</em>, <em>A</em>, <em>src</em>, <em>tgt</em>) and <em>G</em>&#x2032; &#x003D; (<em>V</em>&#x2032;, <em>A</em>&#x2032;, <em>src</em>&#x2032;, <em>tgt</em>&#x2032;) are graphs and that <em>f</em> &#x003D; (<em>f</em><sub>0</sub>, <em>f</em><sub>1</sub>): <em>G</em> &#x2192; <em>G</em>&#x2032; is a graph homomorphism (as in Definition <a href="chapter004.html#Def_4-3-3-1">4.3.3.1</a>).</p>
<p class="nl1-list">a. If <em>f</em><sub>0</sub>: <em>V</em> &#x2192; <em>V</em>&#x2032; and <em>f</em><sub>1</sub>: <em>A</em> &#x2192; <em>A</em>&#x2032; are isomorphisms in <strong>Set</strong>, does this imply that <em>f</em> is an isomorphism in <strong>Grph</strong>?</p>
<p class="nl1-list">b. If so, why; if not, show a counterexample (where <em>f</em><sub>0</sub> and <em>f</em><sub>1</sub> are isomorphisms but <em>f</em> is not).</p>

<p class="noindent1-top-pro" id="Pro_5-1-1-25"><strong>Proposition 5.1.1.25</strong>. <em>Let</em> <epub:switch id="mathmlSwitch410"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>be a category, and let</em> &#x2245; <em>be the relation on</em> Ob(<epub:switch id="mathmlSwitch411"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>) <em>given by saying X</em> &#x2245; <em>Y iff X and Y are isomorphic. Then</em> &#x2245; <em>is an equivalence relation.</em></p>
<p class="noindent1-top"><em>Proof.</em> The proof of Proposition <a href="chapter002.html#Pro_2-1-2-18">2.1.2.18</a> can be mimicked in this more general setting.</p>
</section>


<section title="Another viewpoint on categories">
<h3 class="level3" id="lev_5-1-1-26"><strong>5.1.1.26&#160;&#160;&#160;Another viewpoint on categories</strong></h3>
<p class="noindent">Here is an alternative definition of category, using the work done in Chapter <span class="underline">2</span>.</p>
<p class="noindent1-top-exe" id="Exe_5-1-1-27"><em>Exercise</em> 5.1.1.27.</p>
<p class="space-break">Suppose we begin our definition of category as follows.</p>
<p>A <em>category</em> <epub:switch id="mathmlSwitch412"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> consists of a sequence <epub:switch id="mathmlSwitch413"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>(</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo><mo>,</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>,</mo><mi mathvariant="italic">dom</mi><mo>,</mo><mi mathvariant="italic">cod</mi><mo>,</mo><mi mathvariant="italic">ids</mi><mo>,</mo><mi mathvariant="italic">comp</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, where</p>
<a id="p171"></a>
<ul class="ulindent">
<li><epub:switch id="mathmlSwitch414"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a set;<sup><a id="endnote_ref_4" href="chapter005.html#endnote_4">4</a></sup></li>
<li class="litop"><epub:switch id="mathmlSwitch415"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a set, and <epub:switch id="mathmlSwitch416"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="italic">dom</mtext><mo>,</mo><mtext mathvariant="italic">cod</mtext><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>&#x2192;</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> are functions;</li>
<li class="litop"><em>ids</em>: <epub:switch id="mathmlSwitch417"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a function;</li>
<li class="litop"><em>comp</em> is a function as depicted in the commutative diagram (<a href="chapter005.html#eq_5-3">5.3</a>)</li>
</ul>
<p class="fig-img" id="eq_5-3"><img src="images/Art_P147.jpg" alt="art"/></p>
<p class="nl1-list">a. Add to diagram (<a href="chapter005.html#eq_5-3">5.3</a>) to express the fact that for any <epub:switch id="mathmlSwitch418"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, the morphism id<em><sub>x</sub></em> points from <em>x</em> to <em>x</em>.</p>
<p class="nl1-list">b. Express the condition that composing a morphism <em>f</em> with an appropriate identity morphism yields <em>f</em>.</p>
<p class="noindent1-top-sol"><em>Solution</em> 5.1.1.27.</p>
<p class="nl1-list">a. This is expressed by the equations: <epub:switch id="mathmlSwitch419"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="italic">dom</mi><mo>&#x25CB;</mo><mi mathvariant="italic">ids</mi><mo>=</mo><msub><mrow><mtext>id</mtext></mrow><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="script">C</mi><mo stretchy='false'>)</mo></mrow></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch420"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="italic">cod</mi><mo>&#x25CB;</mo><mi mathvariant="italic">ids</mi><mo>=</mo><msub><mrow><mtext>id</mtext></mrow><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="script">C</mi><mo stretchy='false'>)</mo></mrow></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>. One could express this with the diagram:</p>
<p class="fig-img"><img src="images/Art_P148.jpg" alt="art"/></p>
<a id="p172"></a>
<p class="nl1-list">b. We have <epub:switch id="mathmlSwitch421"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>id</mtext></mrow><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub></mrow></msub><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch422"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="italic">ids</mi><mo>&#x25CB;</mo><mi mathvariant="italic">cod</mi><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and these commute over Ob(<epub:switch id="mathmlSwitch423"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>), meaning that for any morphism <em>f</em>: <em>A</em> &#x2192; <em>B</em>, its codomain is the domain of id<em><sub>B</sub></em>. Thus a unique map</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch424"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>&#x2329;</mo><msub><mrow><mtext>id</mtext></mrow><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>,</mo></mrow></msub><mtext>&#x2009;</mtext><mi>i</mi><mi>d</mi><mi>s</mi><mo>&#x25CB;</mo><mtext>&#x2009;</mtext><mi>c</mi><mi>o</mi><mi>d</mi><msub><mo>&#x232A;</mo><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="script">C</mi><mo stretchy='false'>)</mo></mrow></msub><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><msub><mo>&#x00D7;</mo><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="script">C</mi><mo stretchy='false'>)</mo></mrow></msub><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="nl1-list-para">is induced (see Proposition <a href="chapter003.html#Pro_3-2-1-15">3.2.1.15</a>). Similarly there is a function</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch425"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>&#x2329;</mo><msub><mrow><mtext>id</mtext></mrow><mrow><mi>i</mi><mi>d</mi><mi>s</mi><mo>&#x25CB;</mo><mi>d</mi><mi>o</mi><mi>m</mi></mrow></msub><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>,</mo><mtext>&#x2009;</mtext><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="script">C</mi><mo stretchy='false'>)</mo><msub><mo>&#x232A;</mo><mo>:</mo></msub><mtext>&#x2009;</mtext><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><msub><mo>&#x00D7;</mo><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="script">C</mi><mo stretchy='false'>)</mo></mrow></msub><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="nl1-list-para">When we compose either of these morphisms with <em>comp</em>, we are taking the composition of a morphism and the identity (either on the domain or the codomain). Thus, the fact that composing any morphism with an identity morphism returns that morphism is expressed by asserting two path equivalences,</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch426"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable columnalign='left'><mtr><mtd columnalign='left'><msub><mstyle mathsize='140%' displaystyle='true'/><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub></mrow></msub><mo stretchy='false'>[</mo><mo>&#x2329;</mo><msub><mtext>id</mtext><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>,</mo></mrow></msub><mtext>&#x2009;</mtext><mi>i</mi><mi>d</mi><mi>s</mi><mtext>&#x2009;</mtext><mo>&#x25CB;</mo><mtext>&#x2009;</mtext><mi>c</mi><mi>o</mi><mi>d</mi><mo>&#x232A;</mo><mo>,</mo><mtext>&#x2009;</mtext><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mo stretchy='false'>]</mo><msub><mo>&#x2243;</mo><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub></mrow></msub><mo stretchy='false'>[</mo><mo stretchy='false'>]</mo><mo>,</mo></mtd></mtr><mtr><mtd columnalign='left'><msub><mstyle mathsize='140%' displaystyle='true'/><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub></mrow></msub><mo stretchy='false'>[</mo><mo>&#x2329;</mo><mi>i</mi><mi>d</mi><mi>s</mi><mtext>&#x2009;</mtext><mo>&#x25CB;</mo><mtext>&#x2009;</mtext><mi>d</mi><mi>o</mi><mi>m</mi><mo>,</mo><mtext>&#x2009;</mtext><msub><mtext>id</mtext><mrow><msub><mrow><mtext>Hom</mtext></mrow><mtext>C</mtext></msub></mrow></msub><mo>&#x232A;</mo><mo>,</mo><mtext>&#x2009;</mtext><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mo stretchy='false'>]</mo><msub><mo>&#x2243;</mo><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub></mrow></msub><mo stretchy='false'>[</mo><mo stretchy='false'>]</mo><mo>,</mo></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="nl1-list-para">in the following diagram:</p>
<p class="fig-img"><img src="images/Art_P149.jpg" alt="art"/></p>
<p class="noindent1-top" id="Exa_5-1-1-28"><em>Example</em> 5.1.1.28 (Partial olog for a category). Diagram (<a href="chapter005.html#eq_5-4">5.4</a>) is an olog that captures <a id="p173"></a>some of the essential structures of a category:</p>
<p class="fig-img" id="eq_5-4"><img src="images/Art_P150.jpg" alt="art"/></p>
<p>Missing from (<a href="chapter005.html#eq_5-4">5.4</a>) is the notion of identity morphism (as an arrow from &#x231C;an object of <epub:switch id="mathmlSwitch427"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>&#x231D; to &#x231C;a morphism in <epub:switch id="mathmlSwitch428"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>&#x231D;) and the associated path equivalences, as well as the identity and associativity laws. All of these can be added to the olog, at the expense of some clutter.</p>
<p class="noindent1-top" id="Rem_5-1-1-29"><em>Remark</em> 5.1.1.29. Perhaps it is already clear that category theory is very interconnected. It may feel like everything relates to everything, and this feeling may intensify as you go on. However, the relationships between different notions are rigorously defined, not random. Moreover, almost everything presented in this book can be formalized in a proof system like <span class="underline">Coq</span> (the most obvious exceptions being things like the readability requirement of ologs and the modeling of scientific applications).</p>
<p>Whenever you feel cognitive vertigo, use the interplay between examples and formal definitions to solidify your understanding. Go through each example, making sure it conforms to the definitions or theorems it purports to exemplify.</p>
</section>
</section>

<section title="Functors">
<h2 class="level2" id="lev_5-1-2"><strong>5.1.2&#160;&#160;&#160;Functors</strong></h2>
<p class="noindent">A category <epub:switch id="mathmlSwitch429"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi><mo>&#x003D;</mo><mo>(</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo><mo>,</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>,</mo><mi mathvariant="italic">dom</mi><mo>,</mo><mi mathvariant="italic">cod</mi><mo>,</mo><mi mathvariant="italic">ids</mi><mo>,</mo><mi mathvariant="italic">comp</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, involves a set of objects, a set of morphisms, a notion of domains and codomains, a notion of identity morphisms, and <a id="p174"></a>a composition formula. For two categories to be comparable, these various components should be appropriately comparable.</p>
<p class="noindent1-top-def" id="Def_5-1-2-1"><strong>Definition 5.1.2.1</strong>. Let <epub:switch id="mathmlSwitch430"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch431"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be categories. A <em>functor F from</em> <epub:switch id="mathmlSwitch432"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>to</em> <epub:switch id="mathmlSwitch433"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, denoted <epub:switch id="mathmlSwitch434"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>&#x2192;</mo><mi mathvariant="script">C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, is defined as follows: One announces some constituents (A. on-objects part, B. on-morphisms part) and shows that they conform to some laws (1. preservation of identities, 2. preservation of composition). Specifically, one announces</p>
<p class="nl2-list">A. a function <epub:switch id="mathmlSwitch435"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi>F</mi><mo stretchy='false'>)</mo><mo>:</mo><mo>&#x2009;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="script">C</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="script">C</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, sometimes denoted simply <epub:switch id="mathmlSwitch436"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mo>&#x2009;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="script">C</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="script">C</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>;</p>
<p class="nl2-list">B. for every pair of objects <epub:switch id="mathmlSwitch437"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>,</mo><mi>d</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, a function</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch438"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi>F</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy='false'>)</mo><mo>:</mo><mtext>&#x2009;</mtext><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant="script">C</mi><mo>&#x2032;</mo></mrow></msub><mo stretchy='false'>(</mo><mi>F</mi><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>,</mo><mi>F</mi><mo stretchy='false'>(</mo><mi>d</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>,</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="nl2-list-para">sometimes denoted simply <epub:switch id="mathmlSwitch439"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant="script">C</mi><mo>&#x2032;</mo></mrow></msub><mo stretchy='false'>(</mo><mi>F</mi><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>,</mo><mi>F</mi><mo stretchy='false'>(</mo><mi>d</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="noindent1-top">One must then show that the following <em>functor laws</em> hold:</p>
<ol class="olindent">
<li>Identities are preserved by <em>F</em>, that is, for any object <epub:switch id="mathmlSwitch440"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we have <em>F</em>(id<em><sub>c</sub></em>) &#x003D; id<sub><em>F</em>(<em>c</em>)</sub>.</li>
<li class="litop">Composition is preserved by <em>F</em>, that is, for any objects <epub:switch id="mathmlSwitch441"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>b</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and morphisms <em>g</em>: <em>b</em> &#x2192; <em>c</em> and <em>h</em>: <em>c</em> &#x2192; <em>d</em>, we have <em>F</em>(<em>h</em> &#x25CB; <em>g</em>) &#x003D; <em>F</em>(<em>h</em>) &#x25CB; <em>F</em>(<em>g</em>).</li>
</ol>
<p class="noindent1-top" id="Exa_5-1-2-2"><em>Example</em> 5.1.2.2 (Monoids have underlying sets). Recall from Definition <a href="chapter004.html#Def_4-1-1-1">4.1.1.1</a> that if <epub:switch id="mathmlSwitch442"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> &#x003D; (<em>M</em>, <em>e</em>, &#x22C6;) is a monoid, then <em>M</em> is a set. And recall from Definition <a href="chapter004.html#Def_4-1-4-1">4.1.4.1</a> that if <epub:switch id="mathmlSwitch443"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo>:</mo><mi mathvariant="script">M</mi><mo>&#x2192;</mo><mi mathvariant="script">M</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a monoid homomorphism, then <em>f</em>: <em>M</em> &#x2192; <em>M</em>&#x2032; is a function. Thus we can define a functor</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch444"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>U</mi><mo>:</mo><mtext mathvariant="bold">Mon</mtext><mo>&#x2192;</mo><mtext mathvariant="bold">Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top">The on-objects part of <em>U</em> sends every monoid to its underlying set, <epub:switch id="mathmlSwitch445"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>U</mi><mo>(</mo><mi mathvariant="script">M</mi><mo>)</mo><mo>&#x003D;</mo><mi>M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and sends every monoid homomorphism to its underlying function <em>U</em>(<em>f</em>) &#x003D; <em>f</em>. It is easy to check that the functor laws hold, so <em>U</em> is indeed a functor.</p>
<p>Given two monoids <epub:switch id="mathmlSwitch446"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi><mo>&#x003D;</mo><mo>(</mo><mi>M</mi><mo>,</mo><mi>e</mi><mo>,</mo><mo>&#x22C6;</mo><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch447"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi><mo>&#x2032;</mo><mo>&#x003D;</mo><mo>(</mo><mi>M</mi><mo>&#x2032;</mo><mo>,</mo><mi>e</mi><mo>&#x2032;</mo><mo>,</mo><mo>&#x22C6;</mo><mo>&#x2032;</mo><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, there may be many functions from <em>M</em> to <em>M</em>&#x2032; that do not arise from monoid homomorphisms. In other words, <epub:switch id="mathmlSwitch448"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>U</mi><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Mon</mtext></mrow></msub><mo stretchy='false'>(</mo><mi mathvariant="script">M</mi><mo>,</mo><mi mathvariant="script">M</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Set</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>M</mi><mo>,</mo><mi>M</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> may not be surjective. It is often useful to speak of such functions. For example, one could assign to every command in one video game <em>V</em> a command in another video game <em>V</em>&#x2032;, but this may not work in accordance with the monoid laws when performing a sequence of commands. By being able to speak of <em>M</em> as a set or of <epub:switch id="mathmlSwitch449"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> as a monoid, and understanding the relationship <em>U</em> between them, we can be clear about where we stand at all times in the discussion.</p>
<a id="p175"></a>
<p class="noindent1-top" id="Exa_5-1-2-3"><em>Example</em> 5.1.2.3 (Groups have underlying monoids). Recall that a group is just a monoid (<em>M</em>, <em>e</em>, &#x22C6;) with the extra property that every element <em>m</em> &#x2208; <em>M</em> has an inverse <em>m</em>&#x2032; &#x22C6; <em>m</em> &#x003D; <em>e</em> &#x003D; <em>m</em> &#x22C6; <em>m</em>&#x2032;. Thus to every group we can assign its <em>underlying monoid</em>. Similarly, a group homomorphism is just a monoid homomorphism of its underlying monoids. This means that there is a functor</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch450"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>U</mi><mo>:</mo><mtext mathvariant="bold">Grp</mtext><mo>&#x2192;</mo><mtext mathvariant="bold">Mon</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top">that sends every group or group homomorphism to its underlying monoid or monoid homomorphism. Identity and composition are preserved.</p>
<p class="noindent1-top" id="App_5-1-2-4"><em>Application</em> 5.1.2.4. Suppose you are a scientist working with symmetries. But then suppose that the symmetry breaks somewhere, or you add some extra observable that is not reversible under the symmetry. You want to seamlessly relax the requirement that every action be reversible without changing anything else. You want to know how you can proceed, or what is allowed. The answer is to simply pass from the category of groups (or group actions) to the category of monoids (or monoid actions).</p>
<p>We can also reverse this change of perspective. Recall that Example <a href="chapter004.html#Exa_4-1-2-9">4.1.2.9</a> discussed a monoid <em>M</em> controlling the actions of a video game character. The character position (<em>P</em>) could be moved up (<em>u</em>), moved down (<em>d</em>), or moved right (<em>r</em>). The path equivalences <em>P.u.d</em> &#x003D; <em>P</em> and <em>P.d.u</em> &#x003D; <em>P</em> imply that these two actions are mutually inverse, whereas moving right has no inverse. This, plus equivalences <em>P.r.u</em> &#x003D; <em>P.u.r</em> and <em>P.r.d</em> &#x003D; <em>P.d.r</em>, defined a monoid <em>M</em>.</p>
<p>Inside <em>M</em> is a submonoid <em>G</em>, which includes just upward and downward movement. It has one object, just like <em>M</em>, i.e., Ob(<em>M</em>) &#x003D; {<em>P</em>} &#x003D; Ob(<em>G</em>). But it has fewer morphisms. In fact, there is a monoid isomorphism <em>G</em> &#x2245; &#x2124; because we can assign to any movement in <em>G</em> the number of ups, e.g., <sub><em>P</em></sub>[<em>u</em>, <em>u</em>, <em>u</em>, <em>u</em>, <em>u</em>] is assigned the integer 5, <sub><em>P</em></sub>[<em>d</em>, <em>d</em>, <em>d</em>] is assigned the integer &#x2212;3, and <sub><em>P</em></sub>[<em>d</em>, <em>u</em>, <em>u</em>, <em>d</em>, <em>d</em>, <em>u</em>] is assigned the integer 0 &#x2208; &#x2124;. But &#x2124; is a group, because every integer has an inverse.</p>
<p>The upshot is that we can use functors to compare groups and monoids.</p>
<p class="noindent-top"><em>Slogan</em> 5.1.2.5.</p>
<div class="pull-quote">
<p class="pq-indent"><em>Out of all our available actions, some are reversible.</em></p>
</div>
<p class="noindent1-top" id="Exa_5-1-2-6"><em>Example</em> 5.1.2.6. Recall that we have a category <strong>Set</strong> of sets and a category <strong>Fin</strong> of finite sets. We said that <strong>Fin</strong> was a subcategory of <strong>Set</strong>. In fact, we can think of this subcategory relationship in terms of functors, just as we thought of the subset relationship in terms of functions in Example <a href="chapter002.html#Exa_2-1-2-4">2.1.2.4</a>. Recall that if we have a subset <em>S</em> &#x2286; <em>S</em>&#x2032;, then every element <em>s</em> &#x2208; <em>S</em> is an element of <em>S</em>&#x2032;, so we make a function <em>f</em>: <em>S</em> &#x2192; <em>S</em>&#x2032; such that <em>f</em>(<em>s</em>) &#x003D; <em>s</em> &#x2208; <em>S</em>&#x2032;.</p>
<a id="p176"></a>
<p>To give a functor <em>i</em>: <strong>Fin</strong> &#x2192; <strong>Set</strong>, we have to announce how it works on objects and how it works on morphisms. We begin by announcing a function <em>i</em>: Ob(<strong>Fin</strong>) &#x2192; Ob(<strong>Set</strong>). By analogy with the preceding, we have a subset Ob(<strong>Fin</strong>) &#x2286; Ob(<strong>Set</strong>). Hence every element <em>s</em> &#x2208; Ob(<strong>Fin</strong>) is an element of Ob(<strong>Set</strong>), so we put <em>i</em>(<em>s</em>) &#x003D; <em>s</em>. We also have to announce, for each pair of objects <em>s</em>, <em>s</em>&#x2032; &#x2208; Ob(<strong>Fin</strong>), a function</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch451"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>i</mi><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Fin</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>s</mi><mo>,</mo><mi>s</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Set</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>s</mi><mo>,</mo><mi>s</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top">But again, that is easy because we know by definition (see Example <a href="chapter005.html#Exa_5-1-1-4">5.1.1.4</a>) that these two sets are equal, Hom<strong><sub>Fin</sub></strong>(<em>s</em>, <em>s</em>&#x2032;) &#x003D; Hom<strong><sub>Set</sub></strong>(<em>s</em>, <em>s</em>&#x2032;). Hence we can simply take <em>i</em> to be the identity function on morphisms. It is evident that identities and compositions are preserved by <em>i</em>. Therefore, we have defined a functor <em>i</em>.</p>
<p class="noindent1-top" id="Rem_5-1-2-7"><em>Remark</em> 5.1.2.7. Recall that any group is just a monoid, except that it has an extra property: every element has an inverse. Thus one can start with a group, &#x201C;forget&#x201D; the fact that it is a group and remember only that it is a monoid. Doing this is functorial&#x2014;Example <a href="chapter005.html#Exa_5-1-2-3">5.1.2.3</a> discussed it as a functor <em>U</em>: <strong>Grp</strong> &#x2192; <strong>Mon</strong>. We say that <em>U</em> is a <em>forgetful functor</em>. There is also a forgetful functor <strong>Mon</strong> &#x2192; <strong>Set</strong> and so <strong>Grp</strong> &#x2192; <strong>Set</strong>.</p>
<p class="noindent1-top"><em>Slogan</em> 5.1.2.8.</p>
<div class="pull-quote">
<p class="pq-indent"><em>You can use a smartphone as a paperweight.</em></p>
</div>
<p>Colloquially, people often say things like, &#x201C;Carol wears many hats&#x201D; to mean that Carol acts in different roles, even though substantively she is somehow the same. The <em>hat</em> Carol currently wears is the analogous to the category, or context of interaction, that she is currently in.</p>
<p class="noindent1-top-exe" id="Exe_5-1-2-9"><em>Exercise</em> 5.1.2.9.</p>
<p>A partial order is just a preorder with a special property. A linear order is just a partial order with a special property.</p>
<p class="nl1-list">a. Is there a useful functor <strong>FLin</strong> &#x2192; <strong>PrO</strong>?</p>
<p class="nl1-list">b. Is there a useful functor <strong>PrO</strong> &#x2192; <strong>FLin</strong>?</p>

<p class="noindent1-top-pro" id="Pro_5-1-2-10"><strong>Proposition 5.1.2.10</strong> (Preorders to graphs). <em>Let</em> <strong>PrO</strong> <em>be the category of preorders and</em> <strong>Grph</strong> <em>be the category of graphs. There is a functor P</em>: <strong>PrO</strong> &#x2192; <strong>Grph</strong> <em>such that for any preorder</em> <epub:switch id="mathmlSwitch452"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">X</mi><mo>&#x003D;</mo><mo>(</mo><mi>X</mi><mo>,</mo><mo> &#x2A7D;</mo><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <em>the graph</em> <epub:switch id="mathmlSwitch453"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>P</mi><mo>(</mo><mi mathvariant="script">X</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>has vertices X</em>.</p>
<a id="p177"></a>
<p class="noindent1-top"><em>Proof.</em> Given a preorder <epub:switch id="mathmlSwitch454"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">X</mi><mo>&#x003D;</mo><mo>(</mo><mi>X</mi><mo>,</mo><msub><mrow><mo> &#x2A7D;</mo></mrow><mi>X</mi></msub><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we can make a graph <epub:switch id="mathmlSwitch455"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>(</mo><mi mathvariant="script">X</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> with vertices <em>X</em> and an arrow <em>x</em> &#x2192; <em>x</em>&#x2032; whenever <em>x</em>  &#x2A7D;<em><sub>X</sub> x</em>&#x2032;, as in Remark <a href="chapter004.html#Rem_4-4-1-10">4.4.1.10</a>. More precisely, the preorder  &#x2A7D;<em><sub>X</sub></em> is a relation, i.e., a subset <epub:switch id="mathmlSwitch456"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>R</mi><mi mathvariant="script">X</mi></msub><mo>&#x2286;</mo><mi>X</mi><mo>&#x00D7;</mo><mi>X</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, which we think of as a function <epub:switch id="mathmlSwitch457"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>i</mi><mo>:</mo><msub><mi>R</mi><mi mathvariant="script">X</mi></msub><mo>&#x2192;</mo><mi>X</mi><mo>&#x00D7;</mo><mi>X</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Composing with projections <em>&#x03C0;</em><sub>1</sub>, <em>&#x03C0;</em><sub>2</sub>: <em>X</em> &#x00D7; <em>X</em> &#x2192; <em>X</em> gives</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch458"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd><mrow><mi>s</mi><mi>r</mi><msub><mi>c</mi><mi mathvariant="script">X</mi></msub><mo>&#x2254;</mo><msub><mi>&#x03C0;</mi><mn>1</mn></msub><mo>&#x25CB;</mo><mi>i</mi><mo>:</mo><msub><mi>R</mi><mi mathvariant="script">X</mi></msub><mo>&#x2192;</mo><mi>X</mi></mrow></mtd><mtd><mrow><mtext>and</mtext></mrow></mtd><mtd><mrow><mi>t</mi><mi>g</mi><msub><mi>t</mi><mi mathvariant="script">X</mi></msub><mo>&#x2254;</mo><msub><mi>&#x03C0;</mi><mn>2</mn></msub><mo>&#x25CB;</mo><mi>i</mi><mo>:</mo><msub><mi>R</mi><mi mathvariant="script">X</mi></msub><mo>&#x2192;</mo><mi>X</mi><mo>.</mo></mrow></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top">Then we put <epub:switch id="mathmlSwitch459"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>(</mo><mi mathvariant="script">X</mi><mo>)</mo><mo>&#x2254;</mo><mo>(</mo><mi>X</mi><mo>,</mo><msub><mrow><mi>R</mi></mrow><mi mathvariant="script">X</mi></msub><mo>,</mo><msub><mrow><mi mathvariant="italic">src</mi></mrow><mi mathvariant="script">X</mi></msub><mo>,</mo><msub><mrow><mi mathvariant="italic">tgt</mi></mrow><mi mathvariant="script">X</mi></msub><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. This gives us a function <em>F</em>: Ob(<strong>PrO</strong>) &#x2192; Ob(<strong>Grph</strong>).</p>

<p>Suppose now that <epub:switch id="mathmlSwitch460"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo>:</mo><mi mathvariant="script">X</mi><mo>&#x2192;</mo><mi mathvariant="script">Y</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a preorder morphism, where <epub:switch id="mathmlSwitch461"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">Y</mi><mo>&#x003D;</mo><mo>(</mo><mi>Y</mi><mo>,</mo><msub><mrow><mo> &#x2A7D;</mo></mrow><mi>Y</mi></msub><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. This is a function <em>f</em>: <em>X</em> &#x2192; <em>Y</em> such that for any (<em>x</em>, <em>x</em>&#x2032;) &#x2208; <em>X</em> &#x00D7;<em>X</em>, if <em>x</em>  &#x2A7D;<em><sub>X</sub> x</em>&#x2032;, then <em>f</em>(<em>x</em>)  &#x2A7D; <em>f</em>(<em>x</em>&#x2032;). But that is the same as saying that there exists a dotted arrow making the following diagram of sets commute</p>
<p class="fig-img"><img src="images/Art_P151.jpg" alt="art"/></p>
<p class="noindent1-top">(Note that there cannot be two different dotted arrows making that diagram commute because <epub:switch id="mathmlSwitch462"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>R</mi><mi mathvariant="script">Y</mi></msub><mo>&#x2192;</mo><mi>Y</mi><mo>&#x00D7;</mo><mi>Y</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a monomorphism.) This commutative square is precisely what is needed for a graph homomorphism, as shown in Exercise <a href="chapter004.html#Exe_4-3-3-7">4.3.3.7</a>. Thus, we have defined <em>F</em> on objects and on morphisms. It is clear that <em>F</em> preserves identity and composition.</p>
<p class="noindent1-top-exe" id="Exe_5-1-2-11"><em>Exercise</em> 5.1.2.11.</p>
<p>Proposition <a href="chapter005.html#Pro_5-1-2-10">5.1.2.10</a> gave a functor <em>P</em>: <strong>PrO</strong> &#x2192; <strong>Grph</strong>.</p>
<p class="nl1-list">a. Is every graph <em>G</em> &#x2208; Ob(<strong>Grph</strong>) in the image of <em>P</em> (or more precisely, is the function</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch463"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mrow><mo>(</mo><mi>P</mi><mo>)</mo></mrow><mo>:</mo><mtext>Ob</mtext><mrow><mo>(</mo><mrow><mstyle mathvariant='bold'><mi>P</mi><mi>r</mi><mi>O</mi></mstyle></mrow><mo>)</mo></mrow><mo>&#x2192;</mo><mtext>Ob</mtext><mrow><mo>(</mo><mrow><mstyle mathvariant='bold'><mi>G</mi><mi>r</mi><mi>p</mi><mi>h</mi></mstyle></mrow><mo>)</mo></mrow></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="nl1-list-para">surjective)?</p>
<p class="nl1-list">b. If so, why; if not, name a graph not in the image.</p>
<p class="nl1-list">c. Suppose that <em>G</em>&#x2032; and <em>H</em>&#x2032; are preorders with graph formats <em>P</em>(<em>G</em>&#x2032;) &#x003D; <em>G</em> and <em>P</em>(<em>H</em>&#x2032;) &#x003D; <em>H</em>. Is every graph homomorphism <em>f</em>: <em>G</em> &#x2192; <em>H</em> in the image of</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch464"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi>P</mi></msub><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mstyle mathvariant='bold'><mi>P</mi><mi>r</mi><mi>O</mi></mstyle></mrow></msub><mrow><mo>(</mo><mrow><mi>G</mi><mo>&#x2032;</mo><mo>,</mo><mi>H</mi><mo>&#x2032;</mo></mrow><mo>)</mo></mrow><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mstyle mathvariant='bold'><mi>G</mi><mi>r</mi><mi>p</mi><mi>h</mi></mstyle></mrow></msub><mrow><mo>(</mo><mrow><mi>G</mi><mo>,</mo><mi>H</mi></mrow><mo>)</mo></mrow><mo>?</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="nl1-list-para">In other words, does every graph homomorphism between <em>G</em> and <em>H</em> come from a preorder homomorphism between <em>G</em>&#x2032; and <em>H</em>&#x2032;?</p>
<a id="p178"></a>
<p class="noindent-top" id="Rem_5-1-2-12"><em>Remark</em> 5.1.2.12. There is a functor <em>W</em>: <strong>PrO</strong> &#x2192; <strong>Set</strong> sending (<em>X</em>,  &#x2A7D;) to <em>X</em>. There is a functor <em>T</em>: <strong>Grph</strong> &#x2192; <strong>Set</strong> sending (<em>V</em>, <em>A</em>, <em>src</em>, <em>tgt</em>) to <em>V</em>. When we study the category of categories (see Section <a href="chapter005.html#lev_5-1-2-30">5.1.2.30</a>), it will be clear that Proposition <a href="chapter005.html#Pro_5-1-2-10">5.1.2.10</a> can be summarized as a commutative triangle in <strong>Cat</strong>,</p>
<p class="fig-img"><img src="images/Art_P152.jpg" alt="art"/></p>
<p class="noindent1-top-exe" id="Exe_5-1-2-13"><em>Exercise</em> 5.1.2.13.</p>
<p>Recall from (<a href="chapter002.html#lev_2-3">2.3</a>) that every function <em>f</em>: <em>A</em> &#x2192; <em>B</em> has an image, im<em><sub>f</sub></em>(<em>A</em>) &#x2286; <em>B</em>. Use this idea and Example <a href="chapter004.html#Exa_4-4-1-16">4.4.1.16</a> to construct a functor <em>Im</em>: <strong>Grph</strong> &#x2192; <strong>PrO</strong> such that for any graph <em>G</em> &#x003D; (<em>V</em>, <em>A</em>, <em>src</em>, <em>tgt</em>), the vertices of <em>G</em> are the elements of <em>Im</em>(<em>G</em>). That is, find some ordering  &#x2A7D;<em><sub>G</sub></em>, such that we have <em>Im</em>(<em>G</em>) &#x003D; (<em>V</em>,  &#x2A7D;<em><sub>G</sub></em>).</p>
<p class="noindent1-top-sol"><em>Solution</em> 5.1.2.13.</p>
<p>Suppose given an object <em>G</em> &#x2208; Ob(<strong>Grph</strong>), i.e., a graph <em>G</em> &#x003D; (<em>V</em>, <em>A</em>, <em>src</em>, <em>tgt</em>). The source and target functions combine to give a function &#x2329;<em>src</em>, <em>tgt</em>&#x232A;: <em>A</em> &#x2192; <em>V</em> &#x00D7; <em>V</em>. Its image is a subset <em>R</em> &#x2286; <em>V</em> &#x00D7; <em>V</em>, i.e., a binary relation. But <em>R</em> is not necessarily a preorder. We can remedy that by using the preorder <epub:switch id="mathmlSwitch465"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent='true'><mi>R</mi><mo stretchy='true'>&#x00AF;</mo></mover></mrow></math></epub:case><epub:default></epub:default></epub:switch> generated by <em>R</em>, as in Example <a href="chapter004.html#Exa_4-4-1-16">4.4.1.16</a>. On objects we put <em>Im</em>(<em>G</em>) &#x2254; <epub:switch id="mathmlSwitch466"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent='true'><mi>R</mi><mo stretchy='true'>&#x00AF;</mo></mover></mrow></math></epub:case><epub:default></epub:default></epub:switch>. One way to understand this preorder is that it has as elements <em>V</em>, the vertices of <em>G</em>, and it has <em>v</em>  &#x2A7D; <em>v</em>&#x2032; if and only if there exists a path from <em>v</em> to <em>v</em>&#x2032; in <em>G</em>.</p>

<p>Given a morphism <em>f</em>: <em>G</em> &#x2192; <em>G</em>&#x2032;, we need to provide a preorder morphism <em>Im</em>(<em>G</em>) &#x2192; <em>Im</em>(<em>G</em>&#x2032;). The obvious choice is to use <em>f</em><sub>0</sub> (what <em>f</em> does on vertices), but we need to check that it preserves the order. This is clear because graph morphisms send paths to paths&#x2014;if there was a path from <em>v</em> to <em>v</em>&#x2032; in <em>G</em>, there will be one from <em>f</em>(<em>v</em>) to <em>f</em>(<em>v</em>&#x2032;). We need to check that <em>Im</em>(id<em><sub>G</sub></em>) &#x003D; id<sub><em>Im</em>(<em>G</em>)</sub>, but this is straightforward.</p>
<p class="noindent1-top-exe" id="Exe_5-1-2-14"><em>Exercise</em> 5.1.2.14.</p>
<p>In Exercise <a href="chapter005.html#Exe_5-1-2-13">5.1.2.13</a> you constructed a functor <em>Im</em>: <strong>Grph</strong> &#x2192; <strong>PrO</strong>. What is the <a id="p179"></a>preorder <em>Im</em>(<em>G</em>) when <em>G</em> &#x2208; Ob(<strong>Grph</strong>) is the following graph?</p>
<p class="fig-img"><img src="images/Art_P153.jpg" alt="art"/></p>
<p class="noindent1-top-exe" id="Exe_5-1-2-15"><em>Exercise</em> 5.1.2.15.</p>
<p>Consider the functor <em>Im</em>: <strong>Grph</strong> &#x2192; <strong>PrO</strong> constructed in Exercise <a href="chapter005.html#Exe_5-1-2-13">5.1.2.13</a>.</p>

<p class="nl1-list">a. Is every preorder <epub:switch id="mathmlSwitch467"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">X</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo>(</mo><mtext mathvariant="bold">PrO</mtext><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> in the image of <em>Im</em> (or more precisely, in the image of Ob(<em>Im</em>): Ob(<strong>Grph</strong>) &#x2192; Ob(<strong>PrO</strong>))?</p>
<p class="nl1-list">b. If so, why; if not, name a preorder not in the image.</p>
<p class="nl1-list">c. Suppose that <epub:switch id="mathmlSwitch468"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">X</mi><mo>&#x2032;</mo><mo>,</mo><mi mathvariant="script">Y</mi><mo>&#x2032;</mo><mo>&#x2208;</mo><mtext>Ob</mtext><mo>(</mo><mtext mathvariant="bold">Grph</mtext><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> are graphs, with <epub:switch id="mathmlSwitch469"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">X</mi><mo>&#x2254;</mo><mi mathvariant="italic">Im</mi><mo>(</mo><mi mathvariant="script">X</mi><mo>&#x2032;</mo><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch470"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">Y</mi><mo>&#x2254;</mo><mi mathvariant="italic">Im</mi><mo>(</mo><mi mathvariant="script">Y</mi><mo>&#x2032;</mo><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> in the preorder format. Is every preorder morphism <epub:switch id="mathmlSwitch471"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo>:</mo><mi mathvariant="script">X</mi><mo>&#x2192;</mo><mi mathvariant="script">Y</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> in the image of</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch472"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi>I</mi><mi>m</mi></mrow></msub><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant='bold'>Grph</mi></mrow></msub><mrow><mo>(</mo><mrow><mi mathvariant="script">X</mi><mo>&#x2032;</mo><mo>,</mo><mi mathvariant="script">Y</mi><mo>&#x2032;</mo></mrow><mo>)</mo></mrow><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant='bold'>PrO</mi></mrow></msub><mrow><mo>(</mo><mrow><mi mathvariant="script">X</mi><mo>,</mo><mi mathvariant="script">Y</mi></mrow><mo>)</mo></mrow><mo>?</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="nl1-list-para">In other words, does every preorder homomorphism between <epub:switch id="mathmlSwitch473"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">X</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch474"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">Y</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> come from a graph homomorphism between <epub:switch id="mathmlSwitch475"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">X</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch476"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">Y</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>?</p>
<p class="noindent1-top-exe" id="Exe_5-1-2-16"><em>Exercise</em> 5.1.2.16.</p>
<p>We have functors <em>P</em>: <strong>PrO</strong> &#x2192; <strong>Grph</strong> and <em>Im</em>: <strong>Grph</strong> &#x2192; <strong>PrO</strong>.</p>
<p class="nl1-list">a. What can you say about <em>Im</em> &#x25CB; <em>P</em>: <strong>PrO</strong> &#x2192; <strong>PrO</strong>?</p>
<p class="nl1-list">b. What can you say about <em>P</em> &#x25CB; <em>Im</em>: <strong>Grph</strong> &#x2192; <strong>Grph</strong>?</p>

<p class="noindent1-top-exe" id="Exe_5-1-2-17"><em>Exercise</em> 5.1.2.17.</p>
<p>Consider the functors <em>P</em>: <strong>PrO</strong> &#x2192; <strong>Grph</strong> and <em>Im</em>: <strong>Grph</strong> &#x2192; <strong>PrO</strong>. And consider the chain graph [<em>n</em>] of length <em>n</em> from Example <a href="chapter004.html#Exa_4-3-1-8">4.3.1.8</a> and the linear order [<em>n</em>] of length <em>n</em> from <a id="p180"></a>Example <a href="chapter004.html#Exa_4-4-1-7">4.4.1.7</a>. To differentiate the two, let&#x2019;s rename them for this exercise as [<em>n</em>]<strong><sub>Grph</sub></strong> &#x2208; Ob(<strong>Grph</strong>) and [<em>n</em>]<strong><sub>PrO</sub></strong> &#x2208; Ob(<strong>PrO</strong>). We see a similarity between [<em>n</em>]<strong><sub>Grph</sub></strong> and [<em>n</em>]<strong><sub>PrO</sub></strong>, and we might hope that the functors help formalize this similarity. That is, we might hope that one of the following hold:</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch477"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd><mrow><mi>P</mi><mrow><mo>(</mo><mrow><msub><mrow><mrow><mo>[</mo> <mi>n</mi> <mo>]</mo></mrow></mrow><mrow><mtext mathvariant="bold">PrO</mtext></mrow></msub></mrow><mo>)</mo></mrow><msup><mo>&#x2245;</mo><mo>?</mo></msup><msub><mrow><mrow><mo>[</mo> <mi>n</mi> <mo>]</mo></mrow></mrow><mrow><mtext mathvariant="bold">Grph</mtext></mrow></msub></mrow></mtd><mtd><mrow><mtext>or</mtext></mrow></mtd><mtd><mrow><mi>I</mi><mi>m</mi><mrow><mo>(</mo><mrow><msub><mrow><mrow><mo>[</mo> <mi>n</mi> <mo>]</mo></mrow></mrow><mrow><mtext mathvariant="bold">Grph</mtext></mrow></msub></mrow><mo>)</mo></mrow><msup><mo>&#x2245;</mo><mo>?</mo></msup><msub><mrow><mrow><mo>[</mo> <mi>n</mi> <mo>]</mo></mrow></mrow><mrow><mtext mathvariant="bold">PrO</mtext></mrow></msub></mrow><mo>.</mo></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top">Do either, both, or neither of these hold?</p>
<p class="noindent1-top" id="Rem_5-1-2-18"><em>Remark</em> 5.1.2.18. In the course announcement for MIT&#x2019;s 18-S996 course, I wrote the following:</p>
<div class="pull-quote">
<p class="pq-noindent">It is often useful to focus one&#x2019;s study by viewing an individual thing, or a group of things, as though it exists in isolation. However, the ability to rigorously change our point of view, seeing our object of study in a different context, often yields unexpected insights. Moreover, this ability to change perspective is indispensable for effectively communicating with and learning from others. It is the relationships between things, rather than the things in and by themselves, that are responsible for generating the rich variety of phenomena we observe in the physical, informational, and mathematical worlds.</p>
</div>
<p class="noindent1-top">This holds at many different levels. For example, one can study a group (in the sense of Definition <a href="chapter004.html#Def_4-2-1-1">4.2.1.1</a>) in isolation, trying to understand its subgroups or its automorphisms, and this is mathematically interesting. But one can also view it as a quotient of something else, or as a subgroup of something else. One can view the group as a monoid and look at monoid homomorphisms to or from it. One can look at the group in the context of symmetries by seeing how it acts on sets. These changes of viewpoint are all clearly and formally expressible within category theory. We know how the different changes of viewpoint compose and how they fit together in a larger context.</p>
<p class="noindent1-top-exe" id="Exe_5-1-2-19"><em>Exercise</em> 5.1.2.19.</p>
<p class="nl1-list">a. Is the preceding quotation also true in your scientific discipline of expertise? How so?</p>
<p class="nl1-list">b. Can you imagine a way that category theory can help catalogue the kinds of relationships or changes of viewpoint that exist in your discipline?</p>
<p class="nl1-list">c. What kinds of structures that you use often deserve to be better formalized?</p>
<a id="p181"></a>
<p class="noindent1-top" id="Exa_5-1-2-20"><em>Example</em> 5.1.2.20 (Free monoids). Let <em>G</em> be a set. Definition <a href="chapter004.html#Def_4-1-1-15">4.1.1.15</a> defined a monoid List(<em>G</em>), called the free monoid on <em>G</em>. Given a function <em>f</em>: <em>G</em> &#x2192; <em>G</em>&#x2032;, there is an induced function List(<em>f</em>): List(<em>G</em>) &#x2192; List(<em>G</em>&#x2032;), and this preserves the identity element [ ] and concatenation of lists, so List(<em>f</em>) is a monoid homomorphism. It is easy to check that List: <strong>Set</strong> &#x2192; <strong>Mon</strong> is a functor.</p>
<p class="noindent1-top" id="App_5-1-2-21"><em>Application</em> 5.1.2.21. Application <a href="chapter002.html#App_2-1-2-16">2.1.2.16</a> discussed an isomorphism Nuc<sub>DNA</sub> &#x2245; Nuc<sub>RNA</sub> given by RNA transcription. Applying the functor List, we get a function</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch478"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>List</mtext><mo stretchy='false'>(</mo><msub><mrow><mtext>Nuc</mtext></mrow><mrow><mtext>DNA</mtext></mrow></msub><mo stretchy='false'>)</mo><mover><mo>&#x2192;</mo><mo>&#x2245;</mo></mover><mtext>List</mtext><mo stretchy='false'>(</mo><msub><mrow><mtext>Nuc</mtext></mrow><mrow><mtext>RNA</mtext></mrow></msub><mo stretchy='false'>)</mo><mo>,</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top">which will send sequences of DNA nucleotides to sequences of RNA nucleotides, and vice versa. This is performed by polymerases.</p>
<p class="noindent1-top-exe" id="Exe_5-1-2-22"><em>Exercise</em> 5.1.2.22.</p>
<p>Let <em>G</em> &#x003D; {1, 2, 3, 4, 5}, <em>G</em>&#x2032; &#x003D; {<em>a</em>, <em>b</em>, <em>c</em>}, and let <em>f</em>: <em>G</em> &#x2192; <em>G</em>&#x2032; be given by the sequence (<em>a</em>, <em>c</em>, <em>b</em>, <em>a</em>, <em>c</em>).<sup><a id="endnote_ref_5" href="chapter005.html#endnote_5">5</a></sup> Then if <em>L</em> &#x003D; [1, 1, 3, 5, 4, 5, 3, 2, 4, 1], what is List(<em>f</em>)(<em>L</em>)?</p>
<p class="noindent1-top-sol"><em>Solution</em> 5.1.2.22.</p>
<p>Use <em>f</em> to translate <em>L</em>, entry by entry:</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch479"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>List</mtext><mrow><mo>(</mo><mi>f</mi><mo>)</mo></mrow><mrow><mo>(</mo> <mrow><mrow><mo>[</mo> <mrow><mn>1</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>5</mn><mo>,</mo><mn>4</mn><mo>,</mo><mn>5</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>4</mn><mo>,</mo><mn>1</mn></mrow> <mo>]</mo></mrow><mo>=</mo><mrow><mo>[</mo> <mrow><mi>a</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo>,</mo><mi>a</mi><mo>,</mo><mi>a</mi></mrow> <mo>]</mo></mrow></mrow></mrow><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top"><em>Remark</em> 5.1.2.23 (Questionable functor). Recall from Remark <a href="chapter005.html#Rem_5-1-1-6">5.1.1.6</a> that a questionable category is defined to be a structure that looks like a category (objects, morphisms, identities, composition formula), but which is not required to satisfy any laws. Similarly, given categories (or questionable categories) <epub:switch id="mathmlSwitch480"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch481"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we can define a questionable functor <em>F</em>: <epub:switch id="mathmlSwitch482"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> &#x2192; <epub:switch id="mathmlSwitch483"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> to consist of</p>
<p class="nl2-list">A. a function <epub:switch id="mathmlSwitch484"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo>(</mo><mi>F</mi><mo>)</mo><mo>:</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo><mo>&#x2192;</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>&#x2032;</mo><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, sometimes denoted simply <epub:switch id="mathmlSwitch485"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo><mo>&#x2192;</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>&#x2032;</mo><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>;</p>
<p class="nl2-list">B. for every pair of objects <em>c</em>, <em>d</em> &#x2208; Ob(<epub:switch id="mathmlSwitch486"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>), a function</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch487"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi>F</mi></msub><mrow><mo>(</mo><mrow><mi>c</mi><mo>,</mo><mi>d</mi></mrow><mo>)</mo></mrow><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mrow><mo>(</mo><mrow><mi>c</mi><mo>,</mo><mi>d</mi></mrow><mo>)</mo></mrow><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant="script">C</mi><mo>&#x2032;</mo></mrow></msub><mrow><mo>(</mo><mrow><mi>F</mi><mrow><mo>(</mo><mi>c</mi><mo>)</mo></mrow><mo>,</mo><mi>F</mi><mrow><mo>(</mo><mi>d</mi><mo>)</mo></mrow></mrow><mo>)</mo></mrow><mo>,</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="nl2-list-para">sometimes denoted simply <epub:switch id="mathmlSwitch488"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant="script">C</mi><mo>&#x2032;</mo></mrow></msub><mo stretchy='false'>(</mo><mi>F</mi><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>,</mo><mi>F</mi><mo stretchy='false'>(</mo><mi>d</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<a id="p182"></a>
<p class="noindent1-top-exe" id="Exe_5-1-2-24"><em>Exercise</em> 5.1.2.24.</p>
<p>We can rephrase the notion of functor in terms compatible with Exercise <a href="chapter005.html#Exe_5-1-1-27">5.1.1.27</a>. We begin by saying that a functor <epub:switch id="mathmlSwitch489"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>&#x2192;</mo><mi mathvariant="script">C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> consists of two functions,</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch490"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd><mrow><mtext>Ob</mtext><mrow><mo>(</mo><mi>F</mi><mo>)</mo></mrow><mo>:</mo><mtext>Ob</mtext><mrow><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo></mrow><mo>&#x2192;</mo><mtext>Ob</mtext><mrow><mo>(</mo><mi mathvariant="script">C</mi><mo>&#x2032;</mo><mo>)</mo></mrow></mrow></mtd><mtd><mrow><mtext>and</mtext></mrow></mtd><mtd><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi>F</mi></msub><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant="script">C</mi><mo>&#x2032;</mo></mrow> </msub></mrow></mtd></mtr></mtable><mo>,</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top">called the <em>on-objects part</em> and the <em>on-morphisms part</em> respectively. They must follow some rules, expressed by the commutativity of the following squares in <strong>Set</strong>:</p>
<p class="fig-img" id="eq_5-5"><img src="images/Art_P154.jpg" alt="art"/></p>
<p class="fig-img" id="eq_5-6"><img src="images/Art_P154a.jpg" alt="art"/></p>
<p class="nl1-list">a. In the right-hand diagram in (<a href="chapter005.html#eq_5-6">5.6</a>), where does the (unlabeled) left-hand function come from? Hint: Use Exercise <a href="chapter003.html#Exe_3-2-1-20">3.2.1.20</a>.</p>
<p>Consider diagram (<a href="chapter005.html#eq_5-3">5.3</a>); imagine it as though it were contained in a pane of glass. Then imagine a parallel pane of glass involving <epub:switch id="mathmlSwitch491"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> in place of <epub:switch id="mathmlSwitch492"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> everywhere.</p>
<p class="nl1-list">b. Draw arrows from the <epub:switch id="mathmlSwitch493"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> pane to the <epub:switch id="mathmlSwitch494"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> pane, each labeled Ob(<em>F</em>), Hom<em><sub>F</sub></em>, and so on, as appropriate.</p>
<p class="nl1-list">c. If <em>F</em> is a functor, i.e., it satisfies (<a href="chapter005.html#eq_5-5">5.5</a>) and (<a href="chapter005.html#eq_5-6">5.6</a>), do all the squares in your drawing commute?</p>

<p class="nl1-list">d. Does the definition of functor involve anything not captured in this setup?</p>
<p class="noindent1-top-sol"><em>Solution</em> 5.1.2.24.</p>
<a id="p183"></a>
<p class="nl1-list">a. We have Hom<em><sub>F</sub></em>: Hom<em><sub>C</sub></em> &#x2192; Hom<em><sub>C&#x2032;</sub></em>, and since it commutes with <em>dom</em> and <em>cod</em>, we have the desired function, by Exercise <a href="chapter003.html#Exe_3-2-1-20">3.2.1.20</a>.</p>
<p class="nl1-list">b. Let <epub:switch id="mathmlSwitch495"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi><msub><mi>P</mi><mi mathvariant="script">C</mi></msub><mo>=</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><msub><mo>&#x00D7;</mo><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="script">C</mi><mo stretchy='false'>)</mo></mrow></msub><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> denote the set of composable pairs of arrows in <epub:switch id="mathmlSwitch496"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> (and similarly define <epub:switch id="mathmlSwitch497"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mi mathvariant="italic">CP</mi></mrow><mrow><mi mathvariant="script">C</mi><mo>&#x2032;</mo></mrow></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch498"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mi mathvariant="italic">CP</mi></mrow><mrow><mi>F</mi></mrow></msub><mo>:</mo><msub><mrow><mi mathvariant="italic">CP</mi></mrow><mrow><mi mathvariant="script">C</mi></mrow></msub><mo>&#x2192;</mo><msub><mrow><mi mathvariant="italic">CP</mi></mrow><mrow><mi mathvariant="script">C</mi><mo>&#x2032;</mo></mrow></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>). The two-pane diagram is a bit cluttered, but looks like this:</p>
<p class="fig-img"><img src="images/Art_P155.jpg" alt="art"/></p>
<p class="nl1-list">c. Yes.</p>
<p class="nl1-list">d. No, this is all one needs: functions <epub:switch id="mathmlSwitch499"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo>(</mo><mi>F</mi><mo>)</mo><mo>:</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo><mo>&#x2192;</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>&#x2032;</mo><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch500"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi>F</mi></msub><mo>:</mo><mtext>&#x2009;</mtext><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant="script">C</mi><mo>&#x2032;</mo></mrow></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>
such that all the squares commute.</p>
<p class="noindent1-top" id="Exa_5-1-2-25"><em>Example</em> 5.1.2.25 (Paths-graph). Let <em>G</em> &#x003D; (<em>V</em>, <em>A</em>, <em>src</em>, <em>tgt</em>) be a graph. We have a set Path<em><sub>G</sub></em> of paths in <em>G</em>, and functions <epub:switch id="mathmlSwitch501"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover accent='true'><mrow><mi>s</mi><mi>r</mi><mi>c</mi><mo>,</mo><mtext>&#x2009;</mtext></mrow><mo stretchy='true'>&#x00AF;</mo></mover><mover accent='true'><mrow><mi mathvariant="italic">tgt</mi></mrow><mo stretchy='true'>&#x00AF;</mo></mover><mo>:</mo><mtext>&#x2009;</mtext><msub><mrow><mtext>Path</mtext></mrow><mi>G</mi></msub><mo>&#x2192;</mo><mi>V</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>. That information is enough to define a new graph,</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch502"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Paths</mtext><mo stretchy='false'>(</mo><mi>G</mi><mo stretchy='false'>)</mo><mo>&#x2254;</mo><mo stretchy='false'>(</mo><mi>V</mi><mo>,</mo><msub><mrow><mtext>Path</mtext></mrow><mi>G</mi></msub><mo>,</mo><mover accent='true'><mrow><mi>s</mi><mi>r</mi><mi>c</mi><mo>,</mo><mtext>&#x2009;</mtext></mrow><mo stretchy='true'>&#x00AF;</mo></mover><mover accent='true'><mrow><mi mathvariant="italic">tgt</mi></mrow><mo stretchy='true'>&#x00AF;</mo></mover><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>

<p>Moreover, given a graph homomorphism <em>f</em>: <em>G</em> &#x2192; <em>G</em>&#x2032;, every path in <em>G</em> is sent under <em>f</em> to a path in <em>G</em>&#x2032;. So Paths: <strong>Grph</strong> &#x2192; <strong>Grph</strong> is a functor.</p>
<p class="noindent1-top-exe" id="Exe_5-1-2-26"><em>Exercise</em> 5.1.2.26.</p>
<a id="p184"></a>
<p class="nl1-list">a. Consider the graph <em>G</em> from Example <a href="chapter004.html#Exa_4-3-3-3">4.3.3.3</a>. Draw the paths-graph Paths(<em>G</em>) for <em>G</em>.</p>
<p class="nl1-list">b. Repeating part (a) for <em>G</em>&#x2032; from the same example would be hard, because the paths-graph Paths(<em>G</em>&#x2032;) has infinitely many arrows. However, the graph homomorphism <em>f</em>: <em>G</em> &#x2192; <em>G</em>&#x2032; does induce a morphism of paths-graphs Paths(<em>f</em>): Paths(<em>G</em>) &#x2192; Paths(<em>G</em>&#x2032;). How does that act on the vertices and arrows of Paths(<em>G</em>)?</p>
<p class="nl1-list">c. Given a graph homomorphism <em>f</em>: <em>G</em> &#x2192; <em>G</em>&#x2032; and two paths <em>p</em>: <em>v</em> &#x2192; <em>w</em> and <em>q</em>: <em>w</em> &#x2192; <em>x</em> in <em>G</em>, is it true that Paths(<em>f</em>) preserves the concatenation? Explain also what it means to say Paths(<em>f</em>) preserves the concatenation.</p>
<p class="noindent1-top-sol"><em>Solution</em> 5.1.2.26.</p>
<p class="nl1-list">a. Here are <em>G</em> and Paths(<em>G</em>).</p>
<p class="fig-img"><img src="images/Art_P156.jpg" alt="art"/></p>

<p class="nl1-list">b. For the reader&#x2019;s convenience, here is a copy of <em>f</em>: <em>G</em> &#x2192; <em>G</em>&#x2032;:</p>
<p class="fig-img"><img src="images/Art_P157.jpg" alt="art"/></p>
<a id="p185"></a>
<p class="nl1-list-para">By definition Paths(<em>f</em>) acts like <em>f</em> on the vertices, and arrow by arrow on paths. Here is the formal answer:</p>
<p class="fig-img"><img src="images/Art_P158.jpg" alt="art"/></p>
<p class="nl1-list">c. Yes, that is true. It means that <em>f</em>(<em>p</em>) &#x002B;&#x002B;<em>f</em>(<em>q</em>) &#x003D; <em>f</em>(<em>p</em> &#x002B;&#x002B;<em>q</em>), where &#x002B;&#x002B; denotes concatenation of paths.</p>
<p class="noindent1-top-exe" id="Exe_5-1-2-27"><em>Exercise</em> 5.1.2.27.</p>
<p>Suppose that <epub:switch id="mathmlSwitch503"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch504"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> are categories, <em>c</em>, <em>c</em>&#x2032; &#x2208; Ob(<epub:switch id="mathmlSwitch505"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>) are objects, and <em>F</em>: <epub:switch id="mathmlSwitch506"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> &#x2192; <epub:switch id="mathmlSwitch507"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a functor. Suppose that <em>c</em> and <em>c</em>&#x2032; are isomorphic in <epub:switch id="mathmlSwitch508"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Show that this implies that <em>F</em>(<em>c</em>) and <em>F</em>(<em>c</em>&#x2032;) are isomorphic in <epub:switch id="mathmlSwitch509"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>

<p class="noindent1-top-sol"><em>Solution</em> 5.1.2.27.</p>
<p>If <em>c</em> and <em>c</em>&#x2032; are isomorphic, that means there exists a morphism <em>f</em>: <em>c</em> &#x2192; <em>c</em>&#x2032; and a morphism <em>f</em>&#x2032;: <em>c</em>&#x2032; &#x2192; <em>c</em> in <epub:switch id="mathmlSwitch510"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, such that <em>f</em>&#x2032; &#x25CB; <em>f</em> &#x003D; id<em><sub>c</sub></em> and <em>f</em> &#x25CB; <em>f</em>&#x2032; &#x003D; id<em><sub>c&#x2032;</sub></em>. But then <em>F</em>(<em>f</em>): <em>F</em>(<em>c</em>) &#x2192; <em>F</em>(<em>c</em>&#x2032;) and <em>F</em>(<em>f</em>&#x2032;): <em>F</em>(<em>c</em>&#x2032;) &#x2192; <em>F</em>(<em>c</em>) are mutually inverse morphisms between <em>F</em>(<em>c</em>) and <em>F</em>(<em>c</em>&#x2032;). Indeed, since <em>F</em> preserves composition and identities, we have <em>F</em>(<em>f</em>&#x2032;) &#x25CB; <em>F</em>(<em>f</em>) &#x003D; <em>F</em>(<em>f</em>&#x2032; &#x25CB; <em>f</em>) &#x003D; <em>F</em>(id<em><sub>c</sub></em>) &#x003D; id<sub><em>F</em>(<em>c</em>)</sub> and <em>F</em>(<em>f</em>) &#x25CB; <em>F</em>(<em>f</em>&#x2032;) &#x003D; <em>F</em>(<em>f</em> &#x25CB; <em>f</em>&#x2032;) &#x003D; <em>F</em> (id<em><sub>c&#x2032;</sub></em>) &#x003D; id<em><sub>F</sub></em>(<em><sub>c&#x2032;</sub></em>). So <em>F</em>(<em>f</em>) is an isomorphism, which means that <em>F</em>(<em>c</em>) and <em>F</em>(<em>c</em>&#x2032;) are isomorphic in <epub:switch id="mathmlSwitch511"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="noindent1-top" id="Exa_5-1-2-28"><em>Example</em> 5.1.2.28. For any graph <em>G</em>, we can assign its set of length 1 loops <em>Eq</em>(<em>G</em>) as in Exercise <a href="chapter004.html#Exe_4-3-1-12">4.3.1.12</a>. This assignment is functorial in that given a graph homomorphism <em>G</em> &#x2192; <em>G</em>&#x2032;, there is an induced function <em>Eq</em>(<em>G</em>) &#x2192; <em>Eq</em>(<em>G</em>&#x2032;). Similarly, we can functorially assign <a id="p186"></a>the set of connected components of the graph, <em>Coeq</em>(<em>G</em>). In other words, <em>Eq</em>: <strong>Grph</strong> &#x2192; <strong>Set</strong> and <em>Coeq</em>: <strong>Grph</strong> &#x2192; <strong>Set</strong> are functors. The assignment of vertex set and arrow set are two more functors <strong>Grph</strong> &#x2192; <strong>Set</strong>.</p>
<p>Suppose you want to decide whether two graphs <em>G</em> and <em>G</em>&#x2032; are isomorphic. If the graphs have thousands of vertices and thousands of arrows, this could take a long time. However, the preceding functors, in combination with Exercise <a href="chapter005.html#Exe_5-1-2-27">5.1.2.27</a> give us some things to try.</p>
<p>The first thing to do is to count the number of loops of each, because these numbers are generally small. If the number of loops in <em>G</em> is different than the number of loops in <em>G</em>&#x2032;, then because functors preserve isomorphisms, <em>G</em> and <em>G</em>&#x2032; cannot be isomorphic. Similarly, one can count the number of connected components, again generally a small number. If the number of components in <em>G</em> is different than the number of components in <em>G</em>&#x2032;, then <em>G</em> &#x2247; <em>G</em>&#x2032;. Similarly, one can simply count the number of vertices or the number of arrows in <em>G</em> and <em>G</em>&#x2032;. These are all isomorphism invariants.</p>
<p>All this is a bit like trying to decide if a number is prime by checking if it is even, if its digits add up to a multiple of 3, or if it ends in a 5; these tests do not determine the answer, but they offer some level of discernment.</p>
<p class="noindent1-top" id="Rem_5-1-2-29"><em>Remark</em> 5.1.2.29. As mentioned, functors allow ideas in one domain to be rigorously imported to another. Example <a href="chapter005.html#Exa_5-1-2-28">5.1.2.28</a> is a first taste. Because functors preserve isomorphisms, we can tell graphs apart by looking at them in a simpler category, <strong>Set</strong>, using various lenses (in that case, four). There is relatively simple theorem in <strong>Set</strong> that says that for different natural numbers <em>m</em>, <em>n</em> the sets <em><span class="underline">m</span></em> and <em><span class="underline">n</span></em> are never isomorphic. This theorem is transported via the four functors to four different theorems about telling graphs apart.</p>


<section title="The category of categories">
<h3 class="level3" id="lev_5-1-2-30"><strong>5.1.2.30&#160;&#160;&#160;The category of categories</strong></h3>
<p class="noindent">Recall from Remark <a href="chapter005.html#Rem_5-1-1-2">5.1.1.2</a> that a small category <epub:switch id="mathmlSwitch512"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is one in which Ob(<epub:switch id="mathmlSwitch513"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>) is a set. But everything said so far works whether or not <epub:switch id="mathmlSwitch514"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is small. The following definition gives more precision.</p>
<p class="noindent1-top-pro" id="Pro_5-1-2-31"><strong>Proposition 5.1.2.31</strong>. <em>There exists a category, called</em> the category of small categories <em>and denoted</em> <strong>Cat</strong>, <em>in which the objects are the small categories and the morphisms are the functors</em>,</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch515"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant="bold">Cat</mi></mrow></msub><mrow><mo>(</mo><mrow><mi mathvariant="script">C</mi><mo>,</mo><mi mathvariant="script">D</mi></mrow><mo>)</mo></mrow><mo>=</mo><mrow><mo>{</mo> <mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>&#x2192;</mo><mi mathvariant="script">D</mi><mo>&#x007C;</mo><mi>F</mi><mtext>&#x2009;is&#x2009;a&#x2009;functor</mtext></mrow> <mo>}</mo></mrow><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top"><em>That is, there are identity functors, functors can be composed, and the identity and associativity laws hold.</em></p>
<p class="noindent1-top"><em>Proof.</em> We follow Definition <a href="chapter005.html#Def_5-1-1-1">5.1.1.1</a>. We have already specified Ob(<strong>Cat</strong>) and Hom<strong><sub>Cat</sub></strong> in the statement of the proposition. Given a small category <epub:switch id="mathmlSwitch516"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, there is an identity functor <epub:switch id="mathmlSwitch517"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>id</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>:</mo><mi mathvariant="script">C</mi><mo>&#x2192;</mo><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> that is identity on the set of objects and the set of morphisms. <a id="p187"></a>And given a functor <epub:switch id="mathmlSwitch518"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>&#x2192;</mo><mi mathvariant="script">D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and a functor <epub:switch id="mathmlSwitch519"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>G</mi><mo>:</mo><mi mathvariant="script">D</mi><mo>&#x2192;</mo><mi mathvariant="script">E</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, it is easy to check that <epub:switch id="mathmlSwitch520"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>G</mi><mo>&#x25CB;</mo><mi>F</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>&#x2192;</mo><mi mathvariant="script">E</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, defined by composition of functions <epub:switch id="mathmlSwitch521"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo>(</mo><mi>G</mi><mi>)</mi><mo>&#x25CB;</mo><mtext>Ob</mtext><mo>(</mo><mi>F</mi><mo>)</mo><mo>:</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo><mo>&#x2192;</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">E</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch522"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi>G</mi></msub><mo>&#x25CB;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi>F</mi></msub><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">E</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> (see Exercise <a href="chapter005.html#Exe_5-1-2-24">5.1.2.24</a>), is a functor; thus we have a composition formula. For the same reasons, one can show that functors, as morphisms, obey the identity law and the composition law. Therefore, this specification of <strong>Cat</strong> satisfies the definition of being a category.</p>
<p class="noindent-top" id="Exa_5-1-2-32"><em>Example</em> 5.1.2.32 (Categories have underlying graphs). Suppose given a category in the notation is as in Exercise <a href="chapter005.html#Exe_5-1-1-27">5.1.1.27</a>, <epub:switch id="mathmlSwitch523"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi><mo>&#x003D;</mo><mo>(</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo><mo>,</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>,</mo><mtext mathvariant="italic">dom</mtext><mo>,</mo><mtext mathvariant="italic">cod</mtext><mo>,</mo><mtext mathvariant="italic">ids</mtext><mo>,</mo><mtext mathvariant="italic">comp</mtext><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Then <epub:switch id="mathmlSwitch524"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>(</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo><mo>,</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo>,</mo><mtext mathvariant="italic">dom</mtext><mo>,</mo><mtext mathvariant="italic">cod</mtext><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a graph, called the <em>graph underlying</em> <epub:switch id="mathmlSwitch525"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and denoted <epub:switch id="mathmlSwitch526"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>U</mi><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo><mo>&#x2208;</mo><mtext>Ob</mtext><mo>(</mo><mtext mathvariant="bold">Grph</mtext><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. A functor <epub:switch id="mathmlSwitch527"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>&#x2192;</mo><mi mathvariant="script">D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> induces a graph morphism <epub:switch id="mathmlSwitch528"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>U</mi><mo>(</mo><mi>F</mi><mo>)</mo><mo>:</mo><mi>U</mi><mo>(</mo><mi mathvariant="script">C</mi><mo>)</mo><mo>&#x2192;</mo><mi>U</mi><mo>(</mo><mi mathvariant="script">D</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, as seen in (<a href="chapter005.html#eq_5-5">5.5</a>). So we have a functor,</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch529"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>U</mi><mo>:</mo><mtext>&#x2009;</mtext><mtext mathvariant="bold">Cat</mtext><mo>&#x2192;</mo><mtext mathvariant="bold">Grph</mtext><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top" id="Exa_5-1-2-33"><em>Example</em> 5.1.2.33 (Free category on a graph). Example <a href="chapter005.html#Exa_5-1-2-25">5.1.2.25</a> discussed a functor Paths: <strong>Grph</strong> &#x2192; <strong>Grph</strong> that considered all the paths in a graph <em>G</em> as the arrows of a new graph Paths(<em>G</em>). In fact, Paths(<em>G</em>) could be construed as a category, denoted <em>F</em>(<em>G</em>) &#x2208; Ob(<strong>Cat</strong>) and called <em>the free category generated by G</em>.</p>
<p>The objects of the category <em>F</em>(<em>G</em>) are the vertices of <em>G</em>. For any two vertices <em>v</em>, <em>v</em>&#x2032;, the hom-set Hom<em><sub>F</sub></em><sub>(<em>G</em>)</sub>(<em>v</em>, <em>v</em>&#x2032;) is the set of paths in <em>G</em> from <em>v</em> to <em>v</em>&#x2032;. The identity elements are given by the trivial paths, and the composition formula is given by concatenation of paths.</p>
<p>For the on-morphisms part of <em>F</em>, we need to see that a graph homomorphism <em>f</em>: <em>G</em> &#x2192; <em>G</em>&#x2032; induces a functor <em>F</em>(<em>f</em>): <em>F</em>(<em>G</em>) &#x2192; <em>F</em>(<em>G</em>&#x2032;). But this was shown in Exercise <a href="chapter005.html#Exe_5-1-2-26">5.1.2.26</a>. Thus we have a functor</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch530"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mtext>&#x2009;</mtext><mtext mathvariant="bold">Grph</mtext><mo>&#x2192;</mo><mtext mathvariant="bold">Cat</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top">called <em>the free category</em> functor.</p>

<p class="noindent1-top-exe" id="Exe_5-1-2-34"><em>Exercise</em> 5.1.2.34.</p>
<p>Let <em>G</em> be the graph depicted</p>
<p class="fig-img"><img src="images/Art_P159.jpg" alt="art"/></p>
<p class="noindent1-top">and let [1] &#x2208; Ob(<strong>Cat</strong>) denote the free category on <em>G</em>, i.e., [1] &#x2254; <em>F</em>(<em>G</em>), as in Example <a href="chapter005.html#Exa_5-1-2-33">5.1.2.33</a>. We call [1] the <em>free arrow category</em>.</p>
<p class="nl1-list">a. What are the objects of [1]?</p>
<p class="nl1-list">b. For every pair of objects in [1], write the hom-set.</p>
<a id="p188"></a>
<p class="noindent1-top-sol"><em>Solution</em> 5.1.2.34.</p>
<p class="nl1-list">a. Ob([1]) &#x003D; {<em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>}.</p>
<p class="nl1-list">b. There are four pairs of objects, so the four hom-sets are:</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch531"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable columnalign='left'><mtr columnalign='left'><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mrow><mo>[</mo> <mtext>1</mtext> <mo>]</mo></mrow></mrow></msub><mrow><mo>(</mo><mrow><msub><mi>&#x03C5;</mi><mn>0</mn></msub><mo>,</mo><msub><mi>&#x03C5;</mi><mn>0</mn></msub></mrow><mo>)</mo></mrow><mo>=</mo><mrow><mo>{</mo> <mrow><msub><mrow><mtext>id</mtext></mrow><mrow><msub><mi>&#x03C5;</mi><mn>0</mn></msub></mrow></msub></mrow> <mo>}</mo></mrow><mo>;</mo></mrow></mtd><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mrow><mo>[</mo> <mtext>1</mtext> <mo>]</mo></mrow></mrow></msub><mrow><mo>(</mo><mrow><msub><mi>&#x03C5;</mi><mn>0</mn></msub><mo>,</mo><msub><mi>&#x03C5;</mi><mn>1</mn></msub></mrow><mo>)</mo></mrow><mo>=</mo><mrow><mo>{</mo> <mi>e</mi> <mo>}</mo></mrow><mo>;</mo></mrow></mtd></mtr><mtr columnalign='left'><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mrow><mo>[</mo> <mtext>1</mtext> <mo>]</mo></mrow></mrow></msub><mrow><mo>(</mo><mrow><msub><mi>&#x03C5;</mi><mn>1</mn></msub><mo>,</mo><msub><mi>&#x03C5;</mi><mn>0</mn></msub></mrow><mo>)</mo></mrow><mo>=</mo><mo>&#x2205;</mo><mo>;</mo></mrow></mtd><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mrow><mo>[</mo> <mtext>1</mtext> <mo>]</mo></mrow></mrow></msub><mrow><mo>(</mo><mrow><msub><mi>&#x03C5;</mi><mn>1</mn></msub><mo>,</mo><msub><mi>&#x03C5;</mi><mn>1</mn></msub></mrow><mo>)</mo></mrow><mo>=</mo><mrow><mo>{</mo> <mrow><msub><mrow><mtext>id</mtext></mrow><mrow><msub><mi>&#x03C5;</mi><mtext>1</mtext></msub></mrow></msub></mrow> <mo>}</mo></mrow><mo>.</mo></mrow></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top-exe" id="Exe_5-1-2-35"><em>Exercise</em> 5.1.2.35.</p>
<p>Let <em>G</em> be the graph whose vertices are all U.S. cities and whose arrows are airplane flights connecting the cities. What idea is captured by the free category on <em>G</em>?</p>
<p class="noindent1-top-exe" id="Exe_5-1-2-36"><em>Exercise</em> 5.1.2.36.</p>
<p>Let <em>F</em>: <strong>Grph</strong> &#x2192; <strong>Cat</strong> denote the free category functor from Example <a href="chapter005.html#Exa_5-1-2-33">5.1.2.33</a>, and let <em>U</em>: <strong>Cat</strong> &#x2192; <strong>Grph</strong> denote the underlying graph functor from Example <a href="chapter005.html#Exa_5-1-2-32">5.1.2.32</a>. What is the composition <em>U</em> &#x25CB; <em>F</em>: <strong>Grph</strong> &#x2192; <strong>Grph</strong> called?</p>

<p class="noindent1-top-sol"><em>Solution</em> 5.1.2.36.</p>
<p>Since <em>F</em>: <strong>Grph</strong> &#x2192; <strong>Cat</strong> freely adds all paths, one can check that <em>U</em>&#x25CB;<em>F</em>: <strong>Grph</strong> &#x2192; <strong>Grph</strong> is the construction that takes a graph and adds all paths; i.e., <em>U</em> &#x25CB; <em>F</em> &#x003D; Paths (see Example <a href="chapter005.html#Exa_5-1-2-25">5.1.2.25</a>).</p>
<p class="noindent1-top-exe" id="Exe_5-1-2-37"><em>Exercise</em> 5.1.2.37.</p>
<p>Recall the graph <em>G</em> from Example <a href="chapter004.html#Exa_4-3-1-2">4.3.1.2</a>. Let <epub:switch id="mathmlSwitch532"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> &#x003D; <em>F</em>(<em>G</em>) be the free category on <em>G</em>.</p>
<p class="nl1-list">a. What is <epub:switch id="mathmlSwitch533"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo stretchy='false'>(</mo><mi>v</mi><mo>,</mo><mi>x</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>?</p>
<p class="nl1-list">b. What is <epub:switch id="mathmlSwitch534"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">C</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>,</mo><mi>v</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>?</p>
<p class="noindent1-top" id="Exa_5-1-2-38"><em>Example</em> 5.1.2.38 (Discrete graphs, discrete categories). There is a functor <em>Disc</em>: <strong>Set</strong> &#x2192; <strong>Grph</strong> that sends a set <em>S</em> to the graph</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch535"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>D</mi><mi>i</mi><mi>s</mi><mi>c</mi><mrow><mo>(</mo><mi>S</mi><mo>)</mo></mrow><mo>&#x2254;</mo><mrow><mo>(</mo><mrow><mi>S</mi><mo>,</mo><mo>&#x2205;</mo><mo>,</mo><mo>!</mo><mo>,</mo><mo>!</mo></mrow><mo>)</mo></mrow><mo>,</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<a id="p189"></a>
<p class="noindent1-top">where &#x0021;: &#x2205; &#x2192; <em>S</em> is the unique function. We call <em>Disc</em>(<em>S</em>) the <em>discrete graph on the set S</em>. It is clear that a function <em>S</em> &#x2192; <em>S</em>&#x2032; induces a morphism of discrete graphs. Now applying the free category functor <em>F</em>: <strong>Grph</strong> &#x2192; <strong>Cat</strong>, we get the <em>discrete category on the set S</em>. This composition is also denoted <em>Disc</em>: <strong>Set</strong> &#x2192; <strong>Cat</strong>.</p>
<p class="noindent1-top-exe" id="Exe_5-1-2-39"><em>Exercise</em> 5.1.2.39.</p>
<p>Recall from (<a href="chapter002.html#lev_2-4">2.4</a>) the definition of the set <em><span class="underline">n</span></em> for any natural number <em>n</em> &#x2208; &#x2115;, and let <em>D<sub>n</sub></em> &#x2254; <em>Disc</em>(<em><span class="underline">n</span></em>) &#x2208; Ob(<strong>Cat</strong>) be the discrete category on the set <em><span class="underline">n</span></em>, as in Example <a href="chapter005.html#Exa_5-1-2-38">5.1.2.38</a>.</p>
<p class="nl1-list">a. List all the morphisms in <em>D</em><sub>4</sub>.</p>
<p class="nl1-list">b. List all the functors <em>D</em><sub>3</sub> &#x2192; <em>D</em><sub>2</sub>.</p>

<p class="noindent1-top-exe" id="Exe_5-1-2-40"><em>Exercise</em> 5.1.2.40.</p>
<p>Let <epub:switch id="mathmlSwitch536"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> be a category. How many functors are there <epub:switch id="mathmlSwitch537"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> &#x2192; <em>D</em><sub>1</sub>, where <em>D</em><sub>1</sub> &#x2254; <em>Disc</em>(<span class="underline">1</span>) is the discrete category on one element?</p>
<p class="noindent1-top-sol"><em>Solution</em> 5.1.2.40.</p>
<p>There is always one functor <epub:switch id="mathmlSwitch538"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> &#x2192; <em>D</em><sub>1</sub>. There is no choice about where to send objects (all go to the object 1), and there is no choice about where to send morphisms (all go to the morphism id<sub>1</sub>).</p>
<p>We sometimes refer to <em>Disc</em>(<span class="underline">1</span>) as the <em>terminal category</em> (see Section <a href="chapter006.html#lev_6-1-3">6.1.3</a>) and for simplicity denote it <span class="underline">1</span>. Its unique object is denoted 1.</p>
<p class="noindent1-top-exe" id="Exe_5-1-2-41"><em>Exercise</em> 5.1.2.41.</p>
<p>If someone said, &#x201C;Ob is a functor from <strong>Cat</strong> to <strong>Set</strong>,&#x201D; what might they mean?</p>
<p class="noindent1-top-sol"><em>Solution</em> 5.1.2.41.</p>
<p>They probably mean that there is a functor <strong>Cat</strong> &#x2192; <strong>Set</strong> that sends a category <epub:switch id="mathmlSwitch539"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> to its set of objects Ob(<epub:switch id="mathmlSwitch540"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>). Since the speaker does not say what this functor, Ob, does on morphisms, he is suggesting it is obvious. A morphism in <strong>Cat</strong> is a functor <i>F</i>: <epub:switch id="mathmlSwitch541"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> &#x2192; <epub:switch id="mathmlSwitch542"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, which includes an on-objects part by definition. In other words, it is indeed obvious what Ob(<i>F</i>): Ob(<epub:switch id="mathmlSwitch543"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>) &#x2192; Ob(<epub:switch id="mathmlSwitch544"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>) should mean because this is given in the specification of <i>F</i> (see Definition <a href="chapter005.html#Def_5-1-2-1">5.1.2.1</a>). It is not hard to check that Ob preserves identities and compositions, so it is indeed a functor.</p>
<p class="noindent1-top-exe" id="Exe_5-1-2-42"><em>Exercise</em> 5.1.2.42.</p>
<a id="p190"></a>
<p>If someone said, &#x201C;Hom is a functor from <strong>Cat</strong> to <strong>Set</strong>, where by Hom I mean the mapping that takes <epub:switch id="mathmlSwitch545"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> to the set <epub:switch id="mathmlSwitch546"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>, as in Exercise <a href="chapter005.html#Exe_5-1-1-27">5.1.1.27</a>,&#x201D; what might they mean?</p>
<p class="noindent1-top-sol"><em>Solution</em> 5.1.2.42.</p>
<p>They probably mean that there is a functor <strong>Cat</strong> &#x2192; <strong>Set</strong> that sends a category <epub:switch id="mathmlSwitch547"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> to its set of morphisms <epub:switch id="mathmlSwitch548"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Since the speaker does not indicate what this functor, Hom, does on morphisms, she is suggesting it is obvious. A morphism in <strong>Cat</strong> is a functor <epub:switch id="mathmlSwitch549"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, which includes an on-morphisms part by definition. In other words, it is indeed obvious what <epub:switch id="mathmlSwitch550"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Hom</mtext><mo stretchy='false'>(</mo><mi>F</mi><mo stretchy='false'>)</mo><mo>:</mo><mtext>Hom(</mtext><mi mathvariant='script'>C</mi><mtext>)</mtext><mo>&#x2192;</mo><mtext>Hom(</mtext><mi mathvariant='script'>D</mi><mtext>)</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> should mean because this is given in the specification of <em>F</em> (see Definition <a href="chapter005.html#Def_5-1-2-1">5.1.2.1</a>). It is easy to check that Hom preserves identities and compositions, so it is indeed a functor.</p>
</section>
</section>
</section>

<section title="Common categories and functors from pure math">
<h1 class="level1" id="lev_5-2"><a href="toc.html#Rlev_5-2"><strong>5.2&#160;&#160;&#160;Common categories and functors from pure math</strong></a></h1>


<section title="Monoids, groups, preorders, and graphs">
<h2 class="level2" id="lev_5-2-1"><strong>5.2.1&#160;&#160;&#160;Monoids, groups, preorders, and graphs</strong></h2>
<p class="noindent">We saw in Section <a href="chapter005.html#lev_5-1-1">5.1.1</a> that there is a category <strong>Mon</strong> of monoids, a category <strong>Grp</strong> of groups, a category <strong>PrO</strong> of preorders, and a category <strong>Grph</strong> of graphs. This section shows that each monoid <epub:switch id="mathmlSwitch551"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, each group <epub:switch id="mathmlSwitch552"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>G</mi></math></epub:case><epub:default></epub:default></epub:switch>, and each preorder <epub:switch id="mathmlSwitch553"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>P</mi></math></epub:case><epub:default></epub:default></epub:switch> can be considered as its own category. If each object in <strong>Mon</strong> is a category, we might hope that each morphism in <strong>Mon</strong> is just a functor, and this is true. The same holds for <strong>Grp</strong> and <strong>PrO</strong>. We saw in Example <a href="chapter005.html#Exa_5-1-2-33">5.1.2.33</a> how each graph can be regarded as giving a free category. Another perspective on graphs (i.e., graphs as functors) is discussed in Section <a href="chapter005.html#lev_5-2-1-21">5.2.1.21</a>.</p>


<section title="Monoids as categories">
<h3 class="level3" id="lev_5-2-1-1"><strong>5.2.1.1&#160;&#160;&#160;Monoids as categories</strong></h3>
<p class="noindent">Example <a href="chapter004.html#Exa_4-1-2-9">4.1.2.9</a> said that to olog a monoid, one should use only one box. And again Example <a href="chapter004.html#Exa_4-5-3-3">4.5.3.3</a> said that a monoid action could be captured by only one table. These ideas are encapsulated by the understanding that a monoid is perfectly modeled as a category with one object.</p>
<p class="noindent1-top"><strong>Each monoid as a category with one object</strong> Let (<em>M</em>, <em>e</em>, &#x22C6;) be a monoid. We consider it as a category <epub:switch id="mathmlSwitch554"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> with one object, Ob(<epub:switch id="mathmlSwitch555"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>) &#x003D; {&#x25B2;}, and</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch556"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">M</mi></msub><mo stretchy='false'>(</mo><mo>&#x25B2;</mo><mo>,</mo><mo>&#x25B2;</mo><mo stretchy='false'>)</mo><mo>&#x2254;</mo><mi>M</mi><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>

<p class="noindent">The identity morphism id<sub>&#x25B2;</sub> serves as the monoid identity <em>e</em>, and the composition formula</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch557"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo>&#x25CB;</mo><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">M</mi></msub><mo stretchy='false'>(</mo><mo>&#x25B2;</mo><mo>,</mo><mo>&#x25B2;</mo><mo stretchy='false'>)</mo><mo>&#x00D7;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">M</mi></msub><mo stretchy='false'>(</mo><mo>&#x25B2;</mo><mo>,</mo><mo>&#x25B2;</mo><mo stretchy='false'>)</mo><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">M</mi></msub><mo stretchy='false'>(</mo><mo>&#x25B2;</mo><mo>,</mo><mo>&#x25B2;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<a id="p191"></a>
<p class="noindent">is given by &#x22C6;: <em>M</em> &#x00D7; <em>M</em> &#x2192; <em>M</em>. The associativity and identity laws for the monoid match precisely with the associativity and identity laws for categories.</p>
<p>If a monoid is a category with one object, is there any categorical way of phrasing the notion of monoid homomorphism? Suppose that <epub:switch id="mathmlSwitch558"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> &#x003D; (<em>M</em>, <em>e</em>, &#x22C6;) and <epub:switch id="mathmlSwitch559"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>&#x2032; &#x003D; (<em>M</em>&#x2032;, <em>e</em>&#x2032;, &#x22C6;&#x2032;). We know that a monoid homomorphism is a function <em>f</em> : <em>M</em> &#x2192; <em>M</em>&#x2032; such that <em>f</em>(<em>e</em>) &#x003D; <em>e</em>&#x2032; and such that for every pair <em>m</em><sub>0</sub>, <em>m</em><sub>1</sub> &#x2208; <em>M</em>, we have <em>f</em>(<em>m</em><sub>0</sub> &#x22C6; <em>m</em><sub>1</sub>) &#x003D; <em>f</em>(<em>m</em><sub>0</sub>) &#x22C6;&#x2032; <em>f</em>(<em>m</em><sub>1</sub>). What is a functor <epub:switch id="mathmlSwitch560"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> &#x2192; <epub:switch id="mathmlSwitch561"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>&#x2032;?</p>
<p class="noindent1-top"><strong>Each monoid homomorphism as a functor between one-object categories</strong> Say that Ob(<epub:switch id="mathmlSwitch562"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>) &#x003D; {&#x25B2;} and Ob(<epub:switch id="mathmlSwitch563"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>&#x2032;) &#x003D; {&#x25B2;&#x2032;}, and we know that <epub:switch id="mathmlSwitch564"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">M</mi></msub><mrow><mo>(</mo><mrow><mi mathvariant="normal">&#x25B2;</mi><mo>,</mo><mi mathvariant="normal">&#x25B2;</mi></mrow><mo>)</mo></mrow><mo>=</mo><mi>M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch565"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><msup><mi mathvariant="script">M</mi><mo>&#x2032;</mo></msup></msub><mrow><mo>(</mo><mrow><msup><mi mathvariant="normal">&#x25B2;</mi><mo>&#x2032;</mo></msup><mo>,</mo><msup><mi mathvariant="normal">&#x25B2;</mi><mo>&#x2032;</mo></msup></mrow><mo>)</mo></mrow><mo>=</mo><msup><mi>M</mi><mo>&#x2032;</mo></msup></mrow></math></epub:case><epub:default></epub:default></epub:switch>. A functor <epub:switch id="mathmlSwitch566"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">M</mi><mo>&#x2192;</mo><msup><mi mathvariant="script">M</mi><mo>&#x2032;</mo></msup></mrow></math></epub:case><epub:default></epub:default></epub:switch> consists first of a function Ob(<epub:switch id="mathmlSwitch567"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>) &#x2192; Ob(<epub:switch id="mathmlSwitch568"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>&#x2032;), but these sets have only one element each, so there is nothing to say on that front: we must have <em>F</em>(&#x25B2;) &#x003D; &#x25B2;&#x2032;. It also consists of a function <epub:switch id="mathmlSwitch569"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">M</mi></msub><mo>&#x2192;</mo><msub><mrow><mi>hom</mi><mo>&#x2061;</mo></mrow><msup><mi mathvariant="script">M</mi><mo>&#x2032;</mo></msup></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>, but that is just a function <em>M</em> &#x2192; <em>M</em>&#x2032;. The identity and composition formulas for functors match precisely with the identity and composition formula for monoid homomorphisms. Thus a monoid homomorphism is nothing more than a functor between one-object categories.</p>
<p class="noindent1-top-slo"><em>Slogan</em> 5.2.1.2.</p>
<div class="pull-quote">
<p class="pq-noindent"><em>A monoid is a category with one object. A monoid homomorphism is just a functor between one-object categories.</em></p>
</div>
<p>This is formalized in the following theorem.</p>
<p class="noindent1-top-the" id="The_5-2-1-3"><strong>Theorem 5.2.1.3</strong>. <em>There is a functor i</em> : <strong>Mon</strong> &#x2192; <strong>Cat</strong> <em>with the following properties:</em></p>
<ul class="ulindent">
<li><em>For every monoid</em> <epub:switch id="mathmlSwitch570"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant="script">M</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mrow><mo>(</mo><mrow><mtext mathvariant="bold">Mon</mtext></mrow><mo>)</mo></mrow></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <em>the category</em> <epub:switch id="mathmlSwitch571"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>i</mi><mrow><mo>(</mo><mi mathvariant="script">M</mi><mo>)</mo></mrow><mo>&#x2208;</mo><mtext>Ob</mtext><mrow><mo>(</mo><mrow><mtext mathvariant="bold">Cat</mtext></mrow><mo>)</mo></mrow></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>itself has exactly one object,</em>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch572"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mrow><mo>|</mo><mrow><mtext>Ob</mtext><mrow><mo>(</mo><mrow><mi>i</mi><mrow><mo>(</mo><mi mathvariant="script">M</mi><mo>)</mo></mrow></mrow><mo>)</mo></mrow></mrow> <mo>|</mo></mrow><mo>=</mo><mn>1</mn><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p></li>
<li class="litop"><em>For every pair of monoids</em> <epub:switch id="mathmlSwitch573"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant="script">M</mi><mo>,</mo><msup><mi mathvariant="script">M</mi><mo>&#x2032;</mo></msup><mo>&#x2208;</mo><mtext>Ob</mtext><mrow><mo>(</mo><mrow><mtext mathvariant="bold">Mon</mtext></mrow><mo>)</mo></mrow></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <em>the function</em>
<p class="disp-eq-no"><epub:switch id="mathmlSwitch574"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Mon</mtext></mrow></msub><mo stretchy='false'>(</mo><mi mathvariant="script">M</mi><mo>,</mo><mi mathvariant="script">M</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo><mover><mo>&#x2192;</mo><mrow><mo>&#x2245;</mo></mrow></mover><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Cat</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>i</mi><mo stretchy='false'>(</mo><mi mathvariant="script">M</mi><mo stretchy='false'>)</mo><mo>,</mo><mi>i</mi><mo stretchy='false'>(</mo><mi mathvariant="script">M</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>,</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent"><em>induced by the functor i, is a bijection.</em></p></li>
</ul>

<p class="noindent"><em>Proof.</em> This is basically the content of the preceding paragraphs. The functor <em>i</em> sends a monoid to the corresponding category with one object and <em>i</em> sends a monoid homomorphism to the corresponding functor. One can check that <em>i</em> preserves identities and compositions.</p>
<a id="p192"></a>
<p>Theorem <a href="chapter005.html#The_5-2-1-3">5.2.1.3</a> situates the theory of monoids very nicely within the world of categories. But we have other ways of thinking about monoids, namely, their actions on sets. It would greatly strengthen the story if we could subsume monoid actions within category theory also, and we can.</p>
<p class="noindent1-top"><strong>Each monoid action as a set-valued functor</strong> Recall from Definition <a href="chapter004.html#Def_4-1-2-1">4.1.2.1</a> that if (<em>M</em>, <em>e</em>, &#x22C6;) is a monoid, an action consists of a set <em>S</em> and a function <img src="images/Art_P160.jpg" alt="art"/> such that <img src="images/Art_P161.jpg" alt="art"/> and <img src="images/Art_P162.jpg" alt="art"/> for all <em>s</em> &#x2208; <em>S</em>. How might we relate the notion of monoid actions to the notion of functors? Since monoids act on sets, one idea is to try asking what a functor <epub:switch id="mathmlSwitch575"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">M</mi></mrow><mo>&#x2192;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch> is; this idea will work.</p>
<p>The monoid-as-category <epub:switch id="mathmlSwitch576"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> has only one object, &#x25B2;, so <em>F</em> provides one set, <em>S</em> &#x2254; <em>F</em>(&#x25B2;) &#x2208; Ob(<strong>Set</strong>). It also provides a function <epub:switch id="mathmlSwitch577"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi>F</mi></msub><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">M</mi></msub><mrow><mo>(</mo><mrow><mi><mi mathvariant="normal">&#x25B2;</mi></mi><mo>,</mo><mi><mi mathvariant="normal">&#x25B2;</mi></mi></mrow><mo>)</mo></mrow><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant='bold'>Set</mtext></mrow></msub><mrow><mo>(</mo><mrow><mi>F</mi><mrow><mo>(</mo><mi><mi mathvariant="normal">&#x25B2;</mi></mi><mo>)</mo></mrow><mo>,</mo><mi>F</mi><mrow><mo>(</mo><mi><mi mathvariant="normal">&#x25B2;</mi></mi><mo>)</mo></mrow></mrow><mo>)</mo></mrow></mrow></math></epub:case><epub:default></epub:default></epub:switch>, or more concisely, a function</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch578"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mi>H</mi><mi>F</mi></msub><mo>:</mo><mi>M</mi><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Set</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>S</mi><mo>,</mo><mi>S</mi><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">By currying (see Proposition <a href="chapter003.html#Pro_3-4-2-3">3.4.2.3</a>), this is the same as a function <img src="images/Art_P163.jpg" alt="art"/>. The first monoid action law, that <img src="images/Art_P164.jpg" alt="art"/>, becomes the law that functors preserve identities, Hom<em><sub>F</sub></em> (id<sub>&#x25B2;</sub>) &#x003D; id<em><sub>S</sub></em>. The other monoid action law is equivalent to the composition law for functors.</p>
</section>


<section title="Groups as categories">
<h3 class="level3" id="lev_5-2-1-4"><strong>5.2.1.4&#160;&#160;&#160;Groups as categories</strong></h3>
<p class="noindent">A group is just a monoid (<em>M</em>, <em>e</em>, &#x22C6;) in which every element <em>m</em> &#x2208; <em>M</em> is invertible, meaning there exists some <em>m</em>&#x2032; &#x2208; <em>M</em> with <em>m</em> &#x22C6; <em>m</em>&#x2032; &#x003D; <em>e</em> &#x003D; <em>m</em>&#x2032; &#x22C6; <em>m</em>. If a monoid is the same thing as a category <epub:switch id="mathmlSwitch579"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> with one object, then a group must be a category with one object and with an additional property having to do with invertibility. The elements of <em>M</em> are the morphisms of the category <epub:switch id="mathmlSwitch580"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, so we need a notion of invertibility for morphisms. Luckily we have such a notion already, namely, isomorphism.</p>
<p class="noindent1-top-slo"><em>Slogan</em> 5.2.1.5.</p>
<div class="pull-quote">
<p class="pq-noindent"><em>A group is a category <epub:switch id="mathmlSwitch581"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>G</mi></math></epub:case><epub:default></epub:default></epub:switch> with one object, such that every morphism in <epub:switch id="mathmlSwitch582"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>G</mi></math></epub:case><epub:default></epub:default></epub:switch> is an isomorphism. A group homomorphism is just a functor between such categories.</em></p>
</div>

<p class="noindent1-top-the" id="The_5-2-1-6"><strong>Theorem 5.2.1.6</strong>. <em>There is a functor i</em> : <strong>Grp</strong> &#x2192; <strong>Cat</strong> <em>with the following properties:</em></p>
<ul class="ulindent">
<li><em>For every group</em> <epub:switch id="mathmlSwitch583"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>G</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mtext mathvariant='bold'>Grp</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <em>the category</em> <epub:switch id="mathmlSwitch584"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>i</mi><mo>(</mo><mi mathvariant='script'>G</mi><mo>)</mo><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mtext mathvariant='bold'>Cat</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>itself has exactly one object, and every morphism m in</em> <epub:switch id="mathmlSwitch585"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>i</mi><mo>(</mo><mi mathvariant='script'>G</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>is an isomorphism.</em></li>
<li class="litop"><a id="p193"></a><em>For every pair of groups</em> <epub:switch id="mathmlSwitch586"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>G</mi><mo>,</mo><mi mathvariant='script'>G</mi><mo>&#x2032;</mo><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mtext mathvariant='bold'>Grp</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <em>the function</em>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch587"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant='bold'>Grp</mtext></mrow></msub><mo stretchy='false'>(</mo><mi mathvariant='script'>G</mi><mo>,</mo><mi mathvariant='script'>G</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo><mover><mo>&#x2192;</mo><mrow><mo>&#x2245;</mo></mrow></mover><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant='bold'>Cat</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>i</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>G</mi><mo stretchy='false'>)</mo><mo>,</mo><mi>i</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>G</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>,</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent"><em>induced by the functor i, is a bijection.</em></p></li>
</ul>
<p>Just as with monoids, an action of some group (<em>G</em>, <em>e</em>, &#x22C6;) on a set <em>S</em> &#x2208; Ob(<strong>Set</strong>) is the same thing as a functor <epub:switch id="mathmlSwitch588"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>G</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> sending the unique object of <epub:switch id="mathmlSwitch589"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>G</mi></math></epub:case><epub:default></epub:default></epub:switch> to the set <em>S</em>.</p>
</section>


<section title="A monoid and a group stationed at each object in any category">
<h3 class="level3" id="lev_5-2-1-7"><strong>5.2.1.7&#160;&#160;&#160;A monoid and a group stationed at each object in any category</strong></h3>
<p class="noindent">If a monoid is just a category with one object, we can locate monoids in any category <epub:switch id="mathmlSwitch590"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> by focusing on one object in <epub:switch id="mathmlSwitch591"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>. Similarly for groups.</p>
<p class="noindent1-top-exe" id="Exa_5-2-1-8"><em>Example</em> 5.2.1.8 (Endomorphism monoid). Let <epub:switch id="mathmlSwitch592"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> be a category and <epub:switch id="mathmlSwitch593"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> an object. Let <epub:switch id="mathmlSwitch594"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>M</mi><mo>=</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>,</mo><mi>x</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Note that for any two elements <em>f</em>, <em>g</em> &#x2208; <em>M</em>, we have <em>f</em> &#x25CB; <em>g</em> : <em>x</em> &#x2192; <em>x</em> in <em>M</em>. Let <epub:switch id="mathmlSwitch595"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> &#x003D; (<em>M</em>, id<em><sub>x</sub></em>, &#x25CB;). It is easy to check that <epub:switch id="mathmlSwitch596"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a monoid; it is called the <em>endomorphism monoid of x in</em> <epub:switch id="mathmlSwitch597"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, denoted End(<em>x</em>).</p>
<p class="noindent1-top-exe" id="Exa_5-2-1-9"><em>Example</em> 5.2.1.9 (Automorphism group). Let <epub:switch id="mathmlSwitch598"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> be a category and <epub:switch id="mathmlSwitch599"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> an object. Let <epub:switch id="mathmlSwitch600"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>G</mi><mo>=</mo><mo>&#x007B;</mo><mi>f</mi><mo>&#x2208;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>,</mo><mi>x</mi><mo stretchy='false'>)</mo><mo>&#x007C;</mo><mi>f</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is an isomorphism}. Let <epub:switch id="mathmlSwitch601"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>G</mi><mo>=</mo><mo stretchy='false'>(</mo><mi>G</mi><mo>,</mo><msub><mrow><mtext>id</mtext></mrow><mi>x</mi></msub><mo>,</mo><mo>&#x25CB;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. One can check that <epub:switch id="mathmlSwitch602"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>G</mi></math></epub:case><epub:default></epub:default></epub:switch> is a group; it is called the <em>automorphism group of x in</em> <epub:switch id="mathmlSwitch603"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> denoted Aut(<em>x</em>).</p>
<p class="noindent1-top-exe" id="Exe_5-2-1-10"><em>Exercise</em> 5.2.1.10.</p>
<p>Let <em>S</em> &#x003D; {1, 2, 3, 4} &#x2208; Ob(<strong>Set</strong>).</p>
<p class="nl1-list">a. What is the automorphism group Aut(<em>S</em>) of <em>S</em> in <strong>Set</strong>, and how many elements does this group have?</p>
<p class="nl1-list">b. What is the endomorphism monoid End(<em>S</em>) of <em>S</em> in <strong>Set</strong>, and how many elements does this monoid have?</p>
<p class="nl1-list">c. Recall from Example <a href="chapter005.html#Exa_5-1-2-3">5.1.2.3</a> that every group has an underlying monoid <em>U</em>(<em>G</em>). Is the endomorphism monoid of <em>S</em> the underlying monoid of the automorphism group of <em>S</em>? That is, is it the case that End(<em>S</em>) &#x003D; <em>U</em>(Aut(<em>S</em>))?</p>

<p class="noindent1-top-exe" id="Exe_5-2-1-11"><em>Exercise</em> 5.2.1.11.</p>
<a id="p194"></a>
<p>Consider the following graph <em>G</em>, which has four vertices and eight arrows:</p>
<p class="fig-img"><img src="images/Art_P165.jpg" alt="art"/></p>
<p class="noindent">What is the automorphism group Aut(<em>G</em>) of <em>G</em> &#x2208; Ob(<strong>Grph</strong>) Hint: Every automorphism of <em>G</em> will induce an automorphism of the set {1, 2, 3, 4}; which ones will preserve the endpoints of arrows?</p>
<p class="noindent1-top-sol"><em>Solution</em> 5.2.1.11.</p>
<p>We use visual perception to guide us. The graph <em>G</em> has the shape of a square. Of the 4! different possible automorphisms of {1, 2, 3, 4}, only those preserving the square shape will be automorphisms of <em>G</em>. The group of automorphisms of <em>G</em> is called the <span class="underline">dihedral group of order 8</span> (see Example <a href="chapter004.html#Exa_4-2-1-4">4.2.1.4</a>). It has eight elements,</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch604"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo stretchy="false">&#x007B;</mo><mi>e</mi><mo>,</mo><mi>r</mi><mo>,</mo><msup><mi>r</mi><mn>2</mn></msup><mo>,</mo><msup><mi>r</mi><mn>3</mn></msup><mo>,</mo><mi>f</mi><mo>,</mo><mtext mathvariant="italic">fr</mtext><mo>,</mo><msup><mtext mathvariant="italic">fr</mtext><mn>2</mn></msup><mo>,</mo><msup><mtext mathvariant="italic">fr</mtext><mn>3</mn></msup><mo stretchy="false">&#x007D;</mo><mo>,</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>

<p class="noindent">where <em>r</em> means rotate the square clockwise 90&#x00B0;, and <em>f</em> means flip the square horizontally. For example, flipping the square vertically can be obtained by flipping horizontally and then rotating twice: <em>fr</em><sup>2</sup>.</p>
</section>


<section title="Preorders as categories">
<h3 class="level3" id="lev_5-2-1-12"><strong>5.2.1.12&#160;&#160;&#160;Preorders as categories</strong></h3>
<p class="noindent">A preorder (<em>X</em>,  &#x2A7D;) consists of a set <em>X</em> and a binary relation  &#x2A7D; that is reflexive and transitive. We can make from (<em>X</em>,  &#x2A7D;) &#x2208; Ob(<strong>PrO</strong>) a category <epub:switch id="mathmlSwitch605"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>X</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mtext mathvariant="bold">Cat</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> as follows. Define <epub:switch id="mathmlSwitch606"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>X</mi><mo stretchy='false'>)</mo><mo>=</mo><mi>X</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and for every two objects <em>x</em>, <em>y</em> &#x2208; <em>X</em>, define</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch607"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>X</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy='false'>)</mo><mo>=</mo><mrow><mo>{</mo><mrow><mtable columnalign='left'><mtr columnalign='left'><mtd columnalign='left'><mrow><mo>&#x007B;</mo><mo>&#x201C;</mo><mi>x</mi><mo> &#x2A7D;</mo><mi>y</mi><mo>&#x201D;</mo><mo>&#x007D;</mo></mrow></mtd><mtd columnalign='left'><mrow><mtext>if</mtext><mi>x</mi><mo> &#x2A7D;</mo><mi>y</mi><mo>,</mo></mrow></mtd></mtr><mtr columnalign='left'><mtd columnalign='left'><mo>&#x2205;</mo></mtd><mtd columnalign='left'><mrow><mtext>if</mtext><mi>x</mi><mo>&#x2270;</mo><mi>y</mi><mo>.</mo></mrow></mtd></mtr></mtable></mrow></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">To clarify: if <em>x</em>  &#x2A7D; <em>y</em>, we assign <epub:switch id="mathmlSwitch608"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>X</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> to be the set containing only one element, namely, the string &#x201C;<em>x</em>  &#x2A7D; <em>y</em>.&#x201D;<sup><a id="endnote_ref_6" href="chapter005.html#endnote_6">6</a></sup> If the pair (<em>x</em>, <em>y</em>) is not in relation  &#x2A7D;, then we assign <epub:switch id="mathmlSwitch609"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>X</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> to be the empty set. The composition formula</p>
<p class="disp-equ" id="eq_5-7"><epub:switch id="mathmlSwitch610"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtable><mtr><mtd columnalign='left'><mrow><mo>&#x25CB;</mo><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>X</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy='false'>)</mo><mo>&#x00D7;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>X</mi></msub><mo stretchy='false'>(</mo><mi>y</mi><mo>,</mo><mi>z</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>X</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>,</mo><mi>z</mi><mo stretchy='false'>)</mo></mrow></mtd><mtd columnalign='right'></mtd><mtd columnalign='right'><mrow><mo stretchy='false'>(</mo><mn>5.7</mn><mo stretchy='false'>)</mo></mrow></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<a id="p195"></a>
<p class="noindent">is completely determined because either one of two possibilities occurs. One possibility is that the left-hand side is empty (if either <em>x</em> &#x2270; <em>y</em> or <em>y</em> &#x2270; <em>z</em>; in this case there is a unique function &#x25CB; as in (<a href="chapter005.html#eq_5-7">5.7</a>)). The other possibility is that the left-hand side is not empty in case <em>x</em>  &#x2A7D; <em>y</em> and <em>y</em>  &#x2A7D; <em>z</em>, which implies <em>x</em>  &#x2A7D; <em>z</em>, so the right-hand side has exactly one element &#x201C;<em>x</em>  &#x2A7D; <em>z</em>&#x201D; in which case again there is a unique function &#x25CB; as in (<a href="chapter005.html#eq_5-7">5.7</a>).</p>
<p>On the other hand, if <epub:switch id="mathmlSwitch611"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> is a category having the property that for every pair of objects <epub:switch id="mathmlSwitch612"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, the set <epub:switch id="mathmlSwitch613"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is either empty or has one element, then we can form a preorder out of <epub:switch id="mathmlSwitch614"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>. Namely, take <epub:switch id="mathmlSwitch615"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi><mo>=</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and say <em>x</em>  &#x2A7D; <em>y</em> if there exists a morphism <em>x</em> &#x2192; <em>y</em> in <epub:switch id="mathmlSwitch616"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="noindent1-top-pro" id="Pro_5-2-1-13"><strong>Proposition 5.2.1.13</strong>. <em>There is a functor i</em>: <strong>PrO</strong> &#x2192; <strong>Cat</strong> <em>with the following properties for every preorder</em> (<em>X</em>,  &#x2A7D;)<em>:</em></p>
<ol class="olindent">
<li><em>the category</em> <epub:switch id="mathmlSwitch617"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>X</mi><mo>&#x2254;</mo><mi>i</mi><mo stretchy='false'>(</mo><mi>X</mi><mo>,</mo><mo> &#x2A7D;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>has objects</em> <epub:switch id="mathmlSwitch618"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>X</mi><mo stretchy='false'>)</mo><mo>=</mo><mi>X</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</li>
<li class="litop"><em>For each pair of elements</em> <epub:switch id="mathmlSwitch619"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi><mo>,</mo><mi>x</mi><mo>&#x2032;</mo><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>X</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <em>the set</em> <epub:switch id="mathmlSwitch620"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>X</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>,</mo><mi>x</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>has at most one element</em>.</li>
</ol>
<p class="noindent"><em>Moreover, any category with property</em> 2 <em>is in the image of the functor i</em>.</p>

<p class="noindent1-top"><em>Proof</em>. To specify a functor <em>i</em> : <strong>PrO</strong> &#x2192; <strong>Cat</strong>, we need to say what it does on objects and on morphisms. To an object (<em>X</em>,  &#x2A7D;) in <strong>PrO</strong>, we assign the category <epub:switch id="mathmlSwitch621"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>X</mi></math></epub:case><epub:default></epub:default></epub:switch> with objects <em>X</em> and a unique morphism <em>x</em> &#x2192; <em>x</em>&#x2032; if <em>x</em>  &#x2A7D; <em>x</em>&#x2032;. To a morphism <em>f</em> : (<em>X</em>,  &#x2A7D;<em><sub>X</sub></em>) &#x2192; (<em>Y</em>,  &#x2A7D;<em><sub>Y</sub></em>) of preorders, we must assign a functor <epub:switch id="mathmlSwitch622"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>i</mi><mo stretchy='false'>(</mo><mi>f</mi><mo stretchy='false'>)</mo><mo>:</mo><mi mathvariant='script'>X</mi><mo>&#x2192;</mo><mi mathvariant='script'>Y</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Again, to specify a functor, we need to say what it does on objects and morphisms of <epub:switch id="mathmlSwitch623"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>X</mi></math></epub:case><epub:default></epub:default></epub:switch>. To an object <epub:switch id="mathmlSwitch624"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>X</mi><mo stretchy='false'>)</mo><mo>=</mo><mi>X</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we assign the object <epub:switch id="mathmlSwitch625"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo stretchy='false'>(</mo><mi>x</mi><mo stretchy='false'>)</mo><mo>&#x2208;</mo><mi>Y</mi><mo>=</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>Y</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Given a morphism <em>f</em> : <em>x</em> &#x2192; <em>x</em>&#x2032; in <epub:switch id="mathmlSwitch626"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>X</mi></math></epub:case><epub:default></epub:default></epub:switch>, we know that <em>x</em>  &#x2A7D; <em>x</em>&#x2032;, so by Definition <a href="chapter004.html#Def_4-4-4-1">4.4.4.1</a> we have that <em>f</em>(<em>x</em>)  &#x2A7D; <em>f</em>(<em>x</em>&#x2032;), and we assign to <em>f</em> the unique morphism <em>f</em>(<em>x</em>) &#x2192; <em>f</em>(<em>x</em>&#x2032;) in <epub:switch id="mathmlSwitch627"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>Y</mi></math></epub:case><epub:default></epub:default></epub:switch>. To check that the rules of functors (preservation of identities and composition) are obeyed is routine.</p>
<p class="noindent1-top-slo"><em>Slogan</em> 5.2.1.14.</p>
<div class="pull-quote">
<p class="pq-noindent"><em>A preorder is a category in which every hom-set has either 0 elements or 1 element. A preorder morphism is just a functor between such categories</em>.</p>
</div>
<p class="noindent1-top-exe" id="Exe_5-2-1-15"><em>Exercise</em> 5.2.1.15.</p>
<p>Suppose that <epub:switch id="mathmlSwitch628"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> is a preorder (considered as a category). Let <epub:switch id="mathmlSwitch629"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be objects such that <em>x</em>  &#x2A7D; <em>y</em> and <em>y</em>  &#x2A7D; <em>x</em>. Prove that there is an isomorphism <em>x</em> &#x2192; <em>y</em> in <epub:switch id="mathmlSwitch630"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<a id="p196"></a>
<p class="noindent1-top-exe" id="Exe_5-2-1-16"><em>Exercise</em> 5.2.1.16.</p>
<p>Proposition <a href="chapter005.html#Pro_5-2-1-13">5.2.1.13</a> stated that a preorder can be considered as a category <epub:switch id="mathmlSwitch631"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>P</mi></math></epub:case><epub:default></epub:default></epub:switch>. Recall from Definition <a href="chapter004.html#Def_4-4-1-1">4.4.1.1</a> that a partial order is a preorder with an additional property. Phrase the defining property for partial orders in terms of isomorphisms in the category <epub:switch id="mathmlSwitch632"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>P</mi></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="noindent1-top-exe" id="Exa_5-2-1-17"><em>Example</em> 5.2.1.17. The olog from Example <a href="chapter004.html#Exa_4-4-1-3">4.4.1.3</a> depicted a partial order, call it <epub:switch id="mathmlSwitch633"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>P</mi></math></epub:case><epub:default></epub:default></epub:switch>. In it we have</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch634"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>P</mi></msub><mo stretchy='false'>(</mo><mo>&#x231C;</mo><mtext>a diamond</mtext><mo>&#x231D;</mo><mo>,</mo><mo>&#x231C;</mo><mtext>a red card</mtext><mo>&#x231D;</mo><mo>)</mo><mo>=</mo><mo>&#x007B;</mo><mtext>is</mtext><mo>&#x007D;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">and</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch635"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>P</mi></msub><mo stretchy='false'>(</mo><mo>&#x231C;</mo><mtext>a black queen</mtext><mo>&#x231D;</mo><mo>,</mo><mo>&#x231C;</mo><mtext>a card</mtext><mo>&#x231D;</mo><mo stretchy='false'>)</mo><mo>&#x2245;</mo><mo>&#x007B;</mo><mtext>is</mtext><mo>&#x25CB;</mo><mtext>is</mtext><mo>&#x007D;</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">Both of these sets contain exactly one element; the name is not important. The set <epub:switch id="mathmlSwitch636"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant="script">P</mi></msub><mo stretchy='false'>(</mo><mo>&#x231C;</mo><mi mathvariant="normal">a</mi><mo>&#x00A0;</mo><mn>4</mn><mo>&#x231D;</mo><mo>,</mo><mo>&#x231C;</mo><mi mathvariant="normal">a</mi><mo>&#x00A0;</mo><mn>4</mn><mo>&#x00A0;</mo><mtext>of diamonds</mtext><mo>&#x231D;</mo><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x2205;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="noindent1-top-exe" id="Exe_5-2-1-18"><em>Exercise</em> 5.2.1.18.</p>
<p>Every linear order is a preorder with a special property. Using the categorical interpretation of preorders, can you phrase the property of being a linear order in terms of hom-sets?</p>
<p class="noindent1-top-exe" id="Exe_5-2-1-19"><em>Exercise</em> 5.2.1.19.</p>
<p>Recall the functor <em>P</em> : <strong>PrO</strong> &#x2192; <strong>Grph</strong> from Proposition <a href="chapter005.html#Pro_5-1-2-10">5.1.2.10</a>, the functors <em>F</em> : <strong>Grph</strong> &#x2192; <strong>Cat</strong> and <em>U</em> : <strong>Cat</strong> &#x2192; <strong>Grph</strong> from Example <a href="chapter005.html#Exe_5-1-2-36">5.1.2.36</a>, and the functor <em>i</em>: <strong>PrO</strong> &#x2192; <strong>Cat</strong> from Proposition <a href="chapter005.html#Pro_5-2-1-13">5.2.1.13</a>.</p>
<p class="nl1-list">a. Do either of the following diagrams of categories commute?</p>
<p class="fig-img"><img src="images/Art_P166.jpg" alt="art"/></p>
<p class="nl1-list">b. We also gave a functor <em>Im</em>: <strong>Grph</strong> &#x2192; <strong>PrO</strong> in Exercise <a href="chapter005.html#Exe_5-1-2-13">5.1.2.13</a>. Does the following diagram of categories commute?</p>
<p class="fig-img"><img src="images/Art_P167.jpg" alt="art"/></p>
<a id="p197"></a>
<p class="noindent1-top-pro" id="Pro_5-2-1-20"><strong>Proposition 5.2.1.20</strong>. <em>There is a unique functor R</em>: <strong>Cat</strong> &#x2192; <strong>PrO</strong> <em>with the following properties:</em></p>
<ol class="olindent">
<li><em>For each category</em> <epub:switch id="mathmlSwitch637"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, <em>the preorder</em> <epub:switch id="mathmlSwitch638"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo stretchy='false'>(</mo><mi>X</mi><mo>,</mo><mo> &#x2A7D;</mo><mo stretchy='false'>)</mo><mo>&#x2254;</mo><mi>R</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>has the same set of objects</em>, <epub:switch id="mathmlSwitch639"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi><mo>=</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</li>
<li class="litop"><em>For each pair of objects</em> <epub:switch id="mathmlSwitch640"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <em>we have x</em>  &#x2A7D; <em>y in R</em>(<em>C</em>) <em>if and only if the hom-set</em> <epub:switch id="mathmlSwitch641"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy='false'>)</mo><mo>&#x2260;</mo><mo>&#x2205;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>is nonempty</em>.</li>
</ol>
<p class="noindent"><em>Furthermore, if i</em>: <strong>PrO</strong> &#x2192; <strong>Cat</strong> <em>is the inclusion from Proposition</em> <a href="chapter005.html#Pro_5-2-1-13">5.2.1.13</a>, <em>we have R</em> &#x25CB; <em>i</em> &#x003D; id<strong><sub>PrO</sub></strong>.</p>
<p class="noindent1-top"><em>Proof</em>. Given a category <epub:switch id="mathmlSwitch642"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, we define a preorder <epub:switch id="mathmlSwitch643"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>R</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo><mo>&#x2254;</mo><mo stretchy='false'>(</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo><mo>,</mo><mo> &#x2A7D;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, where <em>x</em>  &#x2A7D; <em>y</em> if and only if <epub:switch id="mathmlSwitch644"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy='false'>)</mo><mo>&#x2260;</mo><mo>&#x2205;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. This is indeed a preorder because the identity law and composition law for a category ensure the reflexivity and transitivity properties of preorders hold. Given a functor <epub:switch id="mathmlSwitch645"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> (i.e., a morphism in <strong>Cat</strong>), we get <epub:switch id="mathmlSwitch646"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi>F</mi><mo stretchy='false'>)</mo><mo>:</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and for <em>R</em> to be defined on morphisms, we need to check that this function preserves order. If <em>x</em>  &#x2A7D; <em>y</em> in <epub:switch id="mathmlSwitch647"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>R</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, then there is a morphism <em>g</em> : <em>x</em> &#x2192; <em>y</em> in <epub:switch id="mathmlSwitch648"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, so there is a morphism <em>F</em>(<em>g</em>) : <em>F</em>(<em>x</em>) &#x2192; <em>F</em>(<em>y</em>), which means <em>F</em>(<em>x</em>)  &#x2A7D; <em>F</em>(<em>y</em>) in <epub:switch id="mathmlSwitch649"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></math></epub:case><epub:default></epub:default></epub:switch>. It is straightforward to see now that <em>R</em> is a functor, and there was no other way to construct <em>R</em> satisfying the desired properties. It is also easy to see that <em>R</em> &#x25CB; <em>i</em> &#x003D; id<strong><sub>PrO</sub></strong>.</p>
</section>


<section title="Graphs as functors">
<h3 class="level3" id="lev_5-2-1-21"><strong>5.2.1.21&#160;&#160;&#160;Graphs as functors</strong></h3>
<p class="noindent">Let <epub:switch id="mathmlSwitch650"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> denote the category depicted as follows:</p>
<p class="fig-img" id="eq_5-8"><img src="images/Art_P168.jpg" alt="art"/></p>
<p class="noindent">Then a functor <em>G</em> : <strong>GrIn</strong> &#x2192; <strong>Set</strong> is the same thing as two sets <em>G</em>(<em>Ar</em>), <em>G</em>(<em>Ve</em>) and two functions <em>G</em>(<em>src</em>) : <em>G</em>(<em>Ar</em>) &#x2192; <em>G</em>(<em>Ve</em>) and <em>G</em>(<em>tgt</em>) : <em>G</em>(<em>Ar</em>) &#x2192; <em>G</em>(<em>Ve</em>). This is precisely what is needed for a graph; see Definition <a href="chapter004.html#Def_4-3-1-1">4.3.1.1</a>. We call <strong>GrIn</strong> the <em>graph-indexing category</em>.</p>
<p class="noindent1-top-exe" id="Exe_5-2-1-22"><em>Exercise</em> 5.2.1.22.</p>
<p>Consider the terminal category, <span class="underline">1</span>, also known as the discrete category on one element (see Exercise <a href="chapter005.html#Exe_5-1-2-40">5.1.2.40</a>). Let <strong>GrIn</strong> be as in (<a href="chapter005.html#eq_5-8">5.8</a>) and consider the functor <em>i</em><sub>0</sub> : <span class="underline">1</span> &#x2192; <strong>GrIn</strong> sending the unique object of <span class="underline">1</span> to the object <em>V e</em> &#x2208; Ob(<strong>GrIn</strong>).</p>
<p class="nl1-list">a. If <em>G</em> : <strong>GrIn</strong> &#x2192; <strong>Set</strong> is a graph, what is the composite <em>G</em> &#x25CB; <em>i</em><sub>0</sub>? It consists of only one set; in terms of the graph <em>G</em>, what set is it?</p>
<a id="p198"></a>
<p class="nl1-list">b. As an example, what set is it when <em>G</em> is the graph from Example <a href="chapter004.html#Exa_4-3-3-3">4.3.3.3</a>?</p>

<p class="space-break">If a graph is a functor <strong>GrIn</strong> &#x2192; <strong>Set</strong>, what is a graph homomorphism? Example <a href="chapter005.html#Exa_5-3-1-20">5.3.1.20</a> shows that graph homomorphisms are homomorphisms between functors, which are called natural transformations. (Natural transformations are the highest-level structure in ordinary category theory.)</p>
<p class="noindent1-top-exe" id="Exa_5-2-1-23"><em>Example</em> 5.2.1.23. Let <strong>SGrIn</strong> be the category depicted as follows:</p>
<p class="fig-img" id="eq_5-9"><img src="images/Art_P169.jpg" alt="art"/></p>
<p class="noindent">with the following composition formula:</p>
<p class="disp-eq-no"><epub:switch id="mathmlSwitch651"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtable columnalign='left'><mtr columnalign='left'><mtd columnalign='left'><mrow><mi>&#x03C1;</mi><mo>&#x25CB;</mo><mi>&#x03C1;</mi><mo>=</mo><msub><mrow><mtext>id</mtext></mrow><mi>A</mi></msub><mo>;</mo></mrow></mtd><mtd columnalign='left'><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mrow><mtext mathvariant="italic">src</mtext><mo>&#x25CB;</mo><mi>&#x03C1;</mi><mo>=</mo><mtext mathvariant="italic">tgt</mtext><mo>;</mo></mrow></mtd><mtd columnalign='left'><mrow><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mtext>and</mtext><mo>&#x00A0;</mo></mrow></mtd><mtd columnalign='left'><mrow><mtext mathvariant="italic">tgt</mtext><mo>&#x25CB;</mo><mi>&#x03C1;</mi><mo>=</mo><mtext mathvariant="italic">src</mtext><mo>.</mo></mrow></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p>The idea here is that the morphism <em>&#x03C1;</em>: <em>A</em> &#x2192; <em>A</em> reverses arrows. The PED <sub><em>A</em></sub>[<em>&#x03C1;</em>, <em>&#x03C1;</em>] &#x003D; <em><sub>A</sub></em>[ ] forces the fact that the reverse of the reverse of an arrow yields the original arrow. The PEDs <sub><em>A</em></sub>[<em>&#x03C1;</em>, <em>src</em>] &#x003D; <sub><em>A</em></sub>[<em>tgt</em>] and <sub><em>A</em></sub>[<em>&#x03C1;</em>, <em>tgt</em>] &#x003D; <sub><em>A</em></sub>[<em>src</em>] force the fact that when we reverse an arrow, its source and target switch roles.</p>
<p>This category <strong>SGrIn</strong> is the <em>symmetric graph-indexing category</em>. Just as any graph can be understood as a functor <strong>GrIn</strong> &#x2192; <strong>Set</strong>, where <strong>GrIn</strong> is the graph-indexing category displayed in (<a href="chapter005.html#eq_5-8">5.8</a>), any symmetric graph can be understood as a functor <strong>SGrIn</strong> &#x2192; <strong>Set</strong>, where <strong>SGrIn</strong> is the category drawn in (<a href="chapter005.html#eq_5-9">5.9</a>). Given a functor <em>G</em> : <strong>SGrIn</strong> &#x2192; <strong>Set</strong>, we will have a set of arrows, a set of vertices, a source operation, a target operation, and a reverse-direction operation (<em>&#x03C1;</em>) that all behave as expected.</p>
<p>It is customary to draw the connections in a symmetric graph <em>G</em> as line segments rather than arrows between vertices. However, a better heuristic is to think that each connection between vertices in <em>G</em> consists of two arrows, one pointing in each direction.</p>
<p class="noindent1-top-slo"><em>Slogan</em> 5.2.1.24.</p>
<div class="pull-quote">
<p class="pq-noindent"><em>In a symmetric graph, every arrow has an equal and opposite arrow</em>.</p>
</div>
<p class="noindent1-top-exe" id="Exe_5-2-1-25"><em>Exercise</em> 5.2.1.25.</p>
<p>Which of the following graphs are symmetric:</p>

<p class="nl1-list">a. The graph <em>G</em> from (4.3)?</p>
<p class="nl1-list">b. The graph <em>G</em> from Exercise <a href="chapter004.html#Exe_4-3-1-10">4.3.1.10</a>?</p>
<a id="p199"></a>
<p class="nl1-list">c. The graph <em>G</em>&#x2032; from (4.6)?</p>
<p class="nl1-list">d. The graph <epub:switch id="mathmlSwitch652"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> from (4.16), i.e., the graph having exactly one vertex and one arrow?</p>
<p class="nl1-list">e. The graph <em>G</em> from Exercise <a href="chapter005.html#Exe_5-2-1-11">5.2.1.11</a>?</p>
<p class="noindent1-top-exe" id="Exe_5-2-1-26"><em>Exercise</em> 5.2.1.26.</p>
<p>Let <strong>GrIn</strong> be the graph-indexing category shown in (<a href="chapter005.html#eq_5-8">5.8</a>), and let <strong>SGrIn</strong> be the symmetric graph-indexing category displayed in (<a href="chapter005.html#eq_5-9">5.9</a>).</p>
<p class="nl1-list">a. How many functors are there of the form <strong>GrIn</strong> &#x2192; <strong>SGrIn</strong>?</p>
<p class="nl1-list">b. Is one more reasonable than the others? If so, call it <em>i</em> : <strong>GrIn</strong> &#x2192; <strong>SGrIn</strong>, and write how it acts on objects and morphisms.</p>
<p class="nl1-list">c. Choose a functor <em>i</em> : <strong>GrIn</strong> &#x2192; <strong>SGrIn</strong>, the most reasonable one, if such a thing exists. seems most reasonable and call it <em>i</em> : <strong>GrIn</strong> &#x2192; <strong>SGrIn</strong>. If a symmetric graph is a functor <em>S</em> : <strong>SGrIn</strong> &#x2192; <strong>Set</strong>, you can compose with <em>i</em> to get a functor <em>S</em> &#x25CB; <em>i</em> : <strong>GrIn</strong> &#x2192; <strong>Set</strong>. This is a graph; what graph is it? What has changed?</p>

<p class="noindent1-top-exe" id="Exa_5-2-1-27"><em>Example</em> 5.2.1.27. Let <epub:switch id="mathmlSwitch653"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> be a category, and consider the set of isomorphisms in <epub:switch id="mathmlSwitch654"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>. Each isomorphism <em>f</em> : <em>c</em> &#x2192; <em>c</em>&#x2032; in <epub:switch id="mathmlSwitch655"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> has an inverse as well as a domain (<em>c</em>) and a codomain (<em>c</em>&#x2032;). Thus we can build a symmetric graph <epub:switch id="mathmlSwitch656"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>I</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo><mo>:</mo><mtext mathvariant='bold'>SGrIn</mtext><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Its vertices are the objects in <epub:switch id="mathmlSwitch657"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, and its arrows are the isomorphisms in <epub:switch id="mathmlSwitch658"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>.</p>
</section>
</section>

<section title="Database schemas present categories">
<h2 class="level2" id="lev_5-2-2"><strong>5.2.2&#160;&#160;&#160;Database schemas present categories</strong></h2>
<p class="noindent">Recall from Definition <a href="chapter004.html#Def_4-5-2-7">4.5.2.7</a> that a database schema (or schema, for short) consists of a graph together with a certain kind of equivalence relation, namely a congruence, on its paths. Section <a href="chapter005.html#lev_5-4-1">5.4.1</a> defines a category <strong>Sch</strong> that has schemas as objects and appropriately modified graph homomorphisms as morphisms. Section <a href="chapter005.html#lev_5-4-2">5.4.2</a> proves that the category of schemas is equivalent (in the sense of Definition <a href="chapter005.html#Def_5-3-4-1">5.3.4.1</a>) to the category of categories,</p>
<p class="disp-eq-no"><epub:switch id="mathmlSwitch659"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtext mathvariant="bold">Sch</mtext><mo>&#x2243;</mo><mtext mathvariant="bold">Cat</mtext><mo>.</mo></math></epub:case><epub:default></epub:default></epub:switch></p>
<p>The difference between schemas and categories is like the difference between monoid presentations, given by generators and relations as in Definition <a href="chapter004.html#Def_4-1-1-19">4.1.1.19</a>, and the monoids themselves. The same monoid has (infinitely) many different presentations, and so it is for categories: many different schemas can <em>present</em> the same category. Computer scientists may think of the schema as <em>syntax</em> and the category it presents as the corresponding <a id="p200"></a><em>semantics</em>. A schema is a compact form and can be specified in finite space and time, whereas the category it generates can be infinite.</p>
<p class="noindent1-top-slo"><em>Slogan</em> 5.2.2.1.</p>
<div class="pull-quote">
<p class="pq-noindent"><em>A database schema is a category presentation</em>.</p>
</div>
<p>Section <a href="chapter005.html#lev_5-4-2">5.4.2</a> formally shows how to turn a schema into a category (the category it <em>presents</em>). For now, it seems better not to be so formal, because the idea is fairly straightforward. Suppose given a schema <epub:switch id="mathmlSwitch660"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>S</mi></math></epub:case><epub:default></epub:default></epub:switch>, which consists of a graph <em>G</em> &#x003D; (<em>V</em>, <em>A</em>, <em>src</em>, <em>tgt</em>) equipped with a congruence &#x007E; (see Definition <a href="chapter004.html#Def_4-5-2-3">4.5.2.3</a>). It presents a category <epub:switch id="mathmlSwitch661"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> defined as follows. The set of objects in <epub:switch id="mathmlSwitch662"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> is defined to be the vertices <em>V</em>; the set of morphisms in <epub:switch id="mathmlSwitch663"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> is defined to be the quotient Paths(<em>G</em>)/ &#x007E;; and the composition formula is given by concatenation of paths. The path equivalences making up &#x007E; become commutative diagrams in <epub:switch id="mathmlSwitch664"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="noindent1-top-exe" id="Exa_5-2-2-2"><em>Example</em> 5.2.2.2. The following schema <epub:switch id="mathmlSwitch665"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> has no path equivalence declarations. As a graph it has one vertex and one arrow.</p>
<p class="fig-img"><img src="images/Art_P170.jpg" alt="art"/></p>
<p class="noindent">The category it generates, however, is the free monoid on one generator, &#x2115;. It has one object <em>s</em>, but a morphism <em>f<sup>n</sup></em> : <em>s</em> &#x2192; <em>s</em> for every natural number <em>n</em> &#x2208; &#x2115;, thought of as &#x201C;how many times to go around the loop <em>f</em>.&#x201D; Clearly, the schema is more compact than the infinite category it generates.</p>
<p class="noindent1-top-exe" id="Exe_5-2-2-3"><em>Exercise</em> 5.2.2.3.</p>
<p>Consider the olog from Exercise <a href="chapter004.html#Exe_4-5-2-19">4.5.2.19</a>, which says that for any father <em>x</em>, his youngest child&#x2019;s father is <em>x</em> and his tallest child&#x2019;s father is <em>x</em>. It is redrawn here as a schema <epub:switch id="mathmlSwitch666"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>S</mi></math></epub:case><epub:default></epub:default></epub:switch>, which includes the desired path equivalence declarations, <sub><em>F</em></sub>[<em>t</em>, <em>f</em>] &#x003D; <em><sub>F</sub></em> [ ] and <sub><em>F</em></sub>[<em>y</em>, <em>f</em>] &#x003D; <em><sub>F</sub></em> [ ].</p>
<p class="fig-img"><img src="images/Art_P171.jpg" alt="art"/></p>
<p class="noindent">How many morphisms are there (total) in the category presented by <epub:switch id="mathmlSwitch667"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>S</mi></math></epub:case><epub:default></epub:default></epub:switch>?</p>
<a id="p201"></a>
<p class="noindent1-top-sol"><em>Solution</em> 5.2.2.3.</p>
<p>There are seven. Let <epub:switch id="mathmlSwitch668"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mi mathvariant='script'>S</mi><mo>&#x00AF;</mo></mover></math></epub:case><epub:default></epub:default></epub:switch> be the category presented by <epub:switch id="mathmlSwitch669"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>S</mi></math></epub:case><epub:default></epub:default></epub:switch>. We have</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch670"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtable columnalign='left'><mtr columnalign='left'><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mover accent='true'><mi mathvariant='script'>S</mi><mo>&#x00AF;</mo></mover></msub><mo stretchy='false'>(</mo><mi>F</mi><mo>,</mo><mi>F</mi><mo stretchy='false'>)</mo><mo>=</mo><msub><mo>&#x007B;</mo><mi>F</mi></msub><mo stretchy='false'>[</mo><mo stretchy='false'>]</mo><mo>&#x007D;</mo><mo>;</mo></mrow></mtd><mtd columnalign='left'><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mrow><msub><mrow><mtext>Hom</mtext></mrow><mover accent='true'><mi mathvariant='script'>S</mi><mo>&#x00AF;</mo></mover></msub><mo stretchy='false'>(</mo><mi>F</mi><mo>,</mo><mi>C</mi><mo stretchy='false'>)</mo><mo>=</mo><msub><mo>&#x007B;</mo><mi>F</mi></msub><mo stretchy='false'>[</mo><mi>t</mi><mo stretchy='false'>]</mo><mo>,</mo><msub><mo>&#x00A0;</mo><mi>F</mi></msub><mo stretchy='false'>[</mo><mi>y</mi><mo stretchy='false'>]</mo><mo>&#x007D;</mo><mo>;</mo></mrow></mtd></mtr><mtr columnalign='left'><mtd columnalign='left'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mover accent='true'><mi mathvariant='script'>S</mi><mo>&#x00AF;</mo></mover></msub><mo stretchy='false'>(</mo><mi>C</mi><mo>,</mo><mi>F</mi><mo stretchy='false'>)</mo><mo>=</mo><msub><mo>&#x007B;</mo><mi>C</mi></msub><mo stretchy='false'>[</mo><mi>f</mi><mo stretchy='false'>]</mo><mo>&#x007D;</mo><mo>;</mo></mrow></mtd><mtd columnalign='left'><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mrow><msub><mrow><mtext>Hom</mtext></mrow><mover accent='true'><mi mathvariant='script'>S</mi><mo>&#x00AF;</mo></mover></msub><mo stretchy='false'>(</mo><mi>C</mi><mo>,</mo><mi>C</mi><mo stretchy='false'>)</mo><mo>=</mo><msub><mo>&#x007B;</mo><mi>C</mi></msub><mo stretchy='false'>[</mo><mo stretchy='false'>]</mo><mo>,</mo><msub><mo>&#x00A0;</mo><mi>C</mi></msub><mo stretchy='false'>[</mo><mi>f</mi><mo>,</mo><mi>t</mi><mo stretchy='false'>]</mo><mo>,</mo><msub><mo>&#x00A0;</mo><mi>C</mi></msub><mo stretchy='false'>[</mo><mi>f</mi><mo>,</mo><mi>y</mi><mo stretchy='false'>]</mo><mo>&#x007D;</mo><mo>.</mo></mrow></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">Given a child, the three morphisms <em>C</em> &#x2192; <em>C</em> respectively return the child herself, her tallest sibling (technically, her father&#x2019;s tallest child), and her youngest sibling (technically, her father&#x2019;s youngest child).</p>

<p class="noindent1-top-exe" id="Exe_5-2-2-4"><em>Exercise</em> 5.2.2.4.</p>
<p>Suppose that <em>G</em> is a graph and that <epub:switch id="mathmlSwitch671"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>G</mi></math></epub:case><epub:default></epub:default></epub:switch> is the schema generated by <em>G</em> with no PEDs. What is the relationship between the category generated by <epub:switch id="mathmlSwitch672"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>G</mi></math></epub:case><epub:default></epub:default></epub:switch> and the free category <em>F</em>(<em>G</em>) &#x2208; Ob(<strong>Cat</strong>), as defined in Example <a href="chapter005.html#Exa_5-1-2-33">5.1.2.33</a>?</p>
<p class="noindent1-top-exe" id="Exe_5-2-2-5"><em>Exercise</em> 5.2.2.5.</p>
<p>Let <epub:switch id="mathmlSwitch673"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>C</mi><mo>=</mo><mo stretchy='false'>(</mo><mi>G</mi><mo>,</mo><mo>&#x2243;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be a schema. A leaf table is an object <epub:switch id="mathmlSwitch674"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> with no outgoing arrows.</p>
<p class="nl1-list">a. Express the condition of being a leaf table mathematically in three different languages: that of graphs (using symbols <em>V</em>, <em>A</em>, <em>src</em>, <em>tgt</em>), that of categories (using <epub:switch id="mathmlSwitch675"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>, etc.), and that of tables (in terms of columns, tables, rows, etc.).</p>
<p class="nl1-list">b. In the language of categories, is there a difference between a terminal object and a leaf table? Explain.</p>



<section title="Instances on a schema C">
<h3 class="level3" id="lev_5-2-2-6"><strong>5.2.2.6&#160;&#160;&#160;Instances on a schema</strong> <epub:switch id="mathmlSwitch676"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch></h3>
<p class="noindent">If schemas are like categories, what are instances? Recall that an instance <em>I</em> on a schema <epub:switch id="mathmlSwitch677"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>S</mi><mo>=</mo><mo stretchy='false'>(</mo><mi>G</mi><mo>,</mo><mo>&#x2243;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> assigns to each vertex <em>v</em> in <em>G</em> a set of rows, say, <em>I</em>(<em>v</em>) &#x2208; Ob(<strong>Set</strong>). And to every arrow <em>a</em> : <em>v</em> &#x2192; <em>v</em>&#x2032; in <em>G</em> the instance assigns a function <em>I</em>(<em>a</em>): <em>I</em>(<em>v</em>) &#x2192; <em>I</em>(<em>v</em>&#x2032;). The rule is that given two equivalent paths, their compositions must give the same function. Concisely, an instance is a functor <epub:switch id="mathmlSwitch678"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>S</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="noindent1-top-exe" id="Exa_5-2-2-7"><em>Example</em> 5.2.2.7. We have seen that a monoid is just a category <epub:switch id="mathmlSwitch679"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> with one object and that a monoid action is a functor <epub:switch id="mathmlSwitch680"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> &#x2192; <strong>Set</strong>. With database schemas as categories, <epub:switch id="mathmlSwitch681"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a schema, and so an action becomes an instance of that schema. The monoid action table from Example <a href="chapter004.html#Exa_4-1-3-1">4.1.3.1</a> was simply a manifestation of the database instance according to the Rules <a href="chapter004.html#rul_4-5-2-9">4.5.2.9</a>.</p>
<a id="p202"></a>
<p class="noindent1-top-exe" id="Exe_5-2-2-8"><em>Exercise</em> 5.2.2.8.</p>
<p>Section <a href="chapter005.html#lev_5-2-1-21">5.2.1.21</a> discussed how each graph is a functor <strong>GrIn</strong> &#x2192; <strong>Set</strong> for the graph-indexing category depicted here:</p>
<p class="fig-img"><img src="images/Art_P172.jpg" alt="art"/></p>
<p class="noindent">But now we know that if a graph is a set-valued functor, then we can consider <strong>GrIn</strong> as a database schema.</p>
<p class="nl1-list">a. How many tables, and how many foreign key columns of each should there be (if unsure, consult Rules <a href="chapter004.html#rul_4-5-2-9">4.5.2.9</a>)?</p>
<p class="nl1-list">b. Write the table view of graph <em>G</em> from Example <a href="chapter004.html#Exa_4-3-3-3">4.3.3.3</a>.</p>

</section>
</section>

<section title="Spaces">
<h2 class="level2" id="lev_5-2-3"><strong>5.2.3&#160;&#160;&#160;Spaces</strong></h2>
<p class="noindent">Category theory was invented for use in algebraic topology, and in particular, to discuss natural transformations between certain functors. Section <a href="chapter005.html#lev_5-3">5.3</a> discusses natural transformations more formally. It suffices now to say a natural transformation is some kind of morphism between functors. In the original use, Eilenberg and Mac Lane were interested in functors that connect topological spaces (e.g., shapes such as spheres) to algebraic systems (e.g., groups).</p>
<p>For example, there is a functor that assigns to each space <em>X</em> its group <em>&#x03C0;</em><sub>1</sub>(<em>X</em>) of round-trip voyages (starting and ending at some chosen point <em>x</em> &#x2208; <em>X</em>), modulo some equivalence relation. There is another functor that assigns to every space its group <em>H</em>&#x2124;<sub>1</sub>(<em>X</em>) of ways to drop some (positive or negative) number of circles on <em>X</em>.</p>
<p>These two functors, <em>&#x03C0;</em><sub>1</sub> and <em>H</em>&#x2124;<sub>1</sub> are related, but they are not equal. For example, when <em>X</em> is the figure-8 space (two circles joined at a point) the group <em>&#x03C0;</em><sub>1</sub>(<em>X</em>) is much bigger than the group <em>H</em>&#x2124;<sub>1</sub>(<em>X</em>). Indeed, <em>&#x03C0;</em><sub>1</sub>(<em>X</em>) includes information about the order and direction of loops traveled during the voyage, whereas the group <em>H</em>&#x2124;<sub>1</sub>(<em>X</em>) includes only information about how many times one goes around each loop. However, there is a natural transformation of functors <em>&#x03C0;</em><sub>1</sub> &#x2192; <em>H</em>&#x2124;<sub>1</sub>, called the Hurewicz transformation, which takes <em>&#x03C0;</em><sub>1</sub>&#x2019;s voyage, counts how many times it went around each loop, and delivers that information to <em>H</em>&#x2124;<sub>1</sub>.</p>
<p class="noindent1-top-exe" id="Exa_5-2-3-1"><em>Example</em> 5.2.3.1. Given a set <em>X</em>, recall that &#x2119;(<em>X</em>) denotes the preorder of subsets of <em>X</em>. A <em>topology</em> on <em>X</em> is a choice of which subsets <em>U</em> &#x2208; &#x2119;(<em>X</em>) will be called <em>open sets</em>. To be <a id="p203"></a>a topology, these open sets must follow two rules. Namely, the union of any number of open sets must be considered to be an open set, and the intersection of any finite number of open sets must be considered open. One could say succinctly that a topology on <em>X</em> is a suborder Open(<em>X</em>) &#x2286; &#x2119;(<em>X</em>) that is closed under taking finite meets and infinite joins.</p>

<p>A <em>topological space</em> is a pair (<em>X</em>, Open(<em>X</em>)), where <em>X</em> is a set and Open(<em>X</em>) is a topology on <em>X</em>. The elements of the set <em>X</em> are called <em>points</em>. A <em>morphism of topological spaces</em> (also called a <em>continuous map</em>) is a function <em>f</em> : <em>X</em> &#x2192; <em>Y</em> such that for every <em>V</em> &#x2208; Open(<em>Y</em>), the preimage <em>f</em><sup>&#x2212;1</sup>(<em>V</em>) &#x2208; &#x2119;(<em>X</em>) is actually in Open(<em>X</em>), that is, such that there exists a dashed arrow making the following diagram commute:</p>
<p class="fig-img"><img src="images/Art_P173.jpg" alt="art"/></p>
<p class="noindent">The <em>category of topological spaces</em>, denoted <strong>Top</strong>, is the category having the preceding objects and morphisms.</p>
<p class="noindent1-top-exe" id="Exe_5-2-3-2"><em>Exercise</em> 5.2.3.2.</p>
<p class="nl1-list">a. Explain how looking at points gives a functor <strong>Top</strong> &#x2192; <strong>Set</strong>.</p>
<p class="nl1-list">b. Does looking at open sets give a functor <strong>Top</strong> &#x2192; <strong>PrO</strong>?</p>
<p class="noindent1-top-sol"><em>Solution</em> 5.2.3.2.</p>
<p class="nl1-list">a. A topological space (<em>X</em>, Open(<em>X</em>)) includes a set <em>X</em> &#x2208; Ob(<strong>Set</strong>) of points. A morphism (<em>X</em>, Open(<em>X</em>)) &#x2192; (<em>Y</em>, Open(<em>Y</em>)) of spaces includes a function <em>X</em> &#x2192; <em>Y</em> . Thus we have a functor <strong>Top</strong> &#x2192; <strong>Set</strong>, because the identity morphisms and compositions of morphisms in <strong>Top</strong> are sent to their counterparts in <strong>Set</strong>.</p>
<p class="nl1-list">b. No. A morphism (<em>X</em>, Open(<em>X</em>)) &#x2192; (<em>Y</em>, Open(<em>Y</em>)) includes a preorder morphism in the direction Open(<em>Y</em>) &#x2192; Open(<em>X</em>), not the other way around. Definition <a href="chapter006.html#Def_6-2-1-1">6.2.1.1</a> shows that every category <epub:switch id="mathmlSwitch682"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> has an opposite category <epub:switch id="mathmlSwitch683"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mi mathvariant='script'>C</mi><mrow><mtext>op</mtext></mrow></msup></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Looking at open sets does give a functor Open: <strong>Top</strong><sup>op</sup> &#x2192; <strong>PrO</strong>.</p>
<a id="p204"></a>
<p class="noindent1-top-exe" id="Exa_5-2-3-3"><em>Example</em> 5.2.3.3 (Continuous dynamical systems). The set &#x211D; can be given a topology in a standard way.<sup><a id="endnote_ref_7" href="chapter005.html#endnote_7">7</a></sup> But (&#x211D;, 0, &#x002B;) is also a monoid. Moreover, for every <em>x</em> &#x2208; &#x211D;, the monoid operation &#x002B; : &#x211D; &#x00D7; &#x211D; &#x2192; &#x211D; is continuous.<sup><a id="endnote_ref_8" href="chapter005.html#endnote_8">8</a></sup> So we say that <epub:switch id="mathmlSwitch684"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">R</mi></mrow><mo>&#x2254;</mo><mo>(</mo><mo>&#x211D;</mo><mo>,</mo><mn>0</mn><mo>,</mo><mo>&#x002B;</mo><mo>)</mo></math></epub:case><epub:default></epub:default></epub:switch> is a <em>topological monoid</em>, or that it is a monoid <em>enriched in topological spaces</em>.</p>
<p>Recall from Section <a href="chapter005.html#lev_5-2-1-1">5.2.1.1</a> that an action of <epub:switch id="mathmlSwitch685"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">R</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a functor <epub:switch id="mathmlSwitch686"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">R</mi></mrow><mo>&#x2192;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch>. Imagine a functor <em>a</em> : <epub:switch id="mathmlSwitch687"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">R</mi></mrow><mo>&#x2192;</mo><mtext mathvariant="bold">Top</mtext></math></epub:case><epub:default></epub:default></epub:switch>. Since <epub:switch id="mathmlSwitch688"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">R</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a category with one object, this amounts to an object <em>X</em> &#x2208; Ob(<strong>Top</strong>), a space. And for every real number <em>t</em> &#x2208; &#x211D;, we obtain a continuous map <em>a</em>(<em>t</em>): <em>X</em> &#x2192; <em>X</em>. Further we can ask this <em>a</em>(<em>t</em>) to vary continuously as <em>t</em> moves around in &#x211D;. If we consider <em>X</em> as the set of states of some system and &#x211D; as the time line, we have modeled what is called a <em>continuous dynamical system</em>.</p>
<p class="noindent1-top-exe" id="Exa_5-2-3-4"><em>Example</em> 5.2.3.4. Recall (see Axler [3]) that a <em>real vector space</em> is a set <em>X</em>, elements of which are called <em>vectors</em>, which is closed under addition and scalar multiplication. For example, &#x211D;<sup>3</sup> is a vector space. A <em>linear transformation f from X to Y</em> is a function <em>f</em> : <em>X</em> &#x2192; <em>Y</em> that appropriately preserves addition and scalar multiplication. The <em>category of real vector spaces</em>, denoted <strong>Vect</strong><sub>&#x211D;</sub>, has as objects the real vector spaces and as morphisms the linear transformations.</p>
<p>There is a functor <strong>Vect</strong><sub>&#x211D;</sub> &#x2192; <strong>Grp</strong> sending a vector space to its underlying group of vectors, where the group operation is addition of vectors and the group identity is the 0-vector.</p>
<p class="noindent1-top-exe" id="Exe_5-2-3-5"><em>Exercise</em> 5.2.3.5.</p>
<p>Every vector space has vector subspaces, ordered by inclusion (the origin is inside of any line that is inside of certain planes, and all are inside of the whole space <em>V</em>). If you know about this topic, answer the following questions.</p>
<p class="nl1-list">a. Does a linear transformation <em>V</em> &#x2192; <em>V</em>&#x2032; induce a morphism of these orders? In other words, is there a functor subspaces: <strong>Vect</strong><sub>&#x211D;</sub> &#x2192; <strong>PrO</strong>?</p>
<p class="nl1-list">b. Would you guess that there is a nice functor <strong>Vect</strong><sub>&#x211D;</sub> &#x2192; <strong>Top</strong>? By &#x201C;nice functor&#x201D; I mean a substantive one. For example, there is a functor <strong>Vect</strong><sub>&#x211D;</sub> &#x2192; <strong>Top</strong> that sends every vector space to the empty topological space; if someone asked for a functor <strong>Vect</strong><sub>&#x211D;</sub> &#x2192; <strong>Top</strong> for their birthday, this functor would make them sad. Give a functor <strong>Vect</strong><sub>&#x211D;</sub> &#x2192; <strong>Top</strong> that would make them happy.</p>
<a id="p205"></a>
<p class="space-break">There is a functor &#x007C; &#x00B7; &#x007C;: <strong>Vect</strong><sub>&#x211D;</sub> &#x2192; <strong>Set</strong> sending every vector space <em>X</em> to its set &#x007C;<em>X</em>&#x007C; of vectors. A categorically nice way to understand this functor is as <epub:switch id="mathmlSwitch689"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><msub><mtext mathvariant='bold'>Vect</mtext><mi>&#x211D;</mi></msub></mrow></msub><mo stretchy='false'>(</mo><mi>&#x211D;</mi><mo>,</mo><mo>&#x2212;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, which sends <em>X</em> to the set of linear transformations &#x211D; &#x2192; <em>X</em>. Each linear transformation &#x211D; &#x2192; <em>X</em> is completely determined by where it sends 1 &#x2208; &#x211D;, which can be any vector in <em>X</em>. Thus we get the bijection <epub:switch id="mathmlSwitch690"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mrow><mo>|</mo> <mi>X</mi> <mo>|</mo></mrow><mo>&#x2245;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><msub><mtext mathvariant='bold'>Vect</mtext><mi>&#x211D;</mi></msub></mrow></msub><mo stretchy='false'>(</mo><mi>&#x211D;</mi><mo>,</mo><mi>X</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="noindent1-top-exe" id="Exe_5-2-3-6"><em>Exercise</em> 5.2.3.6.</p>
<p>Suppose we think of <strong>Vect</strong><sub>&#x211D;</sub> as a database schema, and we think of &#x007C; &#x00B7; &#x007C;: <strong>Vect</strong><sub>&#x211D;</sub> &#x2192; <strong>Set</strong> as an instance (see Section <a href="chapter004.html#lev_4-5">4.5</a>). Of course, the schema and the instance are both infinite, but let&#x2019;s not worry about that.</p>
<p class="nl1-list">a. Pick two objects <em>x</em>, <em>y</em> and two morphisms <em>f</em>, <em>g</em> : <em>x</em> &#x2192; <em>y</em> from <strong>Vect</strong><sub>&#x211D;</sub>, actual vector spaces and linear transformations, and call this your subschema. Draw it as dots and arrows.</p>
<p class="nl1-list">b. Write four rows in each table of the instance &#x007C; &#x00B7; &#x007C; on your subschema.</p>



<section title="Groupoids">
<h3 class="level3" id="lev_5-2-3-7"><strong>5.2.3.7&#160;&#160;&#160;Groupoids</strong></h3>
<p class="noindent">Groupoids are like groups except a groupoid can have more than one object.</p>
<p class="noindent1-top-def" id="Def_5-2-3-8"><strong>Definition 5.2.3.8</strong>. A <em>groupoid</em> is a category <epub:switch id="mathmlSwitch691"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> such that every morphism is an isomorphism. If <epub:switch id="mathmlSwitch692"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch693"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> are groupoids, a <em>morphism of groupoids</em>, denoted <epub:switch id="mathmlSwitch694"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, is simply a functor. The category of groupoids is denoted <strong>Grpd</strong>.</p>
<p class="noindent1-top-exe" id="Exa_5-2-3-9"><em>Example</em> 5.2.3.9. There is a functor <strong>Grpd</strong> &#x2192; <strong>Cat</strong>, sending a groupoid to its underlying category. There is also a functor <strong>Grp</strong> &#x2192; <strong>Grpd</strong> sending a group to itself as a groupoid with one object.</p>
<p>There is also a functor Core: <strong>Cat</strong> &#x2192; <strong>Grpd</strong>, sending a category <epub:switch id="mathmlSwitch695"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> to the largest groupoid inside <epub:switch id="mathmlSwitch696"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, called its <em>core</em>. That is, <epub:switch id="mathmlSwitch697"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mtext>Core</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>=</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch698"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext>Core</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x007B;</mo><mi>f</mi><mo>&#x2208;</mo><msub><mtext>Hom</mtext><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy='false'>)</mo><mo>&#x007C;</mo><mi>f</mi><mo>&#x00A0;</mo><mtext>is an isomorphism</mtext><mo>&#x007D;</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top" id="App_5-2-3-10"><em>Application</em> 5.2.3.10. Let <em>M</em> be a material in some original state <em>s</em><sub>0</sub>.<sup><a id="endnote_ref_9" href="chapter005.html#endnote_9">9</a></sup> Construct a category <epub:switch id="mathmlSwitch699"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><msub><mi mathvariant='script'>S</mi><mi>M</mi></msub></math></epub:case><epub:default></epub:default></epub:switch> whose objects are the states of <em>M</em> (which are obtained by pulling on <em>M</em> in different ways, heating it up, and so on). Include a morphism from state <em>s</em> to state <em>s</em>&#x2032; for every physical transformation from <em>s</em> to <em>s</em>&#x2032;. Physical transformations can be performed one after another, so we can compose morphisms, and perhaps we can agree this composition <a id="p206"></a>is associative. Note that there is a morphism <em>i<sub>s</sub></em> : <em>s</em><sub>0</sub> &#x2192; <em>s</em> representing any physical transformation that can bring <em>M</em> from its initial state <em>s</em><sub>0</sub> to <em>s</em>.</p>
<p>The <span class="underline">elastic deformation region</span> of the material is the set of states <em>s</em> such that there exists an inverse <em>s</em> &#x2192; <em>s</em><sub>0</sub> to the morphism <em>i<sub>s</sub></em>. A transformation is irreversible if its representing morphism has no inverse. If a state <em>s</em><sub>1</sub> is not in the elastic deformation region, we can still talk about the region that is (inventing a term) elastically equivalent to <em>s</em><sub>1</sub>. It is all the objects in <epub:switch id="mathmlSwitch700"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><msub><mi mathvariant='script'>S</mi><mi>M</mi></msub></math></epub:case><epub:default></epub:default></epub:switch> that are isomorphic to <em>s</em><sub>1</sub>. If we consider only elastic equivalences in <epub:switch id="mathmlSwitch701"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><msub><mi mathvariant='script'>S</mi><mi>M</mi></msub></math></epub:case><epub:default></epub:default></epub:switch>, we are looking at a groupoid inside it, namely, the core <epub:switch id="mathmlSwitch702"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mtext>Core</mtext><mo>(</mo><msub><mi mathvariant='script'>S</mi><mi>M</mi></msub><mo>)</mo></math></epub:case><epub:default></epub:default></epub:switch>, as in Example <a href="chapter005.html#Exa_5-2-3-9">5.2.3.9</a>.</p>
<p class="noindent1-top-exe" id="Exa_5-2-3-11"><em>Example</em> 5.2.3.11. Alan Weinstein [45] <span class="underline">explains</span> groupoids in terms of tiling patterns on a bathroom floor. This is worth reading.</p>
<p class="noindent1-top-exe" id="Exa_5-2-3-12"><em>Example</em> 5.2.3.12. Let <em>I</em> &#x003D; {<em>x</em> &#x2208; &#x211D; &#x007C; 0  &#x2A7D; <em>x</em>  &#x2A7D; 1} denote the unit interval. It can be given a topology in a standard way, as a subset of &#x211D; (see Example <a href="chapter005.html#Exa_5-2-3-3">5.2.3.3</a>).</p>
<p>For any topological space <em>X</em>, a <em>path in X</em> is a continuous map <em>I</em> &#x2192; <em>X</em>. Two paths are called <em>homotopic</em> if one can be continuously deformed to the other, where the deformation occurs completely within <em>X</em>.<sup><a id="endnote_ref_10" href="chapter005.html#endnote_10">10</a></sup> One can prove that being homotopic is an equivalence relation on paths.</p>
<p>Paths in <em>X</em> can be composed, one after the other, and the composition is associative (up to homotopy). Moreover, for any point <em>x</em> &#x2208; <em>X</em>, there is a trivial path (that stays at <em>x</em>). Finally every path is invertible (by traversing it backward) up to homotopy.</p>
<p>This all means that to any space <em>X</em> &#x2208; Ob(<strong>Top</strong>) we can associate a groupoid, called the <em>fundamental groupoid of X</em> and denoted &#x03A0;<sub>1</sub>(<em>X</em>) &#x2208; Ob(<strong>Grpd</strong>). The objects of &#x03A0;<sub>1</sub>(<em>X</em>) are the points of <em>X</em>; the morphisms in &#x03A0;<sub>1</sub>(<em>X</em>) are the paths in <em>X</em> (up to homotopy). A continuous map <em>f</em> : <em>X</em> &#x2192; <em>Y</em> can be composed with any path <em>I</em> &#x2192; <em>X</em> to give a path <em>I</em> &#x2192; <em>Y</em>, and this preserves homotopy. So, in fact, &#x03A0;<sub>1</sub> : <strong>Top</strong> &#x2192; <strong>Grpd</strong> is a functor.</p>
<p class="noindent1-top-exe" id="Exe_5-2-3-13"><em>Exercise</em> 5.2.3.13.</p>
<p>Let <em>T</em> denote the surface of a doughnut, i.e., a torus. Choose two points <em>p</em>, <em>q</em> &#x2208; <em>T</em>. Since &#x03A0;<sub>1</sub>(<em>T</em>) is a groupoid, it is also a category. What would the hom-set <epub:switch id="mathmlSwitch703"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><msub><mo>&#x03A0;</mo><mn>1</mn></msub><mo stretchy='false'>(</mo><mi>T</mi><mo stretchy='false'>)</mo></mrow></msub><mo stretchy='false'>(</mo><mi>p</mi><mo>,</mo><mi>q</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> represent?</p>
<a id="p207"></a>
<p class="noindent1-top-exe" id="Exe_5-2-3-14"><em>Exercise</em> 5.2.3.14.</p>
<p>Let <em>U</em> &#x2286; &#x211D;<sup>2</sup> be an open subset of the plane, and let <em>F</em> be an <span class="underline">irrotational vector field</span> on <em>U</em> (i.e., one with curl(<em>F</em>) &#x003D; 0). Following Exercise <a href="chapter005.html#Exe_5-1-1-17">5.1.1.17</a>, we have a category <epub:switch id="mathmlSwitch704"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mi mathvariant='script'>C</mi><mi>F</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>. If two curves <em>C</em>, <em>C</em>&#x2032; in <em>U</em> are homotopic, then they have the same line integral, &#x222B;<sub><em>C</em></sub> <em>F</em> &#x003D; &#x222B;<sub><em>C</em>&#x2032;</sub> <em>F</em>.</p>
<p>We also have a category &#x03A0;<sub>1</sub><em>U</em>, given by the fundamental groupoid, as in Example <a href="chapter005.html#Exa_5-2-3-12">5.2.3.12</a>. Both categories have the same objects, <epub:switch id="mathmlSwitch705"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><msub><mi mathvariant='script'>C</mi><mi>F</mi></msub><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x007C;</mo><mi>U</mi><mo>&#x007C;</mo><mo>=</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><msub><mo>&#x03A0;</mo><mn>1</mn></msub><mi>U</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, the set of points in <em>U</em>.</p>
<p class="nl1-list">a. Is there a functor <epub:switch id="mathmlSwitch706"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mi mathvariant='script'>C</mi><mi>F</mi></msub><mover><mo>&#x2192;</mo><mo>?</mo></mover><msub><mo>&#x03A0;</mo><mn>1</mn></msub><mi>U</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> or a functor <epub:switch id="mathmlSwitch707"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mo>&#x03A0;</mo><mn>1</mn></msub><mi>U</mi><mover><mo>&#x2192;</mo><mo>?</mo></mover><msub><mi mathvariant='script'>C</mi><mi>F</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> that is identity on the underlying objects?</p>

<p class="nl1-list">b. Let <epub:switch id="mathmlSwitch708"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mi mathvariant='script'>C</mi><mi>F</mi><mo>&#x2032;</mo></msubsup><mo>&#x2286;</mo><msub><mi mathvariant='script'>C</mi><mi>F</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> denote the subcategory with the same objects but only those morphisms corresponding to curves <em>C</em> with &#x222B;<em><sub>C</sub></em> <em>F</em> &#x003D; 0. Is <epub:switch id="mathmlSwitch709"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mi mathvariant='script'>C</mi><mi>F</mi><mo>&#x2032;</mo></msubsup></mrow></math></epub:case><epub:default></epub:default></epub:switch> a groupoid?</p>
<p class="nl1-list">c. If <em>F</em> is a conservative vector field, what is <epub:switch id="mathmlSwitch710"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mi mathvariant='script'>C</mi><mi>F</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>?</p>
<p class="nl1-list">d. If <em>F</em> is a conservative vector field, how does <epub:switch id="mathmlSwitch711"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mi mathvariant='script'>C</mi><mi>F</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> compare with &#x03A0;<sub>1</sub><em>U</em>?</p>
<p class="noindent1-top-exe" id="Exe_5-2-3-15"><em>Exercise</em> 5.2.3.15.</p>
<p>Consider the set <em>A</em> of all (well-formed) arithmetic expressions that can be written with the symbols</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch712"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo>&#x007B;</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mn>4</mn><mo>,</mo><mn>5</mn><mo>,</mo><mn>6</mn><mo>,</mo><mn>7</mn><mo>,</mo><mn>8</mn><mo>,</mo><mn>9</mn><mo>,</mo><mo>+</mo><mo>,</mo><mo>&#x2212;</mo><mo>,</mo><mo>*</mo><mo>,</mo><mo stretchy='false'>(</mo><mo>,</mo><mo stretchy='false'>)</mo><mo>&#x007D;</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">For example, here are four different elements of <em>A</em> :</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch713"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtable columnalign='left'><mtr columnalign='left'><mtd columnalign='left'><mrow><mn>52</mn><mo>,</mo></mrow></mtd><mtd columnalign='left'><mrow><mo>&#x00A0;</mo><mn>52</mn><mo>&#x2212;</mo><mn>7</mn><mo>,</mo></mrow></mtd><mtd columnalign='left'><mrow><mo>&#x00A0;</mo><mn>45</mn><mo>+</mo><mn>0</mn><mo>,</mo></mrow></mtd><mtd columnalign='left'><mrow><mo>&#x00A0;</mo><mn>50</mn><mo>+</mo><mn>3</mn><mo>*</mo><mo stretchy='false'>(</mo><mn>6</mn><mo>&#x2212;</mo><mn>2</mn><mo stretchy='false'>)</mo><mo>.</mo></mrow></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>

<p class="noindent">We can say that an equivalence between two arithmetic expressions is a justification that they give the same final answer, e.g., 52 &#x002B; 60 is equivalent to 10 &#x002A; (5 &#x002B; 6) &#x002B; (2 &#x002B; 0), which is equivalent to 10 &#x002A; 11 &#x002B; 2.</p>
<p class="nl1-list">a. I have basically described a category <em>G</em>. What are its objects, and what are its morphisms?</p>
<p class="nl1-list">b. Is <em>G</em> a groupoid?</p>
</section>
</section>
<a id="p208"></a>


<section title="Logic, set theory, and computer science">
<h2 class="level2" id="lev_5-2-4"><strong>5.2.4&#160;&#160;&#160;Logic, set theory, and computer science</strong></h2>


<section title="The category of propositions">
<h3 class="level3" id="lev_5-2-4-1"><strong>5.2.4.1&#160;&#160;&#160;The category of propositions</strong></h3>
<p class="noindent">Given a domain of discourse, a logical proposition is a statement that is evaluated in any model of that domain as either true or not always true, which the black-and-white thinker might dub &#x201C;false.&#x201D; For example, in the domain of real numbers we might have the proposition</p>
<div class="pull-quote">
<p class="pq-noindent">For any real number <em>x</em> &#x2208; &#x211D;, there exists a real number <em>y</em> &#x2208; &#x211D; such that <em>y</em> &#x003E; 3<em>x</em>.</p>
</div>
<p class="noindent">That is true: for <em>x</em> &#x003D; 22, we can offer <em>y</em> &#x003D; 100. But the following proposition is not true:</p>
<div class="pull-quote">
<p class="pq-noindent">Every integer <em>x</em> &#x2208; &#x2124; is divisible by 2 or 3.</p>
</div>

<p class="noindent">It is true for the majority of integers, but not for all integers; thus it is dubbed false.</p>
<p>We say that one logical proposition <em>P implies</em> another proposition <em>Q</em>, denoted <em>P</em> &#x21D2; <em>Q</em>, if for every model in which <em>P</em> is true, so is <em>Q</em>. There is a category <strong>Prop</strong> whose objects are logical propositions and whose morphisms are proofs that one statement implies another. Crudely, one might say that <em>B holds at least as often as A</em> if there is a morphism <em>A</em> &#x2192; <em>B</em> (meaning in any model for which <em>A</em> holds, so does <em>B</em>). So the proposition &#x201C;<em>x</em> &#x2260; <em>x</em>&#x201D; holds very seldom, and the proposition &#x201C;<em>x</em> &#x003D; <em>x</em>&#x201D; holds very often.</p>
<p class="noindent1-top-exe" id="Exa_5-2-4-2"><em>Example</em> 5.2.4.2. We can repeat this idea for nonmathematical statements. Take the set of all possible statements that are verifiable by experiment as the objects of a category. Given two such statements, it may be that one implies the other (e.g., &#x201C;If the speed of light is fixed, then there are relativistic effects&#x201D;). Every statement implies itself (identity) and implication is transitive, so we have a category.</p>
<p>Let&#x2019;s consider differences in proofs to be irrelevant, in which case the category <strong>Prop</strong> is simply a preorder (<strong>Prop</strong>, &#x21D2;): either <em>A</em> implies <em>B</em> or it does not. Then it makes sense to discuss meets and joins. It turns out that meets are &#x201C;and&#x2019;s,&#x201D; and joins are &#x201C;or&#x2019;s.&#x201D; That is, given propositions <em>A</em>, <em>B</em>, the meet <em>A</em> &#x2227; <em>B</em> is defined to be a proposition that holds as often as possible subject to the constraint that it implies both <em>A</em> and <em>B</em>; the proposition &#x201C;<em>A</em> holds and <em>B</em> holds&#x201D; fits the bill. Similarly, the join <em>A</em> &#x2228; <em>B</em> is given by &#x201C;<em>A</em> holds or <em>B</em> holds.&#x201D;</p>
<p class="noindent1-top-exe" id="Exe_5-2-4-3"><em>Exercise</em> 5.2.4.3.</p>
<p>Consider the set of possible laws (most likely an infinite set) that can be dictated to hold throughout a jurisdiction. Consider each law as a proposition (&#x201C;such and such is the case&#x201D;), i.e., as an object of the preorder <strong>Prop</strong>. Given a jurisdiction <em>V</em>, and a set of laws {<em>&#x2113;</em><sub>1</sub>, <em>&#x2113;</em><sub>2</sub>, &#x2026;, <em>&#x2113;<sub>n</sub></em>} that are dictated to hold throughout <em>V</em>, we take their meet <em>L</em>(<em>V</em>) &#x2254; <em>&#x2113;</em><sub>1</sub> &#x2227; <em>&#x2113;</em><sub>2</sub> &#x2227; &#x22EF; &#x2227; <em>&#x2113;<sub>n</sub></em> and consider it to be the single law of the land <em>V</em>. Suppose <a id="p209"></a>that <em>V</em> is a jurisdiction and <em>U</em> is a subjurisdiction (e.g., <em>U</em> is a county and <em>V</em> is a state); write <em>U</em> &#x2286; <em>V</em>. Then any law dictated by the large jurisdiction (the state) must also hold throughout the small jurisdiction (the county). Let <em>J</em> be the set of jurisdictions, so that (<em>J</em>, &#x2286;) is a preorder.</p>
<p class="nl1-list">a. If <em>V</em> &#x2286; <em>U</em> are jurisdictions, what is the relation in <strong>Prop</strong> between <em>L</em>(<em>U</em>) and <em>L</em>(<em>V</em>)?</p>
<p class="nl1-list">b. Consider the preorder (<em>J</em>, &#x2286;) of jurisdictions. Is the law of the land a morphism of preorders <em>J</em> &#x2192; <strong>Prop</strong>? That is, considering both <em>J</em> and <strong>Prop</strong> to be categories (by Proposition <a href="chapter005.html#Pro_5-2-1-13">5.2.1.13</a>), we have a function <em>L</em> : Ob(<em>J</em>) &#x2192; Ob(<strong>Prop</strong>); does <em>L</em> extend to a functor <em>J</em> &#x2192; <strong>Prop</strong>.</p>

<p class="noindent1-top-sol"><em>Solution</em> 5.2.4.3.</p>
<p>This exercise is strangely tricky, so we go through it slowly.</p>
<p class="nl1-list">a. Suppose that the proposition <em>L</em>(<em>V</em>) is true, i.e., we are in a model where all <em>V</em>&#x2019;s laws are being followed. Does this imply that <em>L</em>(<em>U</em>) is true? Since <em>V</em> &#x2286; <em>U</em>, every law of <em>U</em> is a law of <em>V</em> (e.g., if one may not own slaves anywhere in the United States, one may not own slaves in Maine). So indeed <em>L</em>(<em>U</em>) is true; thus we have <em>L</em>(<em>V</em>) &#x21D2; <em>L</em>(<em>U</em>).</p>
<p class="nl1-list">b. Yes, <em>L</em> extends to a preorder morphism <em>L</em> : <em>J</em> &#x2192; <strong>Prop</strong> because if <em>V</em> &#x2286; <em>U</em>, then <em>L</em>(<em>V</em>) &#x21D2; <em>L</em>(<em>U</em>).</p>
<p class="noindent1-top-exe" id="Exe_5-2-4-4"><em>Exercise</em> 5.2.4.4.</p>
<p>Take again the preorder (<em>J</em>, &#x2286;) of jurisdictions from Exercise <a href="chapter005.html#Exe_5-2-4-3">5.2.4.3</a> and the idea that laws are propositions. But this time, let <em>R</em>(<em>V</em>) be the set of all possible laws (not just those dictated to hold) that are, in actuality, being respected, i.e., followed, by all people in <em>V</em>. This assigns to each jurisdiction a set. Does the &#x201C;set of respected laws&#x201D; function <em>R</em> : Ob(<em>J</em>) &#x2192; Ob(<strong>Set</strong>) extend to a functor <em>J</em> &#x2192; <strong>Set</strong>?</p>
<p class="noindent1-top-sol"><em>Solution</em> 5.2.4.4.</p>
<p>If <em>V</em> &#x2286; <em>U</em>, then any law respected throughout <em>U</em> is respected throughout <em>V</em>, i.e., <em>R</em>(<em>U</em>) &#x2286; <em>R</em>(<em>V</em>). In other words, <em>R</em> is <em>contravariant</em> (see Section <a href="chapter006.html#lev_6-2-1">6.2.1</a>), meaning it constitutes a functor <em>R</em> : <em>J</em><sup>op</sup> &#x2192; <strong>Set</strong>. (Every law is being respected throughout the jurisdiction &#x2205;, and physicists want to know what laws are being respected throughout the universe-as-jurisdiction.)</p>
</section>
<a id="p210"></a>


<section title="A categorical characterization of Set">
<h3 class="level3" id="lev_5-2-4-5"><strong>5.2.4.5&#160;&#160;&#160;A categorical characterization of Set</strong></h3>
<p class="noindent">The category <strong>Set</strong> of sets is fundamental in mathematics, but instead of thinking of it as something given or somehow special, it can be shown to merely be a category with certain properties, each of which can be phrased purely categorically. This was shown by Lawvere [23]. A very readable account is given in [26].</p>
</section>


<section title="Categories in computer science">
<h3 class="level3" id="lev_5-2-4-6"><strong>5.2.4.6&#160;&#160;&#160;Categories in computer science</strong></h3>
<p class="noindent">Computer science makes heavy use of trees, graphs, orders, lists, and monoids. All of these can be understood in the context of category theory, although it seems the categorical interpretation is rarely mentioned explicitly in computer science textbooks. However, categories are used explicitly in the theory of programming languages (PL). Researchers in that field attempt to understand the connection between what programs are supposed to do (their denotation) and what they actually cause to occur (their operation). Category theory provides a useful mathematical formalism in which to study this.</p>
<p>The kind of category most often considered by a PL researcher is known as a <em>Cartesian closed category</em>, or CCC, which means a category <epub:switch id="mathmlSwitch714"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>T</mi></math></epub:case><epub:default></epub:default></epub:switch> that has products (like <em>A</em> &#x00D7; <em>B</em> in <strong>Set</strong>) and exponential objects (like <em>B<sup>A</sup></em> in <strong>Set</strong>). So <strong>Set</strong> is an example of a CCC, but there are others that are more appropriate for actual computation. The objects in a PL person&#x2019;s CCC represent the <em>types</em> of the programming language, types such as <span class="font1">integers, strings, floats</span>. The morphisms represent computable functions, e.g., <span class="font1">length: strings&#x2192;integers</span>. The products allow one to discuss pairs (<em>a</em>, <em>b</em>), where <em>a</em> is of one type and <em>b</em> is of another type. Exponential objects allow one to consider computable functions as things that can be input to a function (e.g., given any computable function <span class="font1">floats&#x2192;integers</span>, one can consistently multiply its results by 2 and get a new computable function <span class="font1">floats&#x2192;integers</span>). Products are studied in Section <a href="chapter006.html#Def_6-1-1-8">6.1.1.8</a> and exponential objects in Section <a href="chapter005.html#lev_5-3-2">5.3.2</a>.</p>
<p>But category theory does not only offer a language for thinking about programs, it offers an unexpected tool called monads. The CCC model for types allows researchers only to discuss functions, leading to the notion of functional programming languages; however, not all things that a computer does are functions. For example, reading input and output, changing internal state, and so on, are operations that can be performed on a computer but that ruin the functional aspect of programs. Monads were found in 1991 by Moggi [33] to provide a powerful abstraction that opens the doors to such nonfunction operations without forcing the developer to leave the category-theoretic paradise. Monads are discussed in Section <a href="chapter007.html#lev_7-3">7.3</a>.</p>
<p>Section <a href="chapter005.html#lev_5-2-2">5.2.2</a> showed that databases are well captured by the language of categories (this is formalized in Section <a href="chapter005.html#lev_5-4">5.4</a>). Databases are used in this book to bring clarity to concepts within standard category theory.</p>
</section>
</section>
<a id="p211"></a>

<section title="Categories applied in science">
<h2 class="level2" id="lev_5-2-5"><strong>5.2.5&#160;&#160;&#160;Categories applied in science</strong></h2>
<p class="noindent">Categories are used throughout mathematics to relate various subjects as well as to draw out the essential structures within these subjects. For example, there is active research in categorifying classical theories like that of knots, links, and braids (Khovanov [21]). It is similarly applied in science to clarify complex subjects. Here are some very brief descriptions of scientific disciplines to which category theory is applied.</p>
<p>Quantum field theory was categorified by Atiyah [2] in the late 1980s, with much success (at least in producing interesting mathematics). In this domain, one takes a category in which an object is a reasonable space, called a manifold, and a morphism is a manifold connecting two manifolds, like a cylinder connecting two circles. Such connecting manifolds are called cobordisms and the category of manifolds and cobordisms is denoted <strong>Cob</strong>. Topological quantum field theory is the study of functors <strong>Cob</strong> &#x2192; <strong>Vect</strong> that assign a vector space to each manifold and a linear transformation of vector spaces to each cobordism.</p>
<p>Samson Abramsky [1] showed a relationship between database theory, category theory, and quantum physics. He used the notion of sheaves on a database (see Section <a href="chapter007.html#lev_7-2-3">7.2.3</a>) and the sheaf cohomology thereof, to derive <span class="underline">Bell&#x2019;s theorem</span>, which roughly states that certain variables that can be observed locally do not extend to globally observable variables.</p>
<p>Information theory, invented in 1948 by Claude Shannon, is the study of how to ideally compress messages so that they can be sent quickly and accurately across a noisy channel.<sup><a id="endnote_ref_11" href="chapter005.html#endnote_11">11</a></sup> Its main quantity of interest is the number of bits necessary to encode a piece of information. For example, the amount of information in an English sentence can be greatly reduced. The fact that <em>t</em>&#x2019;s are often followed by <em>h</em>&#x2019;s, or that <em>e</em>&#x2019;s are much more common than <em>z</em>&#x2019;s, implies that letters are not being used as efficiently as possible. The amount of bits necessary to encode a message is called its <em>entropy</em> and has been linked to the commonly used notion of the same name in physics.</p>
<p>Baez, Fritz, and Leinster [7] show that entropy can be captured quite cleanly using category theory. They make a category <span class="font1">FinProb</span> whose objects are finite sets equipped <a id="p212"></a>with a probability measure, and whose morphisms are probability-preserving functions. They characterize <em>information loss</em> as a way to assign numbers to such morphisms, subject to certain explicit constraints. They then show that the entropy of an object in <span class="font1">FinProb</span> is the amount of information lost under the unique map to the singleton set {&#x263A;}. This approach explicates (by way of the explicit constraints for information loss functions) the essential idea of Shannon&#x2019;s information theory, allowing it to be generalized to categories other than <span class="font1">FinProb</span>. Thus Baez and colleagues effectively <em>categorified</em> information theory.</p>
<p>Robert Rosen proposed in the 1970s that category theory could play a major role in biology. That is only now starting to be fleshed out. There is a categorical account of evolution and memory, called <em>Memory Evolutive Systems</em> [15]. There is also a paper [10] by Brown and Porter with applications to neuroscience.</p>
</section>
</section>

<section title="Natural transformations">
<h1 class="level1" id="lev_5-3"><a href="toc.html#Rlev_5-3"><strong>5.3&#160;&#160;&#160;Natural transformations</strong></a></h1>
<p class="noindent">The Big 3 of category theory are categories, functors, and natural transformations. This section introduces the last of these, natural transformations. Category theory was originally invented to discuss natural transformations. These were sufficiently conceptually challenging that they required formalization and thus the invention of category theory. If we think of categories as domains (e.g., of discourse, interaction, comparability) and functors as translations between different domains, the natural transformations compare different translations.</p>
<p>Natural transformations can seem a bit abstruse at first, but hopefully some examples and exercises may help.</p>


<section title="Definition and examples">
<h2 class="level2" id="lev_5-3-1"><strong>5.3.1&#160;&#160;&#160;Definition and examples</strong></h2>
<p class="noindent">Let&#x2019;s begin with an example. There is a functor List: <strong>Set</strong> &#x2192; <strong>Set</strong>, which sends a set <em>X</em> to the set List(<em>X</em>) consisting of all lists whose entries are elements of <em>X</em>. Given a morphism <em>f</em> : <em>X</em> &#x2192; <em>Y</em>, we can transform a list with entries in <em>X</em> into a list with entries in <em>Y</em> by applying <em>f</em> to each entry (see Exercise <a href="chapter005.html#Exe_5-1-2-22">5.1.2.22</a>). Call this process translating the list.</p>
<p>It may seem a strange thing to contemplate, but there is also a functor List&#x25CB;List: <strong>Set</strong> &#x2192; <strong>Set</strong> that sends a set <em>X</em> to the set of lists of lists in <em>X</em>. If <em>X</em> &#x003D; {<em>a</em>, <em>b</em>, <em>c</em>}, then List &#x25CB; List(<em>X</em>) contains elements like [[<em>a</em>, <em>b</em>], [<em>a</em>, <em>c</em>, <em>a</em>, <em>b</em>, <em>c</em>], [<em>c</em>]] and [[ ]] and [[<em>a</em>], [ ], [<em>a</em>, <em>a</em>, <em>a</em>]]. We can <em>naturally transform</em> a list of lists into a list by concatenation. In other words, for any set <em>X</em> there is a function <em>&#x00B5;<sub>X</sub></em> : List &#x25CB; List(<em>X</em>) &#x2192; List(<em>X</em>), which sends that list of lists to [<em>a</em>, <em>b</em>, <em>a</em>, <em>c</em>, <em>a</em>, <em>b</em>, <em>c</em>, <em>c</em>] and [ ] and [<em>a</em>, <em>a</em>, <em>a</em>, <em>a</em>] respectively. In fact, even if we use a function <em>f</em> : <em>X</em> &#x2192; <em>Y</em> to translate a list of <em>X</em>&#x2019;s into a list of <em>Y</em>&#x2019;s (or a list of lists of <em>X</em>&#x2019;s into a list of lists of <em>Y</em>&#x2019;s), the concatenation works correctly.</p>
<a id="p213"></a>
<p class="noindent1-top-slo"><em>Slogan</em> 5.3.1.1.</p>
<div class="pull-quote">
<p class="pq-noindent"><em>What does it mean to say that concatenation of lists is natural with respect to translation? It means that concatenating then translating is the same thing as translating then concatenating</em>.</p>
</div>
<p>Let&#x2019;s make this concrete. Let <em>X</em> &#x003D; {<em>a</em>, <em>b</em>, <em>c</em>}, let <em>Y</em> &#x003D; {1, 2, 3}, and let <em>f</em> : <em>X</em> &#x2192; <em>Y</em> assign <em>f</em>(<em>a</em>) &#x003D; 1, <em>f</em>(<em>b</em>) &#x003D; 1, <em>f</em>(<em>c</em>) &#x003D; 2. The naturality condition says the following for any list of lists of <em>X</em>&#x2019;s, in particular, for [[<em>a</em>, <em>b</em>], [<em>a</em>, <em>c</em>, <em>a</em>, <em>b</em>, <em>c</em>], [<em>c</em>]] &#x2208; List &#x25CB; List(<em>X</em>):</p>
<p class="fig-img"><img src="images/Art_P174.jpg" alt="art"/></p>
<p class="noindent">The top right path is concatenating then translating, and the left bottom path is translating then concatenating, and one sees here that they do the same thing.</p>
<p>Here is how the preceding example fits with the terminology of Definition <a href="chapter005.html#Def_5-3-1-2">5.3.1.2</a>. The categories <epub:switch id="mathmlSwitch715"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch716"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> are both <strong>Set</strong>, the functor <epub:switch id="mathmlSwitch717"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is List &#x25CB; List, and the functor <epub:switch id="mathmlSwitch718"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>G</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is List. The natural transformation is <em>&#x00B5;</em> : List&#x25CB;List &#x2192; List. It can be depicted:</p>
<p class="fig-img"><img src="images/Art_P175.jpg" alt="art"/></p>
<p class="noindent1-top-def" id="Def_5-3-1-2"><strong>Definition 5.3.1.2</strong>. Let <epub:switch id="mathmlSwitch719"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch720"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> be categories, and let <epub:switch id="mathmlSwitch721"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch722"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>G</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> be functors. A <em>natural transformation &#x03B1; from F to G</em>, denoted <em>&#x03B1;</em> : <em>F</em> &#x2192; <em>G</em> and depicted</p>
<p class="fig-img"><img src="images/Art_P176.jpg" alt="art"/></p>
<p class="noindent">is defined as follows. One announces some constituents (A. components) and shows that they conform to a law (1. naturality squares). Specifically, one announces</p>
<p class="nl3-list">A. for each object <epub:switch id="mathmlSwitch723"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, a morphism <em>&#x03B1;<sub>X</sub></em> : <em>F</em> (<em>X</em>) &#x2192; <em>G</em>(<em>X</em>) in <epub:switch id="mathmlSwitch724"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch>, called <em>the X-component of &#x03B1;</em>.</p>
<a id="p214"></a>
<p class="noindent">One must then show that the following <em>natural transformation law</em> holds:</p>
<ol class="olindent">
<li>For every morphism <em>f</em> : <em>X</em> &#x2192; <em>Y</em> in <epub:switch id="mathmlSwitch725"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, the square (<a href="chapter005.html#eq_5-10">5.10</a>), called the <em>naturality square for f</em>, must commute:
<p class="fig-img" id="eq_5-10"><img src="images/Art_P177.jpg" alt="art"/></p></li>
</ol>

<p class="noindent">The set of natural transformations <em>F</em> &#x2192; <em>G</em> is denoted Nat(<em>F</em>, <em>G</em>).</p>
<p class="noindent1-top-rem" id="Rem_5-3-1-3"><em>Remark</em> 5.3.1.3. If we have two functors <epub:switch id="mathmlSwitch726"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>,</mo> <mi>G</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, providing a morphism <em>&#x03B1;<sub>X</sub></em> : <em>F</em>(<em>X</em>) &#x2192; <em>G</em>(<em>X</em>) for every object <epub:switch id="mathmlSwitch727"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is called a <em>questionably natural transformation</em>. Once we check the commutativity of all the naturality squares, i.e., once we know it satisfies Definition <a href="chapter005.html#Def_5-3-1-2">5.3.1.2</a>, we drop the &#x201C;questionably&#x201D; part.</p>
<p class="noindent1-top-exe" id="Exa_5-3-1-4"><em>Example</em> 5.3.1.4. Consider the following categories <epub:switch id="mathmlSwitch728"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>C</mi><mo>&#x2245;</mo><mo stretchy='false'>[</mo><mn>1</mn><mo stretchy='false'>]</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch729"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>D</mi><mo>&#x2245;</mo><mo stretchy='false'>[</mo><mn>2</mn><mo stretchy='false'>]</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>:</p>
<p class="fig-img"><img src="images/Art_P178.jpg" alt="art"/></p>
<p class="noindent">Consider the functors <em>F</em>, <em>G</em> : [1] &#x2192; [2], where <em>F</em>(0) &#x003D; <em>A</em>, <em>F</em>(1) &#x003D; <em>B</em>, <em>G</em>(0) &#x003D; <em>A</em>, and <em>G</em>(1) &#x003D; <em>C</em>. It turns out that there is only one possible natural transformation <em>F</em> &#x2192; <em>G</em>; we call it <em>&#x03B1;</em> and explore its naturality square. The components of <em>&#x03B1;</em> : <em>F</em> &#x2192; <em>G</em> are shown in green. These components are <em>&#x03B1;</em><sub>0</sub> &#x003D; id<em><sub>A</sub></em> : <em>F</em>(0) &#x2192; <em>G</em>(0) and <em>&#x03B1;</em><sub>1</sub> &#x003D; <em>g</em> : <em>F</em>(1) &#x2192; <em>G</em>(1). The naturality square for <em>p</em> : 0 &#x2192; 1 is shown twice below, once with notation following that in (<a href="chapter005.html#eq_5-10">5.10</a>) and once in local notation:</p>
<p class="fig-img"><img src="images/Art_P179.jpg" alt="art"/></p>
<p class="noindent">It is clear that this diagram commutes, so the components <em>&#x03B1;</em><sub>0</sub> and <em>&#x03B1;</em><sub>1</sub> satisfy the law of Definition <a href="chapter005.html#Def_5-3-1-2">5.3.1.2</a>, making <em>&#x03B1;</em> a natural transformation.</p>
<p class="noindent1-top-pro" id="Pro_5-3-1-5"><strong>Proposition 5.3.1.5</strong>. <em>Let</em> <epub:switch id="mathmlSwitch730"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> <em>and</em> <epub:switch id="mathmlSwitch731"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> <em>be categories, let</em> <epub:switch id="mathmlSwitch732"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>,</mo><mi>G</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>be functors, and for every object</em> <epub:switch id="mathmlSwitch733"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <em>let</em> <epub:switch id="mathmlSwitch734"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mi>&#x03B1;</mi><mi>c</mi></msub><mo>:</mo><mi>F</mi><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mi>G</mi><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>be a morphism in</em> <epub:switch id="mathmlSwitch735"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch>. <em>Suppose given a path</em> <a id="p215"></a><epub:switch id="mathmlSwitch736"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mi>c</mi><mn>0</mn></msub><mover><mo>&#x2192;</mo><mrow><mo>&#x00A0;</mo><msub><mi>f</mi><mn>1</mn></msub><mo>&#x00A0;</mo></mrow></mover><msub><mi>c</mi><mn>1</mn></msub><mover><mo>&#x2192;</mo><mrow><mo>&#x00A0;</mo><msub><mi>f</mi><mn>2</mn></msub><mo>&#x00A0;</mo></mrow></mover><mo>&#x22EF;</mo><mover><mo>&#x2192;</mo><mrow><mo>&#x00A0;</mo><msub><mi>f</mi><mi>n</mi></msub><mo>&#x00A0;</mo></mrow></mover><msub><mi>c</mi><mi>n</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>such that for each arrow f<sub>i</sub> in it, the following naturality square commutes:</em></p>
<p class="fig-img"><img src="images/Art_P180.jpg" alt="art"/></p>

<p class="noindent"><em>Then the naturality square for the composite p</em> &#x2254; <em>f<sub>n</sub></em> &#x25CB; &#x22EF; &#x25CB; <em>f</em><sub>2</sub> &#x25CB; <em>f</em><sub>1</sub> : <em>c</em><sub>0</sub> &#x2192; <em>c<sub>n</sub></em></p>
<p class="fig-img"><img src="images/Art_P181.jpg" alt="art"/></p>
<p class="noindent"><em>also commutes. In particular, the naturality square commutes for every identity morphism</em> id<em><sub>c</sub></em>.</p>
<p class="noindent1-top"><em>Proof</em>. When <em>n</em> &#x003D; 0, we have a path of length 0 starting at each <epub:switch id="mathmlSwitch737"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. It vacuously satisfies the condition, so we need to see that its naturality square</p>
<p class="fig-img"><img src="images/Art_P182.jpg" alt="art"/></p>
<p class="noindent">commutes. But this is clear because functors preserve identities.</p>
<p>The rest of the proof follows by induction on <em>n</em>. Suppose <em>q</em> &#x003D; <em>f</em><sub><em>n</em>&#x2212;1</sub> &#x25CB; &#x22EF; &#x25CB; <em>f</em><sub>2</sub> &#x25CB; <em>f</em><sub>1</sub> : <em>c</em><sub>0</sub> &#x2192; <em>c</em><sub><em>n</em>&#x2212;1</sub> and <em>p</em> &#x003D; <em>f<sub>n</sub></em> &#x25CB; <em>q</em> and that the naturality squares for <em>q</em> and for <em>f<sub>n</sub></em> commute; we need only show that the naturality square for <em>p</em> commutes. That is, we assume the two small squares commute; it follows that the large rectangle does too, completing the proof.</p>
<p class="fig-img"><img src="images/Art_P183.jpg" alt="art"/></p>
<a id="p216"></a>
<p class="noindent1-top-exe" id="Exa_5-3-1-6"><em>Example</em> 5.3.1.6. Let <epub:switch id="mathmlSwitch738"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>C</mi><mo>=</mo><mi mathvariant='script'>D</mi><mo>=</mo><mo stretchy='false'>[</mo><mn>1</mn><mo stretchy='false'>]</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be the linear order of length 1, thought of as a category (by Proposition <a href="chapter005.html#Pro_5-2-1-13">5.2.1.13</a>). There are three functors <epub:switch id="mathmlSwitch739"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, which we can write as (0, 0), (0, 1), and (1, 1); these are depicted left to right as follows:</p>
<p class="fig-img"><img src="images/Art_P184.jpg" alt="art"/></p>
<p class="noindent">These are just functors so far. What are the natural transformations say, <em>&#x03B1;</em> : (0, 0) &#x2192; (0, 1)? To specify a natural transformation, we must specify a component for each object in <epub:switch id="mathmlSwitch740"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>. In this case <em>&#x03B1;</em><sub>0</sub> : 0 &#x2192; 0 and <em>&#x03B1;</em><sub>1</sub> : 0 &#x2192; 1. There is only one possible choice: <em>&#x03B1;</em><sub>0</sub> &#x003D; id<sub>0</sub> and <em>&#x03B1;</em><sub>1</sub> &#x003D; <em>f</em>. Now that we have chosen components, we need to check the naturality squares.</p>
<p>There are three morphisms in <epub:switch id="mathmlSwitch741"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, namely, id<sub>0</sub>, <em>f</em>, id<sub>1</sub>. By Proposition <a href="chapter005.html#Pro_5-3-1-5">5.3.1.5</a>, we need only check the naturality square for <em>f</em>. We write it twice, once in abstract notation and once in concrete notation:</p>
<p class="fig-img"><img src="images/Art_P185.jpg" alt="art"/></p>
<p class="noindent">This commutes, so <em>&#x03B1;</em> is indeed a natural transformation.</p>
<p class="noindent1-top-exe" id="Exe_5-3-1-7"><em>Exercise</em> 5.3.1.7.</p>
<p>With notation as in Example <a href="chapter005.html#Exa_5-3-1-6">5.3.1.6</a>, we have three functors <epub:switch id="mathmlSwitch742"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, namely, (0, 0), (0, 1), and (1, 1). How many natural transformations are there from <em>F</em> to <em>G</em>, i.e., what is the cardinality of Nat(<em>F</em>, <em>G</em>)</p>
<p class="nl1-list">a. when <em>F</em> &#x003D; (0, 0) and <em>G</em> &#x003D; (1, 1)?</p>
<p class="nl1-list">b. when <em>F</em> &#x003D; (0, 0) and <em>G</em> &#x003D; (0, 0)?</p>
<p class="nl1-list">c. when <em>F</em> &#x003D; (0, 1) and <em>G</em> &#x003D; (0, 0)?</p>
<p class="nl1-list">d. when <em>F</em> &#x003D; (0, 1) and <em>G</em> &#x003D; (1, 1)?</p>

<a id="p217"></a>
<p class="noindent1-top-exe" id="Exe_5-3-1-8"><em>Exercise</em> 5.3.1.8.</p>
<p>Let <span class="underline">1</span> denote the discrete category on one object, Ob(<span class="underline">1</span>) &#x003D; {1}, and let <epub:switch id="mathmlSwitch743"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> denote the category with one object <epub:switch id="mathmlSwitch744"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>Ob</mtext><mrow><mo>(</mo><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext><mo>)</mo><mo>&#x003D;</mo><mo>{</mo><mi>s</mi><mo>}</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch745"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></msub><mrow><mo>(</mo><mrow><mi>s</mi><mo>,</mo><mi>s</mi></mrow><mo>)</mo></mrow><mo>=</mo><mtext>&#x2115;</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> (see Example <a href="chapter005.html#Exa_5-2-2-2">5.2.2.2</a>). There is exactly one functor <epub:switch id="mathmlSwitch746"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>S</mi><mo>:</mo><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder><mo>&#x2192;</mo><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Characterize the natural transformations <em>&#x03B1;</em> : <em>S</em> &#x2192; <em>S</em>.</p>
<p class="noindent1-top-exe" id="Exe_5-3-1-9"><em>Exercise</em> 5.3.1.9.</p>
<p>Let [1] denote the free arrow category,</p>
<p class="fig-img"><img src="images/Art_P186.jpg" alt="art"/></p>
<p class="noindent">as in Exercise <a href="chapter005.html#Exe_5-1-2-34">5.1.2.34</a>, and let <epub:switch id="mathmlSwitch747"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> be as in Example <a href="chapter005.html#Exa_5-2-2-2">5.2.2.2</a>.</p>
<p class="nl1-list">a. What are all the functors [1] &#x2192; <epub:switch id="mathmlSwitch748"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>?</p>
<p class="nl1-list">b. For any two functors <em>F</em>, <em>G</em> : [1] &#x2192; <epub:switch id="mathmlSwitch749"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, characterize the set Nat(<em>F</em>, <em>G</em>) of natural transformations <em>F</em> &#x2192; <em>G</em>.</p>

<p class="noindent1-top-exe" id="Exe_5-3-1-10"><em>Exercise</em> 5.3.1.10.</p>
<p>Consider the functor List: <strong>Set</strong> &#x2192; <strong>Set</strong> sending a set <em>X</em> to the set List(<em>X</em>) of lists with entries in <em>X</em>. There is a natural transformation List&#x25CB;List &#x2192; List given by concatenation.</p>
<p class="nl1-list">a. If someone said, &#x201C;Singleton lists give a natural transformation <em>&#x03C3;</em> from id<strong><sub>Set</sub></strong> to List,&#x201D; what might she mean? That is, for a set <em>X</em>, what component <em>&#x03C3;<sub>X</sub></em> might she be suggesting?</p>
<p class="nl1-list">b. Do these components satisfy the necessary naturality squares for functions <em>f</em> : <em>X</em> &#x2192; <em>Y</em>? In other words, given your interpretation of what the person is saying, is she correct?</p>

<p class="noindent1-top-exe" id="Exe_5-3-1-11"><em>Exercise</em> 5.3.1.11.</p>
<p>Let <epub:switch id="mathmlSwitch750"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch751"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> be categories, and suppose that <epub:switch id="mathmlSwitch752"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>d</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a terminal object. Consider the constant functor <epub:switch id="mathmlSwitch753"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mo>&#x007B;</mo><mi>d</mi><mo>&#x007D;</mo></mrow><mi mathvariant='script'>C</mi></msup><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, which sends each object <epub:switch id="mathmlSwitch754"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> to <em>d</em> and each morphism in <epub:switch id="mathmlSwitch755"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> to the identity morphism id<em><sub>d</sub></em> on <em>d</em>.</p>
<p class="nl1-list">a. For any other functor <epub:switch id="mathmlSwitch756"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, how many natural transformations are there <epub:switch id="mathmlSwitch757"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mtext>&#x200B;</mtext><mo>&#x2192;</mo><msup><mrow><mo>&#x007B;</mo><mi>d</mi><mo>&#x007D;</mo></mrow><mi mathvariant='script'>C</mi></msup></mrow></math></epub:case><epub:default></epub:default></epub:switch>?</p>
<a id="p218"></a>
<p class="nl1-list">b. Let <epub:switch id="mathmlSwitch758"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>D</mi><mo>=</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and let <em>d</em> &#x003D; {&#x263A;}, which is a terminal object in <strong>Set</strong> (see Exercise <a href="chapter003.html#Exe_3-2-3-5">3.2.3.5</a> or Warning <a href="chapter006.html#war_6-1-3-14">6.1.3.14</a>). If <epub:switch id="mathmlSwitch759"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>C</mi><mo>=</mo><mo stretchy='false'>[</mo><mn>1</mn><mo stretchy='false'>]</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is the linear order of length 1, and <epub:switch id="mathmlSwitch760"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> is any functor, what does it mean to give a natural transformation <epub:switch id="mathmlSwitch761"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mo>&#x007B;</mo><mi>d</mi><mo>&#x007D;</mo></mrow><mi mathvariant='script'>C</mi></msup><mo>&#x2192;</mo><mi>F</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>?</p>

<p class="noindent1-top" id="App_5-3-1-12"><em>Application</em> 5.3.1.12. <a href="chapter004.html#Fig_4-2">Figure 4.2</a> showed a <span class="underline">finite state machine</span> on alphabet &#x03A3; &#x003D; {<em>a</em>, <em>b</em>}, and Example <a href="chapter004.html#Exa_4-1-3-1">4.1.3.1</a> shows its associated action table. Imagine this was your model for understanding the behavior of some system when acted on by commands <em>a</em> and <em>b</em>. Suppose a colleague tells you he has a more refined model that fits with the same data. His model has six states rather than three, but it is compatible. What might that mean?</p>
<p>Both the original state machine, <em>X</em>, the proposed model, <em>Y</em>, and their associated action tables are shown in <a href="chapter005.html#Fig_5-1">Figure 5.1</a> (see page 247).</p>
<p>How are these models compatible? In the table for <em>Y</em>, if one removes the distinction between states 1A, 1B, 1C and between states 2A and 2B, then one returns with the table for <em>X</em>. The table for <em>Y</em> is more specific, but it is fully compatible with the table for <em>X</em>. The sense in which it is compatible is precisely the sense defined by there being a natural transformation.</p>
<p>Recall that <epub:switch id="mathmlSwitch762"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant="script">M</mi><mo>=</mo><mrow><mo>(</mo><mrow><mtext>List</mtext><mrow><mo>(</mo><mo>&#x2211;</mo><mo>)</mo></mrow><mo>,</mo><mrow><mo>[</mo><mrow></mrow><mo>]</mo></mrow><mo>,</mo><mo>+</mo><mo>+</mo></mrow><mo>)</mo></mrow></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a monoid, and that a monoid is simply a category with one object, say, <epub:switch id="mathmlSwitch763"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Ob</mtext><mrow><mo>(</mo><mi mathvariant="script">M</mi><mo>)</mo></mrow><mo>=</mo><mrow><mo>{</mo><mi>&#x25B2;</mi><mo>}</mo></mrow></mrow></math></epub:case><epub:default></epub:default></epub:switch> (see Section <a href="chapter005.html#lev_5-2-1">5.2.1</a>). With &#x03A3; &#x003D; {<em>a</em>, <em>b</em>}, the monoid <epub:switch id="mathmlSwitch764"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> can be visualized as follows:</p>
<p class="fig-img"><img src="images/Art_P187.jpg" alt="art"/></p>
<p class="noindent">Recall also that a state machine on <epub:switch id="mathmlSwitch765"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is simply a functor <epub:switch id="mathmlSwitch766"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow><mo>&#x2192;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch>. We thus have two such functors, <em>X</em> and <em>Y</em>. A natural transformation <em>&#x03B1;</em> : <em>Y</em> &#x2192; <em>X</em> would consist of a component <em>&#x03B1;<sub>m</sub></em> for every object <epub:switch id="mathmlSwitch767"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>m</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mrow><mo>(</mo><mi mathvariant="script">M</mi></mrow><mo>)</mo></math></epub:case><epub:default></epub:default></epub:switch> such that certain diagrams commute. But <epub:switch id="mathmlSwitch768"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> having only one object, we need only one function <em>&#x03B1;</em><sub>&#x25B2;</sub> : <em>Y</em>(&#x25B2;) &#x2192; <em>X</em>(&#x25B2;), where <em>Y</em>(&#x25B2;) is the set of (6) states of <em>Y</em> and <em>X</em>(&#x25B2;) is the set of (3) states of <em>X</em>.</p>

<p>The states of <em>Y</em> have been named so as to make the function <em>&#x03B1;</em><sub>&#x25B2;</sub> particularly easy to guess.<sup><a id="endnote_ref_12" href="chapter005.html#endnote_12">12</a></sup> We need to check that two squares commute:</p>
<p class="fig-img" id="eq_5-11"><img src="images/Art_P188.jpg" alt="art"/></p>
<p class="noindent">This can only be checked by going through and making sure that certain things match, as specified by (<a href="chapter005.html#eq_5-11">5.11</a>); this is spelled out in detail. The columns that should match are <a id="p219"></a>those whose entries are written in blue. These correspond to the left bottom composites being matched with the top right composites in the naturality squares of (<a href="chapter005.html#eq_5-11">5.11</a>).</p>
<p class="fig-img" id="eq_5-12"><img src="images/Art_P189.jpg" alt="art"/></p>
<p class="fig-img" id="eq_5-13"><img src="images/Art_P190.jpg" alt="art"/></p>
<p>To recap, scientists may often have the idea that two models <em>Y</em> and <em>X</em> are compatible, and such notions of compatibility may be broadly agreed upon. However, these notions can at the same time be challenging to explain to an outsider, e.g., a regulatory body or auditor, especially in more complex situations. On the other hand, it is unambiguous to simply claim &#x201C;there is a natural transformation from <em>Y</em> to <em>X</em>.&#x201D; If, in a given domain, the notion of natural transformation captures the essence of compatible models, it may bring clarity.</p>
<p class="noindent1-top-exe" id="Exe_5-3-1-13"><em>Exercise</em> 5.3.1.13.</p>
<p>Let <epub:switch id="mathmlSwitch769"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> be a functor. Suppose someone said, &#x201C;The identity on <em>F</em> is a natural transformation from <em>F</em> to itself.&#x201D;</p>
<p class="nl1-list">a. What might he mean?</p>
<p class="nl1-list">b. What components is he suggesting?</p>
<p class="nl1-list">c. Are the components natural?</p>
<a id="p220"></a>
<p class="noindent1-top-sol"><em>Solution</em> 5.3.1.13.</p>
<p class="nl1-list">a. He is certainly telling us about a natural transformation <em>&#x03B1;</em> : <em>F</em> &#x2192; <em>F</em>, and he seems to be telling us that it will somehow act like an identity.</p>
<p class="nl1-list">b. To give a questionably natural transformation, we need to provide, for every <epub:switch id="mathmlSwitch770"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> a morphism <em>&#x03B1;<sub>c</sub></em> : <em>F</em>(<em>c</em>) &#x2192; <em>F</em>(<em>c</em>) in <epub:switch id="mathmlSwitch771"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch>. Since we have in mind the word <em>identity</em>, we could take <em>&#x03B1;<sub>c</sub></em> &#x2254; id<sub><em>F</em>(<em>c</em>)</sub> for all <em>c</em>. This is probably what the person means.</p>
<p class="nl1-list">c. For <em>&#x03B1;</em> to be natural we need to check that the following square commutes for any <em>f</em> : <em>c</em> &#x2192; <em>c</em>&#x2032; in <epub:switch id="mathmlSwitch772"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>:</p>
<p class="fig-img"><img src="images/Art_P191.jpg" alt="art"/></p>
<p class="nl1-list-para">It clearly does commute, so <em>&#x03B1;</em> is natural. This natural transformation <em>&#x03B1;</em> is usually denoted id<em><sub>F</sub></em> : <em>F</em> &#x2192; <em>F</em>.</p>
<p class="noindent1-top-exe" id="Exa_5-3-1-14"><em>Example</em> 5.3.1.14. Let [1] &#x2208; Ob(<strong>Cat</strong>) be the free arrow category described in Exercise <a href="chapter005.html#Exe_5-1-2-34">5.1.2.34</a>, and let <epub:switch id="mathmlSwitch773"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> be any category. To specify a functor <epub:switch id="mathmlSwitch774"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mo stretchy='false'>[</mo><mn>1</mn><mo stretchy='false'>]</mo><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> requires the specification of two objects, <epub:switch id="mathmlSwitch775"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo stretchy='false'>(</mo><msub><mi>v</mi><mn>1</mn></msub><mo stretchy='false'>)</mo><mo>,</mo><mi>F</mi><mo stretchy='false'>(</mo><msub><mi>v</mi><mn>2</mn></msub><mo stretchy='false'>)</mo><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and a morphism <em>F</em>(<em>e</em>): <em>F</em>(<em>v</em><sub>1</sub>) &#x2192; <em>F</em>(<em>v</em><sub>2</sub>) in <epub:switch id="mathmlSwitch776"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> . The identity and composition formulas are taken care of once that much is specified. To recap, a functor <epub:switch id="mathmlSwitch777"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mo stretchy='false'>[</mo><mn>1</mn><mo stretchy='false'>]</mo><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is the same thing as a morphism in <epub:switch id="mathmlSwitch778"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> .</p>
<p>Thus, choosing two functors <epub:switch id="mathmlSwitch779"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>,</mo><mi>G</mi><mo>:</mo><mo stretchy='false'>[</mo><mn>1</mn><mo stretchy='false'>]</mo><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is precisely the same thing as choosing two morphisms in <epub:switch id="mathmlSwitch780"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> . Let us call them <em>f</em> : <em>a</em><sub>0</sub> &#x2192; <em>a</em><sub>1</sub> and <em>g</em> : <em>b</em><sub>0</sub> &#x2192; <em>b</em><sub>1</sub>, where we have <em>f</em> &#x003D; <em>F</em>(<em>e</em>), <em>a</em><sub>0</sub> &#x003D; <em>F</em>(<em>v</em><sub>0</sub>), <em>a</em><sub>1</sub> &#x003D; <em>F</em>(<em>v</em><sub>1</sub>) and <em>g</em> &#x003D; <em>G</em>(<em>e</em>), <em>b</em><sub>0</sub> &#x003D; <em>G</em>(<em>v</em><sub>0</sub>), <em>b</em><sub>1</sub> &#x003D; <em>G</em>(<em>v</em><sub>1</sub>).</p>
<p>A natural transformation <em>&#x03B1;</em> : <em>F</em> &#x2192; <em>G</em> consists of two components, i.e., morphisms <epub:switch id="mathmlSwitch781"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mi>&#x03B1;</mi><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow></msub><mo>:</mo><msub><mi>a</mi><mn>0</mn></msub><mo>&#x2192;</mo><msub><mi>b</mi><mn>0</mn></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch782"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mi>&#x03B1;</mi><mrow><msub><mi>v</mi><mn>1</mn></msub></mrow></msub><mo>:</mo><msub><mi>a</mi><mn>1</mn></msub><mo>&#x2192;</mo><msub><mi>b</mi><mn>1</mn></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>, drawn as dashed lines:</p>
<p class="fig-img"><img src="images/Art_P192.jpg" alt="art"/></p>
<p class="noindent">The condition for <em>&#x03B1;</em> to be a natural transformation is that this square commutes.</p>
<a id="p221"></a>
<p>In other words, a functor <epub:switch id="mathmlSwitch783"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo stretchy='false'>[</mo><mn>1</mn><mo stretchy='false'>]</mo><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a morphism in <epub:switch id="mathmlSwitch784"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> and a natural transformation between two such functors is just a commutative square in <epub:switch id="mathmlSwitch785"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> .</p>
<p class="noindent1-top-exe" id="Exa_5-3-1-15"><em>Example</em> 5.3.1.15. Recall that to any graph <em>G</em> we can associate the paths-graph Paths(<em>G</em>) (see Example <a href="chapter005.html#Exa_5-1-2-25">5.1.2.25</a>). This is a functor Paths: <strong>Grph</strong> &#x2192; <strong>Grph</strong>. There is also an identity functor id<strong><sub>Grph</sub></strong> : <strong>Grph</strong> &#x2192; <strong>Grph</strong>. A natural transformation <em>&#x03B7;</em> : id<strong><sub>Grph</sub></strong> &#x2192; Paths would consist of a graph homomorphism <em>&#x03B7;<sub>G</sub></em> : id<strong><sub>Grph</sub></strong>(<em>G</em>) &#x2192; Paths(<em>G</em>) for every graph <em>G</em>. But id<strong><sub>Grph</sub></strong>(<em>G</em>) &#x003D; <em>G</em> by definition, so we need <em>&#x03B7;<sub>G</sub></em> : <em>G</em> &#x2192; Paths(<em>G</em>). Recall that Paths(<em>G</em>) has the same vertices as <em>G</em>, and every arrow in <em>G</em> counts as a path (of length 1). So there is an obvious graph homomorphism from <em>G</em> to Paths(<em>G</em>). It is not hard to see that the necessary naturality squares commute.</p>
<p class="noindent1-top-exe" id="Exa_5-3-1-16"><em>Example</em> 5.3.1.16. For any graph <em>G</em> we can associate the paths-graph Paths(<em>G</em>), and can do that twice to yield a new graph Paths(Paths(<em>G</em>)). Let&#x2019;s think through what a path of paths in <em>G</em> is. It is a head-to-tail sequence of arrows in Paths(<em>G</em>), meaning a head-to-tail sequence of paths in <em>G</em>. These composable sequences of paths (or &#x201C;paths of paths&#x201D;) are the individual arrows in Paths(Paths(<em>G</em>)). The vertices in Paths(<em>G</em>) and Paths(Paths(<em>G</em>)) are the same as those in <em>G</em>, and all source and target functions are as expected.</p>
<p>Clearly, given such a sequence of paths in <em>G</em>, we could compose them to one big path in <em>G</em> with the same endpoints. In other words, for every <em>G</em> &#x2208; Ob(<strong>Grph</strong>), there is graph homomorphism <em>&#x00B5;<sub>G</sub></em> : Paths(Paths(<em>G</em>)) &#x2192; Paths(<em>G</em>) that is called <em>concatenation</em>. In fact, this concatenation extends to a natural transformation</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch786"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>&#x03BC;</mi><mo>:</mo><mtext>Paths</mtext><mo>&#x25CB;</mo><mtext>Paths</mtext><mo>&#x2192;</mo><mtext>Paths</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">between functors <strong>Grph</strong> &#x2192; <strong>Grph</strong>. Example <a href="chapter005.html#Exa_5-3-1-15">5.3.1.15</a> compared a graph to its paths-graph using a natural transformation id<strong><sub>Grph</sub></strong> &#x2192; Paths; here we are making a similar kind of comparison.</p>

<p class="noindent1-top-rem" id="Rem_5-3-1-17"><em>Remark</em> 5.3.1.17. Example <a href="chapter005.html#Exa_5-3-1-15">5.3.1.15</a> showed that there is a natural transformation comparing each graph to its paths-graph. There is a formal sense in which a category is nothing more than a kind of reverse mapping. That is, to specify a category is the same thing as to specify a graph <em>G</em> together with a graph homomorphism Paths(<em>G</em>) &#x2192; <em>G</em>. The formalities involve monads (see Section <a href="chapter007.html#lev_7-3">7.3</a>).</p>
<p class="noindent1-top-exe" id="Exe_5-3-1-18"><em>Exercise</em> 5.3.1.18.</p>
<p>Let <em>X</em> and <em>Y</em> be sets, and let <em>h</em> : <em>X</em> &#x2192; <em>Y</em>. There is a functor <em>C<sub>X</sub></em> : <strong>Grph</strong> &#x2192; <strong>Set</strong> that sends every graph to the set <em>X</em> and sends every morphism of graphs to the identity morphism id<em><sub>X</sub></em> : <em>X</em> &#x2192; <em>X</em>. This functor is called <em>the constant functor at X</em>. Similarly, there is a constant functor <em>C<sub>Y</sub></em> : <strong>Grph</strong> &#x2192; <strong>Set</strong>.</p>
<p class="nl1-list">a. Use <em>h</em> to construct the components of a questionably natural transformation <em>&#x03B1;</em> : <em>C<sub>X</sub></em> &#x2192; <em>C<sub>Y</sub></em>.</p>
<a id="p222"></a>
<p class="nl1-list">b. Is <em>&#x03B1;</em> natural?</p>
<p class="noindent1-top-exe" id="Exe_5-3-1-19"><em>Exercise</em> 5.3.1.19.</p>
<p>For any graph (<em>V</em>, <em>A</em>, <em>src</em>, <em>tgt</em>) we can extract the set of arrows or the set of vertices. Since each morphism of graphs includes a function between their arrow sets and a function between their vertex sets, we actually have functors <em>Ar</em> : <strong>Grph</strong> &#x2192; <strong>Set</strong> and <em>Ve</em> : <strong>Grph</strong> &#x2192; <strong>Set</strong>.</p>
<p class="nl1-list">a. If someone said, &#x201C;Taking source vertices gives a natural transformation from <em>Ar</em> to <em>Ve</em>,&#x201D; what questionably natural transformation might she be referring to?</p>
<p class="nl1-list">b. Is she correct, i.e., is it natural?</p>

<p class="nl1-list">c. If a different person, say, from a totally different city and in a totally different frame of mind, were to hear this and say, &#x201C;Taking target vertices also gives a natural transformation from <em>Ar</em> to <em>Ve</em>,&#x201D; would they also be correct?</p>
<p class="noindent1-top-exe" id="Exa_5-3-1-20"><em>Example</em> 5.3.1.20 (Graph homomorphisms are natural transformations). As discussed (see diagram (<a href="chapter005.html#eq_5-8">5.8</a>)), there is a category <strong>GrIn</strong> for which a functor <em>G</em> : <strong>GrIn</strong> &#x2192; <strong>Set</strong> is the same thing as a graph. Namely, we have</p>
<p class="fig-img"><img src="images/Art_P193.jpg" alt="art"/></p>
<p class="noindent">A natural transformation of two such functors <em>&#x03B1;</em> : <em>G</em> &#x2192; <em>G</em>&#x2032; involves two components, <em>&#x03B1;<sub>Ar</sub></em> : <em>G</em>(<em>Ar</em>) &#x2192; <em>G</em>&#x2032;(<em>Ar</em>) and <em>&#x03B1;<sub>Ve</sub></em> : <em>G</em>(<em>Ve</em>) &#x2192; <em>G</em>&#x2032;(<em>Ve</em>), and two naturality squares, one for <em>src</em> and one for <em>tgt</em>. This is precisely the same thing as a graph homomorphism, as defined in Definition <a href="chapter004.html#Def_4-3-3-1">4.3.3.1</a>.</p>

</section>


<section title="Vertical and horizontal composition">
<h2 class="level2" id="lev_5-3-2"><strong>5.3.2&#160;&#160;&#160;Vertical and horizontal composition</strong></h2>
<p class="noindent">This section discusses two types of compositions for natural transformations. The terms <em>vertical</em> and <em>horizontal</em> are used to describe them; these terms come from the following pictures:</p>
<a id="p223"></a>
<p class="fig-img"><img src="images/Art_P194.jpg" alt="art"/></p>
<p class="noindent">We use the symbol &#x25CB; to denote vertical composition, so we have <em>&#x03B2;</em> &#x25CB; <em>&#x03B1;</em> : <em>F</em> &#x2192; <em>H</em> in the left-hand diagram. We use the symbol &#x25C7; for horizontal composition, so we have <em>&#x03B3;</em><sub>2</sub> &#x25C7; <em>&#x03B3;</em><sub>1</sub> : <em>F</em><sub>2</sub> &#x25CB; <em>F</em><sub>1</sub> &#x2192; <em>G</em><sub>2</sub> &#x25CB; <em>G</em><sub>1</sub> in the right-hand diagram. Of course, the actual arrangement of things on a page of text does not correlate with verticality or horizontality&#x2014;these are just names. We define them more carefully in the following.</p>


<section title="Vertical composition of natural transformations">
<h3 class="level3" id="lev_5-3-2-1"><strong>5.3.2.1&#160;&#160;&#160;Vertical composition of natural transformations</strong></h3>
<p class="noindent">The following proposition proves that functors and natural transformations (using vertical composition) form a category.</p>
<p class="noindent1-top-pro" id="Pro_5-3-2-2"><strong>Proposition 5.3.2.2</strong>. <em>Let</em> <epub:switch id="mathmlSwitch787"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> <em>and</em> <epub:switch id="mathmlSwitch788"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> <em>be categories. There exists a category, called</em> the category of functors from <epub:switch id="mathmlSwitch789"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> to <epub:switch id="mathmlSwitch790"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> <em>and denoted</em> <epub:switch id="mathmlSwitch791"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>,</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <em>whose objects are the functors</em> <epub:switch id="mathmlSwitch792"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>and whose morphisms are the natural transformations</em>,</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch793"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>,</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo></mrow></msub><mo stretchy='false'>(</mo><mi>F</mi><mo>,</mo><mi>G</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x007B;</mo><mi>&#x03B1;</mi><mo>:</mo><mi>F</mi><mo>&#x2192;</mo><mi>G</mi><mo stretchy="false">&#x007C;</mo><mi>&#x03B1;</mi><mo>&#x00A0;</mo><mtext>is a natural transformation</mtext><mo>&#x007D;</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent"><em>Under this setup, there are indeed identity natural transformations and a composition formula for natural transformations, so we have defined a questionable category</em> <epub:switch id="mathmlSwitch794"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>,</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. <em>The category laws hold, so it is indeed a category</em>.</p>
<p class="noindent1-top"><em>Proof</em>. Exercise <a href="chapter005.html#Exe_5-3-1-13">5.3.1.13</a> showed that for any functor <epub:switch id="mathmlSwitch795"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, there is an identity natural transformation id<em><sub>F</sub></em> : <em>F</em> &#x2192; <em>F</em> (its component at <epub:switch id="mathmlSwitch796"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is id<sub><em>F</em>(<em>c</em>)</sub> : <em>F</em>(<em>c</em>) &#x2192; <em>F</em>(<em>c</em>)).</p>
<p>Given a natural transformation <em>&#x03B1;</em> : <em>F</em> &#x2192; <em>G</em> and a natural transformation <em>&#x03B2;</em> : <em>G</em> &#x2192; <em>H</em>, we need a composite <em>&#x03B2;</em> &#x25CB; <em>&#x03B1;</em>. We propose the transformation <em>&#x03B3;</em> : <em>F</em> &#x2192; <em>H</em> having components <em>&#x03B2;<sub>c</sub></em> &#x25CB; <em>&#x03B1;<sub>c</sub></em> for every <epub:switch id="mathmlSwitch797"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. To see that <em>&#x03B3;</em> is indeed a natural transformation, one simply puts together naturality squares for <em>&#x03B1;</em> and <em>&#x03B2;</em> to get naturality squares for <em>&#x03B2;</em> &#x25CB; <em>&#x03B1;</em>.</p>
<p>One proves the associativity and identity laws in <epub:switch id="mathmlSwitch798"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>,</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> using the fact that they hold in <epub:switch id="mathmlSwitch799"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch>.</p>

<p class="noindent1-top" id="Not_5-3-2-3"><em>Notation</em> 5.3.2.3. We sometimes denote the category <epub:switch id="mathmlSwitch800"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>,</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> by <epub:switch id="mathmlSwitch801"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mi mathvariant='script'>D</mi><mi mathvariant='script'>C</mi></msup></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<a id="p224"></a>
<p class="noindent1-top-exe" id="Exa_5-3-2-4"><em>Example</em> 5.3.2.4. Recall from Exercise <a href="chapter005.html#Exe_5-1-2-41">5.1.2.41</a> that there is a functor Ob: <strong>Cat</strong> &#x2192; <strong>Set</strong> sending a category to its set of objects. And recall from Example <a href="chapter005.html#Exa_5-1-2-38">5.1.2.38</a> that there is a functor <epub:switch id="mathmlSwitch802"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext mathvariant="bold">Set</mtext><mover><mo>&#x2192;</mo><mrow><mtext mathvariant="italic">Disc</mtext></mrow></mover><mtext mathvariant="bold">Cat</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> sending a set to the discrete category with that set of objects (all morphisms in <em>Disc</em>(<em>S</em>) are identity morphisms). Let <em>P</em> : <strong>Cat</strong> &#x2192; <strong>Cat</strong> be the composition <em>P</em> &#x003D; <em>Disc</em> &#x25CB; Ob. Then <em>P</em> takes a category and makes a new category with the same objects but no morphisms. It is like crystal meth for categories.</p>
<p>Let id<strong><sub>Cat</sub></strong> : <strong>Cat</strong> &#x2192; <strong>Cat</strong> be the identity functor. There is a natural transformation <em>i</em> : <em>P</em> &#x2192; id<strong><sub>Cat</sub></strong>. For any category <epub:switch id="mathmlSwitch803"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, the component <epub:switch id="mathmlSwitch804"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mi>i</mi><mi mathvariant='script'>C</mi></msub><mo>:</mo><mi>P</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is pretty easily understood. It is a morphism of categories, i.e., a functor. The two categories <epub:switch id="mathmlSwitch805"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch806"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> have the same set of objects, namely, <epub:switch id="mathmlSwitch807"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, so the functor is identity on objects; and <epub:switch id="mathmlSwitch808"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> has no nonidentity morphisms, so nothing else needs be specified.</p>
<p class="noindent1-top-exe" id="Exe_5-3-2-5"><em>Exercise</em> 5.3.2.5.</p>
<p>Let <img src="images/Art_P195.jpg" alt="art"/> be the category with <epub:switch id="mathmlSwitch809"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x007B;</mo><mi>A</mi><mo>&#x007D;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and <epub:switch id="mathmlSwitch810"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>D</mi></msub><mo stretchy='false'>(</mo><mi>A</mi><mo>,</mo><mi>A</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>&#x007B;</mo><msub><mrow><mtext>id</mtext></mrow><mi>A</mi></msub><mo>&#x007D;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. What is <epub:switch id="mathmlSwitch811"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>D</mi><mo>,</mo><mtext mathvariant='bold'>Set</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>? In particular, characterize the objects and the morphisms.</p>
<p class="noindent1-top" id="Not_5-3-2-6"><em>Notation</em> 5.3.2.6. Recall from Notation <a href="chapter002.html#Not_2-1-2-9">2.1.2.9</a> that if <em>X</em> is a set, we can represent an element <em>x</em> &#x2208; <em>X</em> as a function <epub:switch id="mathmlSwitch812"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo>&#x007B;</mo><mo>&#x263A;</mo><mo>&#x007D;</mo><mover><mo>&#x2192;</mo><mi>x</mi></mover><mi>X</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Similarly, suppose that <epub:switch id="mathmlSwitch813"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> is a category and <epub:switch id="mathmlSwitch814"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is an object. There is a functor <epub:switch id="mathmlSwitch815"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> that sends 1 &#x21A6; <em>c</em>. We say that this functor <em>represents</em> <epub:switch id="mathmlSwitch816"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. We may denote it <epub:switch id="mathmlSwitch817"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi><mo>:</mo><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>

<p class="noindent1-top-exe" id="Exe_5-3-2-7"><em>Exercise</em> 5.3.2.7.</p>
<p>Let <em>n</em> &#x2208; &#x2115;, and let <em><span class="underline">n</span></em> be the set with <em>n</em> elements, considered as a discrete category.<sup><a id="endnote_ref_13" href="chapter005.html#endnote_13">13</a></sup> In other words, we write <em><span class="underline">n</span></em> to mean what should really be called <em>Disc</em>(<em><span class="underline">n</span></em>). Describe the category Fun(<span class="underline">3</span>, <span class="underline">2</span>).</p>
<p class="noindent1-top-exe" id="Exa_5-3-2-8"><em>Example</em> 5.3.2.8. Let <span class="underline">1</span> denote the discrete category with one object (also known as the trivial monoid). For any category <epub:switch id="mathmlSwitch818"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, we investigate the category <epub:switch id="mathmlSwitch819"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>D</mi><mo>&#x2254;</mo><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>,</mo><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Its objects are functors <epub:switch id="mathmlSwitch820"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Such a functor <em>F</em> assigns to each object in <epub:switch id="mathmlSwitch821"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> an object in <span class="underline">1</span>, of which there is one; so there is no choice in what <em>F</em> does on objects. And there is only one morphism in <span class="underline">1</span>, so there is no choice in what <em>F</em> does on morphisms. The upshot is that there is only one object in <epub:switch id="mathmlSwitch822"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch>, let&#x2019;s call it <em>F</em>, so <epub:switch id="mathmlSwitch823"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> is a monoid. What are its morphisms?</p>
<a id="p225"></a>
<p>A morphism <em>&#x03B1;</em> : <em>F</em> &#x2192; <em>F</em> in <epub:switch id="mathmlSwitch824"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> is a natural transformation of functors. For every <epub:switch id="mathmlSwitch825"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we need a component <em>&#x03B1;<sub>c</sub></em> : <em>F</em> (<em>c</em>) &#x2192; <em>F</em> (<em>c</em>), which is a morphism 1 &#x2192; 1 in <span class="underline">1</span>. But there is only one morphism in <span class="underline">1</span>, namely, id<sub>1</sub>, so there is no choice about what these components should be: they are all id<sub>1</sub>. The necessary naturality squares commute, so <em>&#x03B1;</em> is indeed a natural transformation. Thus the monoid <epub:switch id="mathmlSwitch826"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> is the trivial monoid; that is, <epub:switch id="mathmlSwitch827"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>,</mo><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder><mo stretchy='false'>)</mo><mo>&#x2245;</mo><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder></mrow></math></epub:case><epub:default></epub:default></epub:switch> for any category <epub:switch id="mathmlSwitch828"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>.</p>

<p class="noindent1-top-exe" id="Exe_5-3-2-9"><em>Exercise</em> 5.3.2.9.</p>
<p>Let <span class="underline">0</span> represent the discrete category on 0 objects; it has no objects and no morphisms. Let <epub:switch id="mathmlSwitch829"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> be any category.</p>
<p class="nl1-list">a. What is <epub:switch id="mathmlSwitch830"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Fun</mtext><mo stretchy='false'>(</mo><munder accentunder='true'><mn>0</mn><mo>&#x00AF;</mo></munder><mo>,</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>?</p>
<p class="nl1-list">b. What is <epub:switch id="mathmlSwitch831"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>,</mo><munder accentunder='true'><mn>0</mn><mo>&#x00AF;</mo></munder><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>?</p>
<p class="noindent1-top-exe" id="Exe_5-3-2-10"><em>Exercise</em> 5.3.2.10.</p>
<p>Let [1] denote the free arrow category as in Exercise <a href="chapter005.html#Exe_5-1-2-34">5.1.2.34</a>, and let <strong>GrIn</strong> be the graph-indexing category (see (<a href="chapter005.html#eq_5-8">5.8</a>). Draw the underlying graph of the category Fun([1], <strong>GrIn</strong>).</p>

</section>


<section title="Natural isomorphisms">
<h3 class="level3" id="lev_5-3-2-11"><strong>5.3.2.11&#160;&#160;&#160;Natural isomorphisms</strong></h3>
<p class="noindent">Let <epub:switch id="mathmlSwitch832"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch833"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> be categories. We have defined a category <epub:switch id="mathmlSwitch834"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>,</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> whose objects are functors <epub:switch id="mathmlSwitch835"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and whose morphisms are natural transformations. What are the isomorphisms in this category?</p>
<p class="noindent1-top-pro" id="Pro_5-3-2-12"><strong>Proposition 5.3.2.12</strong> (Natural isomorphism). <em>Let</em> <epub:switch id="mathmlSwitch836"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> <em>and</em> <epub:switch id="mathmlSwitch837"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> <em>be categories, and let</em> <epub:switch id="mathmlSwitch838"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>,</mo><mi>G</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>be functors. A natural transformation &#x03B1;</em> : <em>F</em> &#x2192; <em>G is an isomorphism in</em> <epub:switch id="mathmlSwitch839"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>,</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>if and only if the component &#x03B1;<sub>c</sub></em> : <em>F</em>(<em>c</em>) &#x2192; <em>G</em>(<em>c</em>) <em>is an isomorphism for each object</em> <epub:switch id="mathmlSwitch840"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. <em>In this case &#x03B1; is called a</em> natural isomorphism.</p>
<p class="noindent1-top"><em>Proof</em>. First, suppose that <em>&#x03B1;</em> is an isomorphism with inverse <em>&#x03B2;</em> : <em>G</em> &#x2192; <em>F</em>, and let <em>&#x03B2;<sub>c</sub></em> : <em>G</em>(<em>c</em>) &#x2192; <em>F</em> (<em>c</em>) denote its <em>c</em> component. We know that <em>&#x03B1;</em> &#x25CB; <em>&#x03B2;</em> &#x003D; id<em><sub>G</sub></em> and <em>&#x03B2;</em> &#x25CB; <em>&#x03B1;</em> &#x003D; id<em><sub>F</sub></em>. Using the definitions of composition and identity given in Proposition <a href="chapter005.html#Pro_5-3-2-2">5.3.2.2</a>, this means that for every <epub:switch id="mathmlSwitch841"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we have <em>&#x03B1;<sub>c</sub></em> &#x25CB; <em>&#x03B2;<sub>c</sub></em> &#x003D; id<sub><em>G</em>(<em>c</em>)</sub> and <em>&#x03B2;<sub>c</sub></em> &#x25CB; <em>&#x03B1;<sub>c</sub></em> &#x003D; id<sub><em>F</em>(<em>c</em>)</sub>; in other words, <em>&#x03B1;<sub>c</sub></em> is an isomorphism.</p>
<p>Second, suppose that each <em>&#x03B1;<sub>c</sub></em> is an isomorphism with inverse <em>&#x03B2;<sub>c</sub></em> : <em>G</em>(<em>c</em>) &#x2192; <em>F</em>(<em>c</em>). We need to see that these components assemble into a natural transformation, i.e., for every <a id="p226"></a>morphism <em>h</em> : <em>c</em> &#x2192; <em>c</em>&#x2032; in <epub:switch id="mathmlSwitch842"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, the right-hand square</p>
<p class="fig-img"><img src="images/Art_P196.jpg" alt="art"/></p>
<p class="noindent">commutes. We know that the left-hand square commutes because <em>&#x03B1;</em> is a natural transformation; each square is labeled with a ? or a &#x2713; accordingly. In the following diagram we want to show that the left-hand square commutes. We know that the middle square commutes.</p>
<p class="fig-img" id="eq_5-14"><img src="images/Art_P197.jpg" alt="art"/></p>

<p class="noindent">To complete the proof we need only show that <em>F</em>(<em>h</em>) &#x25CB; <em>&#x03B2;<sub>c</sub></em> &#x003D; <em>&#x03B2;<sub>c&#x2032;</sub></em> &#x25CB; <em>G</em>(<em>h</em>). This can be shown by a &#x201C;diagram chase.&#x201D; We go through it symbolically, for demonstration. The following three equalities come from the three check marks in the (<a href="chapter005.html#eq_5-14">5.14</a>).</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch843"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo stretchy='false'>(</mo><mi>h</mi><mo stretchy='false'>)</mo><mo>&#x25CB;</mo><msub><mi>&#x03B2;</mi><mi>c</mi></msub><mo>=</mo><msub><mi>&#x03B2;</mi><mrow><mi>c</mi><mo>&#x2032;</mo></mrow></msub><mo>&#x25CB;</mo><msub><mi>&#x03B1;</mi><mrow><mi>c</mi><mo>&#x2032;</mo></mrow></msub><mo>&#x25CB;</mo><mi>F</mi><mo stretchy='false'>(</mo><mi>h</mi><mo stretchy='false'>)</mo><mo>&#x25CB;</mo><msub><mi>&#x03B2;</mi><mi>c</mi></msub><mo>=</mo><msub><mi>&#x03B2;</mi><mrow><mi>c</mi><mo>&#x2032;</mo></mrow></msub><mo>&#x25CB;</mo><mi>G</mi><mo stretchy='false'>(</mo><mi>h</mi><mo stretchy='false'>)</mo><mo>&#x25CB;</mo><msub><mi>&#x03B1;</mi><mi>c</mi></msub><mo>&#x25CB;</mo><msub><mi>&#x03B2;</mi><mi>c</mi></msub><mo>=</mo><msub><mi>&#x03B2;</mi><mrow><mi>c</mi><mo>&#x2032;</mo></mrow></msub><mo>&#x25CB;</mo><mi>G</mi><mo stretchy='false'>(</mo><mi>h</mi><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top-exe" id="Exe_5-3-2-13"><em>Exercise</em> 5.3.2.13.</p>
<p>Recall from Application <a href="chapter005.html#App_5-3-1-12">5.3.1.12</a> that a finite state machine on alphabet &#x03A3; can be understood as a functor <epub:switch id="mathmlSwitch844"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow><mo>&#x2192;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch>, where <epub:switch id="mathmlSwitch845"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow><mo>&#x003D;</mo><mtext>List</mtext><mo>(</mo><mo>&#x03A3;</mo><mo>)</mo></math></epub:case><epub:default></epub:default></epub:switch> is the free monoid generated by &#x03A3;. That example also discussed how natural transformations provide a language for changing state machines. Describe what kinds of changes are made by natural isomorphisms.</p>

</section>
<a id="p227"></a>


<section title="Horizontal composition of natural transformations">
<h3 class="level3" id="lev_5-3-2-14"><strong>5.3.2.14&#160;&#160;&#160;Horizontal composition of natural transformations</strong></h3>
<p class="noindent1-top-exe" id="Exa_5-3-2-15"><em>Example</em> 5.3.2.15 (Whiskering). Suppose that <epub:switch id="mathmlSwitch846"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow><mo>&#x003D;</mo><mtext>List</mtext><mo>(</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>)</mo></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch847"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msup><mi mathvariant="script">M</mi><mo>&#x2032;</mo></msup></mrow><mo>&#x003D;</mo><mtext>List</mtext><mo>(</mo><mi>m</mi><mo>,</mo><mi>n</mi><mo>,</mo><mi>p</mi><mo>)</mo></math></epub:case><epub:default></epub:default></epub:switch> are free monoids, and let <epub:switch id="mathmlSwitch848"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mo>:</mo><mrow><msup><mi mathvariant="script">M</mi><mo>&#x2032;</mo></msup></mrow><mo>&#x2192;</mo><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> be given by sending [<em>m</em>] &#x21A6; [<em>a</em>], [<em>n</em>] &#x21A6; [<em>b</em>], and [<em>p</em>] &#x21A6; [<em>b</em>, <em>a</em>, <em>a</em>]. An application of this might be if the sequence [<em>b</em>, <em>a</em>, <em>a</em>] were commonly used in practice and one wanted to add a new button just for that sequence.</p>
<p>Recall Application <a href="chapter005.html#App_5-3-1-12">5.3.1.12</a> and <a href="chapter005.html#Fig_5-1">Figure 5.1</a>, which is reproduced here. Let <epub:switch id="mathmlSwitch849"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi><mo>:</mo><mrow><mi mathvariant="script">M</mi></mrow><mo>&#x2192;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch850"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Y</mi><mo>:</mo><mrow><mi mathvariant="script">M</mi></mrow><mo>&#x2192;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch> be the functors, and let <em>&#x03B1;</em> : <em>Y</em> &#x2192; <em>X</em> be the natural transformation.</p>
<p class="fig-img"><img src="images/Art_P198.jpg" alt="art"/></p>
<p class="indent">We can compose <em>X</em> and <em>Y</em> with <em>F</em> as in the diagram below</p>
<p class="fig-img"><img src="images/Art_P199.jpg" alt="art"/></p>
<p class="noindent">to get functors <em>Y</em> &#x25CB; <em>F</em> and <em>X</em> &#x25CB; <em>F</em>, both of type <epub:switch id="mathmlSwitch851"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msup><mi mathvariant="script">M</mi><mo>&#x2032;</mo></msup></mrow><mo>&#x2192;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch>. These would be as follows:<sup><a id="endnote_ref_14" href="chapter005.html#endnote_14">14</a></sup></p>
<p class="fig-img"><img src="images/Art_P200.jpg" alt="art"/></p>
<a id="p228"></a>
<p>The map <em>&#x03B1;</em> is what sent both State 1A and State 1B in <em>Y</em> to State 1 in <em>X</em>, and so on. We can see that the same <em>&#x03B1;</em> works now: the <em>p</em> columns of the tables respect that mapping; that is, they act like [<em>b</em>, <em>a</em>, <em>a</em>] or equivalently [<em>n</em>, <em>m</em>, <em>m</em>]. This is called <em>whiskering</em>. We used <em>&#x03B1;</em> : <em>Y</em> &#x2192; <em>X</em> to get a natural transformation <em>Y</em> &#x25CB; <em>F</em> &#x2192; <em>X</em> &#x25CB; <em>F</em> . It is a kind of horizontal composition of natural transformation.</p>
<p class="noindent1-top-def" id="Def_5-3-2-16"><strong>Definition 5.3.2.16</strong> (Whiskering). Let <epub:switch id="mathmlSwitch852"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>B</mi><mo>,</mo><mi mathvariant='script'>C</mi><mo>,</mo><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch>, and <epub:switch id="mathmlSwitch853"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>E</mi></math></epub:case><epub:default></epub:default></epub:switch> be categories, let <epub:switch id="mathmlSwitch854"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mi>G</mi><mn>1</mn></msub><mo>,</mo><msub><mi>G</mi><mn>2</mn></msub><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> be functors, and let <em>&#x03B1;</em> : <em>G</em><sub>1</sub> &#x2192; <em>G</em><sub>2</sub> be a natural transformation. Suppose that <epub:switch id="mathmlSwitch855"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>B</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> (resp. <epub:switch id="mathmlSwitch856"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>H</mi><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2192;</mo><mi mathvariant='script'>E</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>) is a functor as depicted here:</p>
<p class="fig-img"><img src="images/Art_P201.jpg" alt="art"/></p>
<p class="noindent">Then the <em>prewhiskering of &#x03B1; by F</em>, denoted <em>&#x03B1;</em> &#x25C7; <em>F</em> : <em>G</em><sub>1</sub> &#x25CB; <em>F</em> &#x2192; <em>G</em><sub>2</sub> &#x25CB; <em>F</em> (resp. the <em>post-whiskering of &#x03B1; by H</em>, denoted <em>H</em> &#x25C7; <em>&#x03B1;</em> : <em>H</em> &#x25CB; <em>G</em><sub>1</sub> &#x2192; <em>H</em> &#x25CB; <em>G</em><sub>2</sub>),</p>
<p class="fig-img"><img src="images/Art_P202.jpg" alt="art"/></p>
<p class="noindent">is defined as follows.</p>
<p>For each <epub:switch id="mathmlSwitch857"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi>b</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">B</mi><mo>)</mo></math></epub:case><epub:default></epub:default></epub:switch> the component (<em>&#x03B1;</em> &#x25C7; <em>F</em>)<em><sub>b</sub></em> : <em>G</em><sub>1</sub> &#x25CB; <em>F</em>(<em>b</em>) &#x2192; <em>G</em><sub>2</sub> &#x25CB; <em>F</em>(<em>b</em>) is defined to be <em>&#x03B1;</em><sub><em>F</em>(<em>b</em>)</sub> (resp. for each <epub:switch id="mathmlSwitch858"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, the component (<em>H</em> &#x25C7; <em>&#x03B1;</em>)<em><sub>c</sub></em> : <em>H</em> &#x25CB; <em>G</em><sub>1</sub>(<em>c</em>) &#x2192; <em>H</em> &#x25CB; <em>G</em><sub>2</sub>(<em>c</em>) is defined to be <em>H</em>(<em>&#x03B1;<sub>c</sub></em>)). Checking that the naturality squares commute (in each case) is straightforward.</p>

<p class="noindent1-top-exe" id="Exe_5-3-2-17"><em>Exercise</em> 5.3.2.17.</p>
<p>Suppose given functors <epub:switch id="mathmlSwitch859"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant="script">B</mi><mover><mo>&#x2192;</mo><mi>F</mi></mover><mi mathvariant='script'>C</mi><mover><mo>&#x2192;</mo><mi>G</mi></mover><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and let id<em><sub>G</sub></em> : <em>G</em> &#x2192; <em>G</em> be the identity natural isomorphism. Show that id<em><sub>G</sub></em> &#x25C7; <em>F</em> &#x003D; id<sub><em>G</em>&#x25CB;<em>F</em></sub>.</p>
<p class="noindent1-top-sol"><em>Solution</em> 5.3.2.17.</p>
<p>By Definition <a href="chapter005.html#Def_5-3-2-16">5.3.2.16</a>, for each object <epub:switch id="mathmlSwitch860"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi>b</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo>(</mo><mi mathvariant="script">B</mi><mo>)</mo></math></epub:case><epub:default></epub:default></epub:switch>, the component (id<em><sub>G</sub></em> &#x25C7; <em>F</em>)<em><sub>b</sub></em> is the identity morphism (id<em><sub>G</sub></em>)<sub><em>F</em>(<em>b</em>)</sub> : <em>G</em>(<em>F</em>(<em>b</em>)) &#x2192; <em>G</em>(<em>F</em>(<em>b</em>)). But there can be only one identity morphism, so (id<em><sub>G</sub></em>)<sub><em>F</em>(<em>b</em>)</sub> &#x003D; id<sub><em>G</em>&#x25CB;<em>F</em>(<em>b</em>)</sub> &#x003D; id<sub><em>G</em>&#x25CB;<em>F</em>(<em>b</em>)</sub>.</p>
<p class="noindent1-top-def" id="Def_5-3-2-18"><strong>Definition 5.3.2.18</strong> (Horizontal composition of natural transformations). Let <epub:switch id="mathmlSwitch861"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>B</mi></math></epub:case><epub:default></epub:default></epub:switch>, <epub:switch id="mathmlSwitch862"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, and <epub:switch id="mathmlSwitch863"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> be categories, let <epub:switch id="mathmlSwitch864"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mi>F</mi><mn>1</mn></msub><mo>,</mo><msub><mi>F</mi><mn>2</mn></msub><mo>:</mo><mi mathvariant="script">B</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch865"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mi>G</mi><mn>1</mn></msub><mo>,</mo><msub><mi>G</mi><mn>2</mn></msub><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> be functors, and let <em>&#x03B1;</em> : <em>F</em><sub>1</sub> &#x2192; <em>F</em><sub>2</sub> <a id="p229"></a>and <em>&#x03B2;</em> : <em>G</em><sub>1</sub> &#x2192; <em>G</em><sub>2</sub> be natural transformations, as depicted here:</p>
<p class="fig-img"><img src="images/Art_P203.jpg" alt="art"/></p>
<p class="noindent">By pre- and postwhiskering in one order or the other we get the following diagram:</p>
<p class="fig-img"><img src="images/Art_P204.jpg" alt="art"/></p>
<p class="noindent">It is straightforward to show that this diagram commutes, so we can take the composition to be the definition of the horizontal composition:</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch866"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>&#x03B2;</mi><mo>&#x25C7;</mo><mi>&#x03B1;</mi><mo>:</mo><msub><mi>G</mi><mn>1</mn></msub><mo>&#x25CB;</mo><msub><mi>F</mi><mn>1</mn></msub><mo>&#x2192;</mo><msub><mi>G</mi><mn>2</mn></msub><mo>&#x25CB;</mo><msub><mi>F</mi><mn>2</mn></msub><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top-rem" id="Rem_5-3-2-19"><em>Remark</em> 5.3.2.19. Whiskering a natural transformation <em>&#x03B1;</em> with a functor <em>F</em> is the same thing as horizontally composing <em>&#x03B1;</em> with the identity natural transformation id<em><sub>F</sub></em> . This is true for both pre- and postwhiskering. For example, in the notation of Definition <a href="chapter005.html#Def_5-3-2-16">5.3.2.16</a>, we have</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch867"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtable columnalign='left'><mtr columnalign='left'><mtd columnalign='left'><mrow><mi>&#x03B1;</mi><mo>&#x25C7;</mo><mi>F</mi><mo>=</mo><mi>&#x03B1;</mi><mo>&#x25C7;</mo><msub><mrow><mtext>id</mtext></mrow><mi>F</mi></msub></mrow></mtd><mtd columnalign='left'><mrow><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mtext>and</mtext><mo>&#x00A0;</mo></mrow></mtd><mtd columnalign='left'><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mrow><mi>H</mi><mo>&#x25C7;</mo><mi>&#x03B1;</mi><mo>=</mo><msub><mrow><mtext>id</mtext></mrow><mi>H</mi></msub><mo>&#x25C7;</mo><mi>&#x03B1;</mi></mrow></mtd></mtr></mtable><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>

<p class="noindent1-top-the" id="The_5-3-2-20"><strong>Theorem 5.3.2.20</strong> (Interchange).</p>
<p class="fig-img"><img src="images/Art_P205.jpg" alt="art"/></p>
<p class="noindent"><em>Given a setup of categories, functors, and natural transformations as shown, we have</em></p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch868"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo stretchy='false'>(</mo><msub><mi>&#x03B2;</mi><mn>2</mn></msub><mo>&#x25CB;</mo><msub><mi>&#x03B2;</mi><mn>1</mn></msub><mo stretchy='false'>)</mo><mo>&#x25C7;</mo><mo stretchy='false'>(</mo><msub><mi>&#x03B1;</mi><mn>2</mn></msub><mo>&#x25CB;</mo><msub><mi>&#x03B1;</mi><mn>1</mn></msub><mo stretchy='false'>)</mo><mo>=</mo><mo stretchy='false'>(</mo><msub><mi>&#x03B2;</mi><mn>2</mn></msub><mo>&#x25C7;</mo><msub><mi>&#x03B1;</mi><mn>2</mn></msub><mo stretchy='false'>)</mo><mo>&#x25CB;</mo><mo stretchy='false'>(</mo><mi>&#x03B2;</mi><msub><malignmark/><mn>1</mn></msub><mo>&#x25C7;</mo><msub><mi>&#x03B1;</mi><mn>1</mn></msub><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent"><em>Proof</em>. One need only observe that each square commutes in the following diagram, so taking either outer path to get (<em>&#x03B2;</em><sub>2</sub> &#x25CB; <em>&#x03B2;</em><sub>1</sub>) &#x25C7; (<em>&#x03B1;</em><sub>2</sub> &#x25CB; <em>&#x03B1;</em><sub>1</sub>) yields the same morphism as taking <a id="p230"></a>the diagonal path, (<em>&#x03B2;</em><sub>2</sub> &#x25C7; <em>&#x03B1;</em><sub>2</sub>) &#x25CB; (<em>&#x03B2;</em><sub>1</sub> &#x25C7; <em>&#x03B1;</em><sub>1</sub>):</p>
<p class="fig-img"><img src="images/Art_P206.jpg" alt="art"/></p>
<p class="noindent1-top-exe" id="Exe_5-3-2-21"><em>Exercise</em> 5.3.2.21.</p>
<p>Suppose given categories, functors, and natural transformations as shown:</p>
<p class="fig-img"><img src="images/Art_P207.jpg" alt="art"/></p>
<p class="noindent">such that <em>&#x03B1;</em> : <em>F</em> &#x2192; <em>F</em>&#x2032; and <em>&#x03B2;</em> : <em>G</em> &#x2192; <em>G</em>&#x2032; are natural isomorphisms. Show that <em>&#x03B2;</em>&#x25C7;<em>&#x03B1;</em> : <em>G</em>&#x25CB;<em>F</em> &#x2192; <em>G</em>&#x2032; &#x25CB; <em>F</em>&#x2032; is a natural isomorphism.</p>

<p class="noindent1-top-sol"><em>Solution</em> 5.3.2.21.</p>
<p>Let <em>&#x03B1;</em>&#x2032; : <em>F</em>&#x2032; &#x2192; <em>&#x03B1;</em> and <em>&#x03B2;</em>&#x2032; : <em>G</em>&#x2032; &#x2192; <em>G</em> be the inverses of <em>&#x03B1;</em> and <em>&#x03B2;</em> respectively. To check that <em>&#x03B2;</em> &#x25C7; <em>&#x03B1;</em> is an isomorphism, we use Theorem <a href="chapter005.html#The_5-3-2-20">5.3.2.20</a> (and Exercise <a href="chapter005.html#Exe_5-3-2-17">5.3.2.17</a>) to see that</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch869"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo stretchy='false'>(</mo><mi>&#x03B2;</mi><mo>&#x25C7;</mo><mi>&#x03B1;</mi><mo stretchy='false'>)</mo><mo>&#x25CB;</mo><mo stretchy='false'>(</mo><mi>&#x03B2;</mi><mo>&#x2032;</mo><mo>&#x25C7;</mo><mi>&#x03B1;</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo><mo>=</mo><mo stretchy='false'>(</mo><mi>&#x03B2;</mi><mo>&#x25CB;</mo><mi>&#x03B2;</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo><mo>&#x25C7;</mo><mo stretchy='false'>(</mo><mi>&#x03B1;</mi><mo>&#x25CB;</mo><mi>&#x03B1;</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo><mo>=</mo><msub><mrow><mtext>id</mtext></mrow><mrow><mi>G</mi><mo>&#x2032;</mo></mrow></msub><mo>&#x25C7;</mo><msub><mrow><mtext>id</mtext></mrow><mrow><mi>F</mi><mo>&#x2032;</mo></mrow></msub><mo>=</mo><msub><mrow><mtext>id</mtext></mrow><mrow><mi>G</mi><mo>&#x2032;</mo><mo>&#x25CB;</mo><mi>F</mi><mo>&#x2032;</mo></mrow></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">and similarly for the other order, (<em>&#x03B2;</em>&#x2032; &#x25C7; <em>&#x03B1;</em>&#x2032;) &#x25CB; (<em>&#x03B2;</em> &#x25C7; <em>&#x03B1;</em>) &#x003D; id<sub><em>G</em>&#x25CB;<em>f</em></sub>.</p>
</section>
</section>

<section title="The category of instances on a database schema">
<h2 class="level2" id="lev_5-3-3"><strong>5.3.3&#160;&#160;&#160;The category of instances on a database schema</strong></h2>
<p class="noindent">Section <a href="chapter005.html#lev_5-2-2">5.2.2</a> showed that schemas are presentations of categories, and Section <a href="chapter005.html#lev_5-4">5.4</a> shows that in fact the category of schemas is equivalent to the category of categories. This section therefore takes license to blur the distinction between schemas and categories.</p>
<p>If <epub:switch id="mathmlSwitch870"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> is a schema, i.e., a category, then as discussed in Section <a href="chapter005.html#lev_5-2-2-6">5.2.2.6</a>, an instance on <epub:switch id="mathmlSwitch871"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> is a functor <epub:switch id="mathmlSwitch872"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>. But now we have a notion beyond categories and functors, namely, that of natural transformations. So we make the following definition.</p>
<a id="p231"></a>
<p class="noindent1-top-def" id="Def_5-3-3-1"><strong>Definition 5.3.3.1</strong>. Let <epub:switch id="mathmlSwitch873"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> be a schema (or category). The <em>category of instances on</em> <epub:switch id="mathmlSwitch874"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, denoted <epub:switch id="mathmlSwitch875"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, is <epub:switch id="mathmlSwitch876"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>,</mo><mtext mathvariant='bold'>Set</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Its objects are <epub:switch id="mathmlSwitch877"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>C</mi><mo>-</mo><mtext>instances</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> (i.e., functors <epub:switch id="mathmlSwitch878"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>), and its morphisms are natural transformations.</p>
<p class="noindent1-top" id="Rem_5-3-3-2"><em>Remark</em> 5.3.3.2. One might object to Definition <a href="chapter005.html#Def_5-3-3-1">5.3.3.1</a> on the grounds that database instances should not be infinite. This is a reasonable perspective, and the definition can be modified easily to accommodate it. The subcategory <strong>Fin</strong> (see Example <a href="chapter005.html#Exa_5-1-1-4">5.1.1.4</a>) of finite sets can be substituted for <strong>Set</strong> in Definition <a href="chapter005.html#Def_5-3-3-1">5.3.3.1</a>. One could define the <em>category of finite instances on</em> <epub:switch id="mathmlSwitch879"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> as <epub:switch id="mathmlSwitch880"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Fin</mtext><mo>=</mo><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>,</mo><mtext mathvariant='bold'>Fin</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Almost all of the ideas in this book will make perfect sense in <epub:switch id="mathmlSwitch881"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Fin</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p>Natural transformations should serve as some kind of morphism between instances on the same schema. How are we to interpret a natural transformation <em>&#x03B1;</em> : <em>I</em> &#x2192; <em>J</em> between database instances <epub:switch id="mathmlSwitch882"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>I</mi><mo>,</mo><mi>J</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>?</p>
<p>A first clue comes from Application <a href="chapter005.html#App_5-3-1-12">5.3.1.12</a>. There we considered the case of a monoid <epub:switch id="mathmlSwitch883"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">M</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and we thought about a natural transformation between two functors <epub:switch id="mathmlSwitch884"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi><mo>,</mo><mi>Y</mi><mo>:</mo><mi mathvariant="script">M</mi></mrow><mo>&#x2192;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch>, considered as different finite state machines. The notion of natural transformation captured the idea of one model being a refinement of another. This same kind of idea works for databases with more than one table (categories with more than one object). Let&#x2019;s work it through slowly.</p>
<p class="noindent1-top-exe" id="Exa_5-3-3-3"><em>Example</em> 5.3.3.3. Consider the terminal schema, <img src="images/Art_P208.jpg" alt="art"/>. An instance is a functor <span class="underline">1</span> &#x2192; <strong>Set</strong>, which represents a set (see Notation <a href="chapter005.html#Not_5-3-2-6">5.3.2.6</a>). A natural transformation <em>&#x03B1;</em> : <em>I</em> &#x2192; <em>J</em> is a function from set <em>I</em> to set <em>J</em>. In the standard table view, we might have <em>I</em> and <em>J</em> as shown here:</p>

<p class="fig-img"><img src="images/Art_P209.jpg" alt="art"/></p>
<p>There are 343 natural transformations <em>I</em> &#x2192; <em>J</em>. Perhaps some of them make more sense than others, e.g., we could hope that the numbers in <em>I</em> corresponded to the numbers after the hyphen in <em>J</em> or perhaps to what seems to be the date in January. Knowing something like this would reduce this to only a few options out of 343 possible mappings. But it <a id="p232"></a>could be that the rows in <em>J</em> correspond to batches, and all three grapes in <em>I</em> are part of the first batch on Jan-01.</p>
<p>The point is that the notion of natural transformation is a mathematical one; it has nothing to do with the kinds of associations we might find natural, unless we have found a categorical encoding for this intuition.</p>
<p class="noindent1-top-exe" id="Exe_5-3-3-4"><em>Exercise</em> 5.3.3.4.</p>
<p>Recall the notion of set-indexed sets from Definition <a href="chapter003.html#Def_3-4-6-11">3.4.6.11</a>. Let <em>A</em> be a set, and devise a schema <epub:switch id="mathmlSwitch885"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>A</mi></math></epub:case><epub:default></epub:default></epub:switch> such that instances on <epub:switch id="mathmlSwitch886"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>A</mi></math></epub:case><epub:default></epub:default></epub:switch> are <em>A</em>-indexed sets. Is our current notion of morphism between instances (i.e., natural transformations) well aligned with this definition of mapping of <em>A</em>-indexed sets?</p>
<p class="noindent1-top-sol"><em>Solution</em> 5.3.3.4.</p>
<p>Definition <a href="chapter003.html#Def_3-4-6-11">3.4.6.11</a> actually gives us the objects and morphisms of a category, say, the <em>category of A-indexed sets</em>, in that it tells us that the objects and morphisms are merely the <em>A</em>-indexed sets and the <em>A</em>-indexed functions. Let us denote the category of <em>A</em>-indexed sets <em>A</em>&#x2013;<strong>Set</strong>; this exercise is asking for a category <epub:switch id="mathmlSwitch887"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>A</mi></math></epub:case><epub:default></epub:default></epub:switch> for which there is an isomorphism</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch888"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi><mo>&#x2212;</mo><mtext mathvariant="bold">Set</mtext><mover><mo>&#x2192;</mo><mrow><mo>&#x00A0;</mo><mo>&#x2245;</mo><mo>&#x00A0;</mo></mrow></mover><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>A</mi><mo>,</mo><mtext mathvariant="bold">Set</mtext><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">And indeed there is. Let <epub:switch id="mathmlSwitch889"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>A</mi><mo>=</mo><mtext mathvariant="italic">Disc</mtext><mo stretchy='false'>(</mo><mi>A</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be the discrete category on <em>A</em> objects. Then a functor <epub:switch id="mathmlSwitch890"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>S</mi><mo>:</mo><mi mathvariant='script'>A</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> is just a set <em>S</em>(<em>a</em>) for every <em>a</em> &#x2208; <em>A</em>, and a morphism <em>S</em> &#x2192; <em>S</em>&#x2032; is just a component <em>f<sub>a</sub></em> : <em>S</em>(<em>a</em>) &#x2192; <em>S</em>&#x2032;(<em>a</em>) for each <em>a</em> &#x2208; <em>A</em>. These coincide exactly with the notions of <em>A</em>-indexed set and of mappings between them.</p>

<p>For a general schema (or category) <epub:switch id="mathmlSwitch891"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, let us think through what a morphism <em>&#x03B1;</em> : <em>I</em> &#x2192; <em>J</em> between instances <epub:switch id="mathmlSwitch892"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>I</mi><mo>,</mo><mi>J</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> is. For each object <epub:switch id="mathmlSwitch893"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, there is a component <em>&#x03B1;<sub>c</sub></em> : <em>I</em>(<em>c</em>) &#x2192; <em>J</em>(<em>c</em>). This means that just as in Example <a href="chapter005.html#Exa_5-3-3-3">5.3.3.3</a>, there is for each table <em>c</em> a function from the rows in <em>I</em>&#x2019;s manifestation of <em>c</em> to the rows in <em>J</em>&#x2019;s manifestation of <em>c</em>. So to make a natural transformation, such a function has to be specified table by table. But then we have to contend with naturality squares, one for every arrow in <epub:switch id="mathmlSwitch894"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>. Arrows in <epub:switch id="mathmlSwitch895"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> correspond to foreign key columns in the database. The naturality requirement was already covered in Application <a href="chapter005.html#App_5-3-1-12">5.3.1.12</a> (see especially how (<a href="chapter005.html#eq_5-11">5.11</a>) is checked in (<a href="chapter005.html#eq_5-12">5.12</a>) and (<a href="chapter005.html#eq_5-13">5.13</a>)).</p>
<p class="noindent1-top-exe" id="Exa_5-3-3-5"><em>Example</em> 5.3.3.5. We saw in Section <a href="chapter005.html#lev_5-2-1-21">5.2.1.21</a> that graphs can be regarded as functors <epub:switch id="mathmlSwitch896"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>G</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, where <epub:switch id="mathmlSwitch897"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>G</mi><mo>&#x2245;</mo><mtext mathvariant='bold'>GrIn</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> is the schema for graphs shown here:</p>
<p class="fig-img"><img src="images/Art_P210.jpg" alt="art"/></p>

<a id="p233"></a>
<p>A database instance <epub:switch id="mathmlSwitch898"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>G</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> on <epub:switch id="mathmlSwitch899"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>G</mi></math></epub:case><epub:default></epub:default></epub:switch> consists of two tables. Here is an example instance:</p>
<p class="fig-img"><img src="images/Art_P211.jpg" alt="art"/></p>
<p class="noindent">To discuss natural transformations, we need two instances. Here is another, <epub:switch id="mathmlSwitch900"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>J</mi><mo>:</mo><mi mathvariant='script'>G</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>:</p>
<p class="fig-img"><img src="images/Art_P212.jpg" alt="art"/></p>
<p class="noindent">To give a natural transformation <em>&#x03B1;</em> : <em>I</em> &#x2192; <em>J</em>, we give two components: one for <span class="font1">Arrow</span> and one for <span class="font1">Vertex</span>. We need to say where each vertex in <em>I</em> goes in <em>J</em>, and we need to say where each arrow in <em>I</em> goes in <em>J</em>. The naturality squares insist that if we specify that <em>g</em> &#x21A6; <em>j</em>, for example, then we had better specify that <em>w</em> &#x21A6; <em>r</em> and that <em>x</em> &#x21A6; <em>s</em>. What a computer is very good at, but a human is fairly slow at, is checking that a given pair of components (arrows and vertices) really is natural.</p>
<p>There are 8000 ways to devise component functions <em>&#x03B1;</em><sub><span class="font1">Arrow</span></sub> and <em>&#x03B1;</em><sub><span class="font1">Vertex</span></sub>, but precisely six natural transformations, i.e., six graph homomorphisms, <em>I</em> &#x2192; <em>J</em>; the other 7,994 are haphazard flingings of arrows to arrows and vertices to vertices without any regard to sources and targets. The six are briefly described now. The reader should look at the graph diagrams of <em>I</em> and <em>J</em> while following along.</p>
<p>Every vertex in <em>I</em> has to be sent to some vertex in <em>J</em>, so we think about where to send <em>v</em> and proceed from there.</p>
<ul class="ulindent">
<li>If we try to send <em>v</em> &#x21A6;<sup>?</sup> <em>u</em>, we fail because <em>u</em> touches no arrows, so there is nowhere for <em>f</em> to go. (0)</li>
<li class="litop"><a id="p234"></a>If we send <em>v</em> &#x21A6; <em>q</em>, then <em>f</em> must map to <em>i</em>, and <em>w</em> must map to <em>r</em>, and both <em>g</em> and <em>h</em> must map to <em>j</em>, and <em>x</em> must map to <em>s</em>. (1)</li>
<li class="litop">If we send <em>v</em> &#x21A6; <em>r</em>, then there are two choices for <em>g</em> times two choices for <em>h</em>. (4)</li>
<li class="litop">If we send <em>v</em> &#x21A6; <em>s</em>, then there is one way to obtain a graph morphism. (1)</li>
<li class="litop">If we try to send <em>v</em> &#x21A6;<sup>?</sup> <em>t</em>, we fail as before. (0)</li>
</ul>
<p class="noindent">Humans may follow the diagrams better than the tables, whereas computers probably understand the tables better.</p>
<p class="noindent1-top-exe" id="Exe_5-3-3-6"><em>Exercise</em> 5.3.3.6.</p>
<p>If <epub:switch id="mathmlSwitch901"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>I</mi><mo>,</mo><mi>J</mi><mo>:</mo><mi mathvariant='script'>G</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, as in Example <a href="chapter005.html#Exa_5-3-3-5">5.3.3.5</a>, how many natural transformations are there <em>J</em> &#x2192; <em>I</em>?</p>
<p class="noindent1-top-exe" id="Exe_5-3-3-7"><em>Exercise</em> 5.3.3.7.</p>
<p>Let <strong>GrIn</strong> be the graph-indexing category, and let <em>Y<sub>A</sub></em> : <strong>GrIn</strong> &#x2192; <strong>Set</strong> denote the following instance:</p>
<p class="fig-img"><img src="images/Art_P213.jpg" alt="art"/></p>
<p class="noindent">Let <em>I</em> : <strong>GrIn</strong> &#x2192; <strong>Set</strong> be as in Example <a href="chapter005.html#Exa_5-3-3-5">5.3.3.5</a>.</p>
<p class="nl1-list">a. How many natural transformations are there <em>Y<sub>A</sub></em> &#x2192; <em>I</em>?</p>
<p class="nl1-list">b. With <em>J</em> as previously, how many natural transformations are there <em>Y<sub>A</sub></em> &#x2192; <em>J</em>?</p>
<p class="nl1-list">c. Do you have any conjecture about the way natural transformations <em>Y<sub>A</sub></em> &#x2192; <em>X</em> behave for arbitrary graphs <epub:switch id="mathmlSwitch902"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi><mo>:</mo><mi mathvariant='script'>G</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>?</p>

<p class="noindent1-top-sol"><em>Solution</em> 5.3.3.7.</p>
<p>It is useful to see <em>Y<sub>A</sub></em> as a graph so we can visualize the graph morphisms <em>Y<sub>A</sub></em> &#x2192; <em>I</em> or <em>Y<sub>A</sub></em> &#x2192; <em>J</em>.</p>
<p class="fig-img"><img src="images/Art_P214.jpg" alt="art"/></p>
<a id="p235"></a>
<p class="nl1-list">a. A graph morphism <em>Y<sub>A</sub></em> &#x2192; <em>I</em> amounts to an arrow in graph <em>I</em>. In other words, there is a natural isomorphism</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch903"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Nat</mtext><mo stretchy='false'>(</mo><msub><mi>Y</mi><mi>A</mi></msub><mo>,</mo><mi>I</mi><mo stretchy='false'>)</mo><mo>&#x2245;</mo><mo>&#x007B;</mo><mi>f</mi><mo>,</mo><mi>g</mi><mo>,</mo><mi>h</mi><mo>&#x007D;</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="nl1-list-para">How does this works? What might <em>g</em> mean as a natural transformation <em>Y<sub>A</sub></em> &#x2192; <em>I</em>?</p>
<p class="nl1-list-para">To give a questionably natural transformation <em>&#x03B1;</em> : <em>Y<sub>A</sub></em> &#x2192; <em>I</em>, we need to give a component <em>&#x03B1;<sub>Ar</sub></em> : {<em>a</em>} &#x2192; {<em>f</em>, <em>g</em>, <em>h</em>} and a component <em>&#x03B1;<sub>Ve</sub></em> : {<em>v</em><sub>0</sub>, <em>v</em><sub>1</sub>} &#x2192; {<em>v</em>, <em>w</em>, <em>x</em>}. Since we have <em>g</em> in mind, let&#x2019;s put <em>&#x03B1;<sub>Ar</sub></em>(<em>a</em>) &#x2254; <em>g</em>. There are 3<sup>2</sup> choices for <em>&#x03B1;<sub>Ve</sub></em>, but only one is natural because the two morphisms <em>src</em>, <em>tgt</em> : <em>Ar</em> &#x2192; <em>Ve</em> demand two naturality equations,</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch904"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable columnalign='left'><mtr><mtd><msub><mi>&#x03B1;</mi><mrow><mi>V</mi><mi>e</mi></mrow></msub><mo stretchy='false'>(</mo><msub><mi>v</mi><mn>0</mn></msub><mo stretchy='false'>)</mo><mo>=</mo><msub><mi>&#x03B1;</mi><mrow><mi>V</mi><mi>e</mi></mrow></msub><mo>&#x25CB;</mo><mi>s</mi><mi>r</mi><mi>c</mi><mo stretchy='false'>(</mo><mi>a</mi><mo stretchy='false'>)</mo><mo>=</mo><mi>s</mi><mi>r</mi><mi>c</mi><mo>&#x25CB;</mo><msub><mi>&#x03B1;</mi><mrow><mi>A</mi><mi>r</mi></mrow></msub><mo stretchy='false'>(</mo><mi>a</mi><mo stretchy='false'>)</mo><mo>=</mo><mi>s</mi><mi>r</mi><mi>c</mi><mo stretchy='false'>(</mo><mi>g</mi><mo stretchy='false'>)</mo><mo>=</mo><mi>w</mi><mo>;</mo></mtd></mtr><mtr><mtd><msub><mi>&#x03B1;</mi><mrow><mi>V</mi><mi>e</mi></mrow></msub><mo stretchy='false'>(</mo><msub><mi>v</mi><mn>1</mn></msub><mo stretchy='false'>)</mo><mo>=</mo><msub><mi>&#x03B1;</mi><mrow><mi>V</mi><mi>e</mi></mrow></msub><mo>&#x25CB;</mo><mtext mathvariant="italic">tgt</mtext><mo stretchy='false'>(</mo><mi>a</mi><mo stretchy='false'>)</mo><mo>=</mo><mtext mathvariant="italic">tgt</mtext><mo>&#x25CB;</mo><msub><mi>&#x03B1;</mi><mrow><mi>A</mi><mi>r</mi></mrow></msub><mo stretchy='false'>(</mo><mi>a</mi><mo stretchy='false'>)</mo><mo>=</mo><mtext mathvariant="italic">tgt</mtext><mo stretchy='false'>(</mo><mi>g</mi><mo stretchy='false'>)</mo><mo>=</mo><mi>x</mi><mo>.</mo></mtd></mtr></mtable></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="nl1-list-para">In other words, once we choose <em>&#x03B1;<sub>Ar</sub></em>(<em>a</em>) to be <em>g</em>, the rest is forced on us. In the same way, we could have chosen <em>&#x03B1;<sub>Ar</sub></em>(<em>a</em>) to be any of <em>f</em>, <em>g</em>, <em>h</em>, which is why we said Nat(<em>Y<sub>A</sub></em>, <em>I</em>) &#x2245; {<em>f</em>, <em>g</em>, <em>h</em>}.</p>
<p class="nl1-list">b. There are four, Nat(<em>Y<sub>A</sub></em>, <em>J</em>) &#x2245; {<em>i</em>, <em>j</em>, <em>k</em>, <em>&#x2113;</em>}.</p>
<p class="space-break-top">In terms of databases, this notion of instance morphism <em>&#x03B1;</em> : <em>I</em> &#x2192; <em>J</em> on a schema <epub:switch id="mathmlSwitch905"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> is sometimes called a <em>database homomorphism</em>. It is related to what is known as <em>provenance</em>, in that it tells us how every row in <em>I</em> relates to a counterpart row in <em>J</em>. More precisely, for every table in <epub:switch id="mathmlSwitch906"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, the morphism <em>&#x03B1;</em> gives a mapping from the set of rows in <em>I</em>&#x2019;s version of the table to <em>J</em>&#x2019;s version of the table, such that all the foreign keys are respected. This notion of morphism has excellent formal properties, so projections, unions, and joins of tables (the typical database operations) would be predicted to be interesting by a category theorist who has no idea what a database is.<sup><a id="endnote_ref_15" href="chapter005.html#endnote_15">15</a></sup></p>

</section>


<section title="Equivalence of categories">
<h2 class="level2" id="lev_5-3-4"><strong>5.3.4&#160;&#160;&#160;Equivalence of categories</strong></h2>
<p class="noindent">We have a category <strong>Cat</strong> of categories, and in every category there is a notion of isomorphism between objects: one morphism each way, such that each round-trip composition is the identity. An isomorphism in <strong>Cat</strong>, therefore, takes place between two categories, say, <epub:switch id="mathmlSwitch907"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch908"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch>: it is a functor <epub:switch id="mathmlSwitch909"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and a functor <epub:switch id="mathmlSwitch910"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>G</mi><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> such that <epub:switch id="mathmlSwitch911"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>G</mi><mo>&#x25CB;</mo><mi>F</mi><mo>=</mo><msub><mrow><mtext>id</mtext></mrow><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch912"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>&#x25CB;</mo><mi>G</mi><mo>=</mo><msub><mrow><mtext>id</mtext></mrow><mi mathvariant='script'>D</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p>It turns out that categories are often similar enough to be considered equivalent without being isomorphic. For this reason, the notion of isomorphism is considered too <a id="p236"></a>strong to be useful for categories, akin to saying that two material samples are the same if there is an atom by atom matching, or that two words are the same if they are written in the same font and size, by the same person, in the same state of mind.</p>
<p>As reasonable as isomorphism is as a notion <em>in</em> most categories, it fails to be the right notion <em>about</em> categories. The reason is that <em>in</em> categories there are objects and morphisms, whereas when we talk <em>about</em> categories, we have categories and functors plus natural transformations. Natural transformations serve as mappings between mappings, and this is not part of the structure of an ordinary category. In cases where a category <epub:switch id="mathmlSwitch913"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> does have such mappings between mappings, it is often best to take that extra structure into account, as we do for <epub:switch id="mathmlSwitch914"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='script'>C</mi><mo>=</mo><mtext mathvariant='bold'>Cat</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>. This whole subject leads to the study of 2-categories (or <em>n</em>-categories, or &#x221E;-categories), not discussed in this book. See, for example, Leinster [25] for an introduction.</p>
<p>The purpose now is to explain this &#x201C;good notion&#x201D; of sameness for categories, namely, <em>equivalence of categories</em>, which appropriately takes natural transformations into account. Instead of functors going both ways with round-trips equal to identity, which is required in order to be an isomorphism of categories, equivalence of categories demands functors going both ways with roundtrips <em>naturally isomorphic</em> to identity.</p>
<p class="noindent1-top-def" id="Def_5-3-4-1"><strong>Definition 5.3.4.1</strong> (Equivalence of categories). Let <epub:switch id="mathmlSwitch915"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch916"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></math></epub:case><epub:default></epub:default></epub:switch> be categories. A functor <epub:switch id="mathmlSwitch917"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is called <em>an equivalence of categories</em> and denoted <epub:switch id="mathmlSwitch918"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mover><mo>&#x2192;</mo><mo>&#x2243;</mo></mover><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch><sup><a id="endnote_ref_16" href="chapter005.html#endnote_16">16</a></sup> if there exists a functor <epub:switch id="mathmlSwitch919"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>&#x2032;</mo><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and natural isomorphisms <epub:switch id="mathmlSwitch920"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>&#x03B1;</mi><mo>:</mo><msub><mrow><mtext>id</mtext></mrow><mi mathvariant='script'>C</mi></msub><mover><mo>&#x2192;</mo><mrow><mo>&#x00A0;</mo><mo>&#x2245;</mo><mo>&#x00A0;</mo></mrow></mover><mi>F</mi><mo>&#x2032;</mo><mo>&#x25CB;</mo><mi>F</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch921"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>&#x03B1;</mi><mo>&#x2032;</mo><mo>:</mo><msub><mrow><mtext>id</mtext></mrow><mrow><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></mrow></msub><mover><mo>&#x2192;</mo><mrow><mo>&#x00A0;</mo><mo>&#x2245;</mo><mo>&#x00A0;</mo></mrow></mover><mi>F</mi><mo>&#x25CB;</mo><mi>F</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. In this case we say that <em>F</em> and <em>F</em>&#x2032; are <em>mutually inverse equivalences</em>.</p>
<p class="space-break">Suppose we are given functors <epub:switch id="mathmlSwitch922"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch923"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>&#x2032;</mo><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>. We want to know something about the round-trips on <epub:switch id="mathmlSwitch924"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> and on <epub:switch id="mathmlSwitch925"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></math></epub:case><epub:default></epub:default></epub:switch>; we want to know the same kind of information about each round-trip, so let&#x2019;s concentrate on the <epub:switch id="mathmlSwitch926"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> side. We want to know something about <epub:switch id="mathmlSwitch927"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>&#x2032;</mo><mo>&#x25CB;</mo><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, so let&#x2019;s name it <epub:switch id="mathmlSwitch928"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>i</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>; we want to know that <em>i</em> is a natural isomorphism. That is, for every <epub:switch id="mathmlSwitch929"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we want an isomorphism <epub:switch id="mathmlSwitch930"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mi>&#x03B1;</mi><mi>c</mi></msub><mo>:</mo><mi>c</mi><mover><mo>&#x2192;</mo><mrow><mo>&#x00A0;</mo><mo>&#x2245;</mo><mo>&#x00A0;</mo></mrow></mover><mi>i</mi><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and we want to know that these isomorphisms are picked carefully enough that given <em>g</em> : <em>c</em> &#x2192; <em>c</em>&#x2032; in <epub:switch id="mathmlSwitch931"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, the choice of isomorphisms for <em>c</em> and <em>c</em>&#x2032; are compatible:</p>
<p class="fig-img"><img src="images/Art_P215.jpg" alt="art"/></p>
<p class="noindent">To be an equivalence, the same has to hold for the other round-trip, <epub:switch id="mathmlSwitch932"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>i</mi><mo>&#x2032;</mo><mo>=</mo><mi>F</mi><mo>&#x25CB;</mo><mi>F</mi><mo>&#x2032;</mo><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<a id="p237"></a>
<p class="noindent1-top-exe" id="Exe_5-3-4-2"><em>Exercise</em> 5.3.4.2.</p>
<p>Let <epub:switch id="mathmlSwitch933"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch934"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></math></epub:case><epub:default></epub:default></epub:switch>
be categories. Suppose that <epub:switch id="mathmlSwitch935"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is an isomorphism of categories.</p>
<p class="nl1-list">a. Is it an equivalence of categories?</p>
<p class="nl1-list">b. If not, why? If so, what are the components of <em>&#x03B1;</em> and <em>&#x03B1;</em>&#x2032; (with notation as in Definition <a href="chapter005.html#Def_5-3-4-1">5.3.4.1</a>)?</p>
<p class="noindent1-top-sol"><em>Solution</em> 5.3.4.2.</p>
<p class="nl1-list">a. Yes.</p>
<p class="nl1-list">b. If a functor <epub:switch id="mathmlSwitch936"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is an isomorphism of categories, then there exists a functor <epub:switch id="mathmlSwitch937"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>&#x2032;</mo><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> such that <epub:switch id="mathmlSwitch938"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>&#x2032;</mo><mo>&#x25CB;</mo><mi>F</mi><mo>=</mo><msub><mrow><mtext>id</mtext></mrow><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch939"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>&#x25CB;</mo><mi>F</mi><mo>&#x2032;</mo><mo>=</mo><msub><mrow><mtext>id</mtext></mrow><mrow><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></mrow></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>. We might hope that <em>F</em> and <em>F</em>&#x2032; are mutually inverse equivalences of categories as well. We need natural transformations <epub:switch id="mathmlSwitch940"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>&#x03B1;</mi><mo>:</mo><msub><mrow><mtext>id</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo>&#x2192;</mo><mi>F</mi><mo>&#x2032;</mo><mo>&#x25CB;</mo><mi>F</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch941"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>&#x03B1;</mi><mo>&#x2032;</mo><mo>:</mo><msub><mrow><mtext>id</mtext></mrow><mrow><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></mrow></msub><mo>&#x2192;</mo><mi>F</mi><mo>&#x25CB;</mo><mi>F</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. But since <epub:switch id="mathmlSwitch942"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>&#x2032;</mo><mo>&#x25CB;</mo><mi>F</mi><mo>=</mo><msub><mrow><mtext>id</mtext></mrow><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch943"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>&#x25CB;</mo><mi>F</mi><mo>&#x2032;</mo><mo>=</mo><msub><mrow><mtext>id</mtext></mrow><mrow><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></mrow></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we can take <em>&#x03B1;</em> and <em>&#x03B1;</em>&#x2032; to be the identity transformations. Thus <em>F</em> and <em>F</em>&#x2032; are indeed mutually inverse equivalences of categories.</p>
<p class="noindent1-top-exe" id="Exa_5-3-4-3"><em>Example</em> 5.3.4.3. Let <em>S</em> be a set, and let <em>S</em> &#x00D7; <em>S</em> &#x2286; <em>S</em> &#x00D7; <em>S</em> be the complete relation on <em>S</em>, which is a preorder <em>K<sub>S</sub></em>. Recall from Proposition <a href="chapter005.html#Pro_5-2-1-13">5.2.1.13</a> that there is a functor <em>i</em> : <strong>PrO</strong> &#x2192; <strong>Cat</strong>, and the resulting category <em>i</em>(<em>K<sub>S</sub></em>) is called the <em>indiscrete category on S</em>; it has objects <em>S</em> and a single morphism between every pair of objects. Here is a diagram of <em>K</em><sub>{1,2,3}</sub>:</p>
<p class="fig-img" id="eq_5-15"><img src="images/Art_P216.jpg" alt="art"/></p>

<p>It is easy check that <em>K</em><sub><span class="underline">1</span></sub>, the indiscrete category on one element, is isomorphic to <span class="underline">1</span>, the discrete category on one object, also known as the terminal category (see Exercise <a href="chapter005.html#Exe_5-1-2-40">5.1.2.40</a>). The category <span class="underline">1</span> consists of one object, its identity morphism, and nothing else. Let&#x2019;s think about the difference between isomorphism and equivalence using <em>K<sub>S</sub></em> &#x2208; Ob(<strong>Cat</strong>).</p>
<a id="p238"></a>
<p>The only way that <em>K<sub>S</sub></em> can be isomorphic to <span class="underline">1</span> is if <em>S</em> has one element.<sup><a id="endnote_ref_17" href="chapter005.html#endnote_17">17</a></sup> On the other hand, there is an equivalence of categories</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch944"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mi>K</mi><mi>S</mi></msub><mo>&#x2243;</mo><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">for every set <em>S</em> &#x2260; &#x2205;. So for example, <em>K</em><sub>{1,2,3}</sub> from (<a href="chapter005.html#eq_5-15">5.15</a>) is equivalent to the terminal category, <span class="underline">1</span>.</p>
<p>In fact, there are many such equivalences, one for each element of <em>S</em>. To see this, let <em>S</em> be a nonempty set, and choose an element <em>s</em><sub>0</sub> &#x2208; <em>S</em>. For every <em>s</em> &#x2208; <em>S</em>, there is a unique isomorphism <epub:switch id="mathmlSwitch945"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mi>k</mi><mi>s</mi></msub><mo>:</mo><mi>s</mi><mover><mo>&#x2192;</mo><mrow><mo>&#x00A0;</mo><mo>&#x2245;</mo><mo>&#x00A0;</mo></mrow></mover><msub><mi>s</mi><mn>0</mn></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> in <em>K<sub>S</sub></em>. Let <em>F</em> : <em>K<sub>S</sub></em> &#x2192; <span class="underline">1</span> be the only possible functor (see Exercise <a href="chapter005.html#Exe_5-1-2-40">5.1.2.40</a>), and let <em>F</em>&#x2032; : <span class="underline">1</span> &#x2192; <em>K<sub>S</sub></em> represent the object <em>s</em><sub>0</sub>. Note that <em>F</em>&#x2032; &#x25CB; <em>F</em> &#x003D; id<sub><span class="underline">1</span></sub> : <span class="underline">1</span> &#x2192; <span class="underline">1</span> is the identity, but that <em>F</em> &#x25CB; <em>F</em>&#x2032; : <em>K<sub>S</sub></em> &#x2192; <em>K<sub>S</sub></em> sends everything to <em>s</em><sub>0</sub>. So <em>F</em> is not an isomorphism. We need to show that it is an equivalence.</p>
<p>Let <em>&#x03B1;</em> &#x003D; id<sub><span class="underline">1</span></sub>, and define <epub:switch id="mathmlSwitch946"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>&#x03B1;</mi><mo>&#x2032;</mo><mo>:</mo><msub><mrow><mtext>id</mtext></mrow><mrow><msub><mi>K</mi><mi>S</mi></msub></mrow></msub><mo>&#x2192;</mo><mi>F</mi><mo>&#x25CB;</mo><mi>F</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> by <epub:switch id="mathmlSwitch947"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mi>&#x03B1;</mi><mi>s</mi><mo>&#x2032;</mo></msubsup><mo>=</mo><msub><mi>k</mi><mi>s</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Note that <epub:switch id="mathmlSwitch948"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mi>&#x03B1;</mi><mi>s</mi><mo>&#x2032;</mo></msubsup></mrow></math></epub:case><epub:default></epub:default></epub:switch> is an isomorphism for each <em>s</em> &#x2208; Ob(<em>K<sub>S</sub></em>) and that <em>&#x03B1;</em>&#x2032; is a natural transformation (hence, a natural isomorphism) because every possible square commutes in <em>K<sub>S</sub></em>. This completes the proof, initiated in the preceding paragraph, that the category <em>K<sub>S</sub></em> is equivalent to <span class="underline">1</span> for every nonempty set <em>S</em> and that this fact can be witnessed by any element <em>s</em><sub>0</sub> &#x2208; <em>S</em>.</p>
<p class="noindent1-top-exe" id="Exa_5-3-4-4"><em>Example</em> 5.3.4.4. Consider the category <strong>FLin</strong>, described in Example <a href="chapter005.html#Exa_5-1-1-13">5.1.1.13</a>, of finite nonempty linear orders. For every natural number <em>n</em> &#x2208; &#x2115;, let [<em>n</em>] &#x2208; Ob(<strong>FLin</strong>) denote the linear order shown in Example <a href="chapter004.html#Exa_4-4-1-7">4.4.1.7</a>. Define a category <strong>&#x0394;</strong> whose objects are given by Ob(<strong>&#x0394;</strong>) &#x003D; {[<em>n</em>] &#x007C; <em>n</em> &#x2208; &#x2115;} and with Hom<strong><sub>&#x0394;</sub></strong>([<em>m</em>], [<em>n</em>]) &#x003D; Hom<strong><sub>FLin</sub></strong>([<em>m</em>], [<em>n</em>]). The difference between <strong>FLin</strong> and <strong>&#x0394;</strong> is only that objects in <strong>FLin</strong> may have odd labels, e.g.,</p>
<p class="disp-eq-no"><epub:switch id="mathmlSwitch949"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover><mo>&#x2022;</mo><mn>5</mn></mover><mover><mo stretchy="true">&#x2192;</mo><mrow><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo></mrow></mover><mover><mo>&#x2022;</mo><mi>x</mi></mover><mover><mo stretchy="true">&#x2192;</mo><mrow><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo></mrow></mover><mover><mo>&#x2022;</mo><mrow><mo>&#x201C;</mo><mi>S</mi><mi>a</mi><mi>m</mi><mo>&#x201D;</mo></mrow></mover></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">whereas objects in <strong>&#x0394;</strong> all have standard labels, e.g.,</p>
<p class="disp-eq-no"><epub:switch id="mathmlSwitch950"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover><mo>&#x2022;</mo><mn>0</mn></mover><mover><mo stretchy="true">&#x2192;</mo><mrow><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo></mrow></mover><mover><mo>&#x2022;</mo><mn>1</mn></mover><mover><mo stretchy="true">&#x2192;</mo><mrow><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo></mrow></mover><mover><mo>&#x2022;</mo><mn>2</mn></mover></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">Clearly, <strong>FLin</strong> is a much larger category, and yet it feels as if it is pretty much the same as <strong>&#x0394;</strong>. Actually, they are equivalent, <strong>FLin</strong> &#x2243; <strong>&#x0394;</strong>. We will find functors <em>F</em> and <em>F</em>&#x2032; which witness this equivalence.</p>

<p>Let <em>F</em>&#x2032; : <strong>&#x0394;</strong> &#x2192; <strong>FLin</strong> be the inclusion; and let <em>F</em> : <strong>FLin</strong> &#x2192; <strong>&#x0394;</strong> send every finite nonempty linear order <em>X</em> &#x2208; Ob(<strong>FLin</strong>) to the object <em>F</em>(<em>X</em>) &#x2254; [<em>n</em>] &#x2208; <strong>&#x0394;</strong>, where Ob(<em>X</em>) &#x2245; {0, 1, &#x2026; , <em>n</em>}. <a id="p239"></a>For each such <em>X</em>, there is a unique isomorphism <em>&#x03B1;<sub>X</sub></em> : <epub:switch id="mathmlSwitch951"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi><mover><mo>&#x2192;</mo><mo>&#x2245;</mo></mover><mo stretchy='false'>[</mo><mi>n</mi><mo stretchy='false'>]</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>
, and these fit together into<sup><a id="endnote_ref_18" href="chapter005.html#endnote_18">18</a></sup> the required natural isomorphism id<strong><sub>FLin</sub></strong> &#x2192; <em>F</em>&#x2032; &#x25CB; <em>F</em>. The other natural isomorphism <em>&#x03B1;</em>&#x2032; : id<strong><sub>&#x0394;</sub></strong> &#x2192; <em>F</em> &#x25CB; <em>F</em>&#x2032; is the identity.</p>
<p class="noindent1-top-exe" id="Exe_5-3-4-5"><em>Exercise</em> 5.3.4.5.</p>
<p>Recall from Definition <a href="chapter002.html#Def_2-1-2-23">2.1.2.23</a> that a set <em>X</em> is called finite if there exists a natural number <em>n</em> &#x2208; &#x2115; and an isomorphism of sets <em>X</em> &#x2192; <em><span class="underline">n</span></em>. Let <strong>Fin</strong> denote the category whose objects are the finite sets and whose morphisms are the functions. Let <epub:switch id="mathmlSwitch952"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>S</mi></math></epub:case><epub:default></epub:default></epub:switch> denote the category whose objects are the sets <em><span class="underline">n</span></em> and whose morphisms are again the functions. The difference between <strong>Fin</strong> and <epub:switch id="mathmlSwitch953"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>S</mi></math></epub:case><epub:default></epub:default></epub:switch> is that every object in <epub:switch id="mathmlSwitch954"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>S</mi></math></epub:case><epub:default></epub:default></epub:switch> is one of these <em><span class="underline">n</span></em>&#x2019;s, whereas every object in <strong>Fin</strong> is just isomorphic to one of these <em><span class="underline">n</span></em>&#x2019;s.</p>
<p>For every object <em>X</em> &#x2208; Ob(<strong>Fin</strong>), there exists an isomorphism <em>p<sub>X</sub></em> : <epub:switch id="mathmlSwitch955"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>X</mi><mover><mo>&#x2192;</mo><mo>&#x2245;</mo></mover><munder accentunder='true'><mi>m</mi><mo>&#x00AF;</mo></munder></mrow></math></epub:case><epub:default></epub:default></epub:switch> for some unique object <epub:switch id="mathmlSwitch956"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><munder accentunder='true'><mi>m</mi><mo>&#x00AF;</mo></munder><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy="false">(</mo><mi mathvariant='script'>S</mi><mo stretchy="false">)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Find an equivalence of categories <epub:switch id="mathmlSwitch957"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mstyle mathvariant='bold' mathsize='normal'><mi>F</mi><mi>i</mi><mi>n</mi></mstyle><mover><mo>&#x2192;</mo><mo>&#x2243;</mo></mover><mi mathvariant='script'>S</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>

<p class="noindent1-top-exe" id="Exe_5-3-4-6"><em>Exercise</em> 5.3.4.6.</p>
<p>We say that two categories <epub:switch id="mathmlSwitch958"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch959"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> are equivalent if there exists an equivalence of categories between them. Show that the relation of being equivalent is an equivalence relation on Ob(<strong>Cat</strong>).</p>

<p class="noindent1-top1" id="Exa_5-3-4-7"><em>Example</em> 5.3.4.7. Consider the group &#x2124;<sub>2</sub> &#x2254; ({0, 1}, 0, &#x002B;), where 1 &#x002B; 1 &#x003D; 0. As a category, &#x2124;<sub>2</sub> has one object &#x25B2; and two morphisms, namely, 0, 1, such that 0 is the identity. Since &#x2124;<sub>2</sub> is a group, every morphism is an isomorphism.</p>
<p>Let <epub:switch id="mathmlSwitch960"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi mathvariant='script'>C</mi><mo>=</mo><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder></mrow></math></epub:case><epub:default></epub:default></epub:switch> be the terminal category, as in Exercise <a href="chapter005.html#Exe_5-1-2-40">5.1.2.40</a>. One might accidentally believe that <epub:switch id="mathmlSwitch961"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> is equivalent to &#x2124;<sub>2</sub>, but this is not the case. The argument in favor of the accidental belief is that we have unique functors <epub:switch id="mathmlSwitch962"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>F</mi><mo>:</mo><msub><mi>&#x2124;</mi><mn>2</mn></msub><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch963"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>F</mi><mo>&#x2032;</mo><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><msub><mi>&#x2124;</mi><mn>2</mn></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> (and this is true); the round-trip <epub:switch id="mathmlSwitch964"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>F</mi><mo>&#x25CB;</mo><mi>F</mi><mo>&#x2032;</mo><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is the identity (and this is true); and for the round-trip <em>F</em>&#x2032; &#x25CB; <em>F</em> : &#x2124;<sub>2</sub> &#x2192; &#x2124;<sub>2</sub> both morphisms in &#x2124;<sub>2</sub> are isomorphisms, so any choice of morphism <em>&#x03B1;</em><sub>&#x25B2;</sub>: &#x25B2; &#x2192; <em>F</em>&#x2032; &#x25CB; <em>F</em>(&#x25B2;) will be an isomorphism (and this is true). The problem is that whatever one does with <em>&#x03B1;</em><sub>&#x25B2;</sub>, one gets a questionably natural isomorphism, but it will never be natural.</p>
<p>When we round-trip <em>F</em>&#x2032; &#x25CB; <em>F</em> : &#x2124;<sub>2</sub> &#x2192; &#x2124;<sub>2</sub>, the image of 1: &#x25B2; &#x2192; &#x25B2; is <em>F</em>&#x2032; &#x25CB; <em>F</em>(1) &#x003D; 0 &#x003D; id<sub>&#x25B2;</sub>. So the naturality square for the morphism 1 looks like this:</p>
<p class="fig-img"><img src="images/Art_P217.jpg" alt="art"/></p>
<a id="p240"></a>
<p class="noindent">where it is undecided whether <em>&#x03B1;</em><sub>&#x25B2;</sub> is to be 0 or 1. Unfortunately, neither choice works (i.e., for neither choice will the diagram commute) because <em>x</em> &#x002B; 1 &#x2260; <em>x</em> &#x002B; 0 in &#x2124;<sub>2</sub>.</p>
<p class="noindent1-top-def" id="Def_5-3-4-8"><strong>Definition 5.3.4.8</strong> (Full and faithful functors). Let <epub:switch id="mathmlSwitch965"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch966"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> be categories, and let <epub:switch id="mathmlSwitch967"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> be a functor. For any two objects <epub:switch id="mathmlSwitch968"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>c</mi><mo>,</mo><mi>c</mi><mo>&#x2032;</mo><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy="false">(</mo><mi mathvariant='script'>C</mi><mo stretchy="false">)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, there is a function</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch969"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><msub><mrow><mtext>Hom</mtext></mrow><mi>F</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>c</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>c</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>D</mi></msub><mo stretchy='false'>(</mo><mi>F</mi><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>,</mo><mi>F</mi><mo stretchy='false'>(</mo><mi>c</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">guaranteed by the definition of functor. We say that <em>F</em> is <em>a full functor</em> if Hom<em><sub>F</sub></em>(<em>c</em>, <em>c</em>&#x2032;) is surjective for every <epub:switch id="mathmlSwitch970"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>c</mi><mo>,</mo><mi>c</mi><mo>&#x2032;</mo><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy="false">(</mo><mi mathvariant='script'>C</mi><mo stretchy="false">)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. We say that <em>F</em> is <em>a faithful functor</em> if Hom<em><sub>F</sub></em>(<em>c</em>, <em>c</em>&#x2032;) is injective for every <em>c</em>, <em>c</em>&#x2032;. We say that <em>F</em> is <em>a fully faithful functor</em> if Hom<em><sub>F</sub></em>(<em>c</em>, <em>c</em>&#x2032;) is bijective for every <em>c</em>, <em>c</em>&#x2032;.</p>
<p class="noindent1-top-exe" id="Exe_5-3-4-9"><em>Exercise</em> 5.3.4.9.</p>
<p>Let <span class="underline">1</span> and <span class="underline">2</span> be the discrete categories on one and two objects respectively. There is only one functor <em>F</em> : <span class="underline">2</span> &#x2192; <span class="underline">1</span>.</p>

<p class="nl1-list">a. Is it full?</p>
<p class="nl1-list">b. Is it faithful?</p>
<p class="noindent1-top-exe" id="Exe_5-3-4-10"><em>Exercise</em> 5.3.4.10.</p>
<p>Let <span class="underline">0</span> denote the empty category, and let <epub:switch id="mathmlSwitch971"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> be any category. There is a unique functor <epub:switch id="mathmlSwitch972"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>F</mi><mo>:</mo><munder accentunder='true'><mn>0</mn><mo>&#x00AF;</mo></munder><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="nl1-list">a. For general <epub:switch id="mathmlSwitch973"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, will <em>F</em> be full?</p>
<p class="nl1-list">b. For general <epub:switch id="mathmlSwitch974"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, will <em>F</em> be faithful?</p>
<p class="nl1-list">c. For general <epub:switch id="mathmlSwitch975"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, will <em>F</em> be an equivalence of categories?</p>
<p class="noindent1-top-pro" id="Pro_5-3-4-11"><strong>Proposition 5.3.4.11</strong>. <em>Let</em> <epub:switch id="mathmlSwitch976"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>and</em> <epub:switch id="mathmlSwitch977"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>be categories, and let</em> <epub:switch id="mathmlSwitch978"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>be an equivalence of categories. Then F is fully faithful.</em></p>

<p class="noindent"><em>Sketch of proof.</em> Suppose <em>F</em> is an equivalence, so we can find a functor <epub:switch id="mathmlSwitch979"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>F</mi><mo>&#x2032;</mo><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and natural isomorphisms <epub:switch id="mathmlSwitch980"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>&#x03B1;</mi><mo>:</mo><msub><mrow><mtext>id</mtext></mrow><mi mathvariant='script'>C</mi></msub><mover><mo>&#x2192;</mo><mo>&#x2245;</mo></mover><mi>F</mi><mo>&#x2032;</mo><mo>&#x25CB;</mo><mi>F</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch981"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>&#x03B1;</mi><mo>&#x2032;</mo><mo>:</mo><msub><mrow><mtext>id</mtext></mrow><mrow><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></mrow></msub><mover><mo>&#x2192;</mo><mo>&#x2245;</mo></mover><mi>F</mi><mo>&#x25CB;</mo><mi>F</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. We need to know that for any objects <epub:switch id="mathmlSwitch982"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>c</mi><mo>,</mo><mi>d</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy="false">(</mo><mi mathvariant='script'>C</mi><mo stretchy="false">)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, the map</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch983"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi>F</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy='false'>)</mo><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></mrow></msub><mo stretchy='false'>(</mo><mi>F</mi><mi>c</mi><mo>,</mo><mi>F</mi><mi>d</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<a id="p241"></a>
<p class="noindent">is bijective. Consider the following diagram</p>
<p class="fig-img"><img src="images/Art_P218.jpg" alt="art"/></p>
<p class="noindent">One can check that <epub:switch id="mathmlSwitch984"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><msubsup><mi>&#x03B1;</mi><mi>c</mi><mrow><mo>&#x2212;</mo><mn>1</mn></mrow></msubsup><mo>,</mo><msub><mi>&#x03B1;</mi><mi>d</mi></msub><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is bijective, so the vertical function is surjective by Exercise <a href="chapter003.html#Exe_3-4-5-3">3.4.5.3</a>. The fact that <epub:switch id="mathmlSwitch985"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></mrow></msub><mo stretchy='false'>(</mo><msup><mrow><mo stretchy='false'>(</mo><msubsup><mi>&#x03B1;</mi><mrow><mi>F</mi><mi>C</mi></mrow><mo>&#x2032;</mo></msubsup><mo stretchy='false'>)</mo></mrow><mrow><mo>&#x2212;</mo><mn>1</mn></mrow></msup><mo>,</mo><msubsup><mi>&#x03B1;</mi><mrow><mi>F</mi><mi>D</mi></mrow><mo>&#x2032;</mo></msubsup><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is bijective implies that the vertical function is injective. Thus we know that Hom<em><sub>F</sub></em>&#x2032; (<em>Fc</em>, <em>Fd</em>) is bijective. This implies that Hom<em><sub>F</sub></em>(<em>c</em>, <em>d</em>) is bijective as well.</p>
<p class="noindent1-top-exe" id="Exe_5-3-4-12"><em>Exercise</em> 5.3.4.12.</p>
<p>Let &#x2124;<sub>2</sub> be the group (as category) from Example <a href="chapter005.html#Exa_5-3-4-7">5.3.4.7</a>. Are there any fully faithful functors &#x2124;<sub>2</sub> &#x2192; <span class="underline">1</span>?</p>
</section>
</section>
<section title="Categories and schemas are equivalent, Cat &#x2243; Sch">
<h1 class="level1" id="lev_5-4"><a href="toc.html#Rlev_5-4"><strong>5.4&#160;&#160;&#160;Categories and schemas are equivalent, Cat &#x2243; Sch</strong></a></h1>
<p class="noindent">Perhaps it is intuitively clear that schemas are somehow equivalent to categories. In fact, this is a reason that so much attention has been given to databases (and ologs). This section makes the equivalence between schemas and categories precise; it is proved in Section <a href="chapter005.html#lev_5-4-2">5.4.2</a>. The basic idea was laid out in Section <a href="chapter005.html#lev_5-2-2">5.2.2</a>.</p>



<section title="The category Sch of schemas">
<h2 class="level2" id="lev_5-4-1"><strong>5.4.1&#160;&#160;&#160;The category Sch of schemas</strong></h2>
<p class="noindent">Recall from Definition <a href="chapter004.html#Def_4-5-2-7">4.5.2.7</a> that a schema consists of a pair <epub:switch id="mathmlSwitch986"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi mathvariant='script'>C</mi><mo>&#x2254;</mo><mo stretchy='false'>(</mo><mi>G</mi><mo>,</mo><mo>&#x2243;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, where <em>G</em> &#x003D; (<em>V</em>, <em>A</em>, <em>src</em>, <em>tgt</em>) is a graph and &#x2243; is a congruence, meaning a kind of equivalence relation on the paths in <em>G</em> (see Definition <a href="chapter004.html#Def_4-5-2-3">4.5.2.3</a>). If we think of a schema as being analogous to a category, what in schema-land should fulfill the role of functors? That is, what are to be the morphisms in <strong>Sch</strong>?</p>
<p>Unfortunately, one&#x2019;s first guess may give the wrong idea if we want an equivalence <strong>Sch</strong> &#x2243; <strong>Cat</strong>. Since an object in <strong>Sch</strong> is a graph with a congruence, one might imagine that a morphism <epub:switch id="mathmlSwitch987"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> in <strong>Sch</strong> should be a graph homomorphism (as in Definition <a href="chapter004.html#Def_4-3-3-1">4.3.3.1</a>) that preserves the congruence. But graph homomorphisms require that arrows be sent to <a id="p242"></a>arrows, whereas we are more interested in paths than in individual arrows&#x2014;the arrows are merely useful for presentation.</p>
<p>If instead we define morphisms between schemas to be maps that send paths in <epub:switch id="mathmlSwitch988"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> to paths in <epub:switch id="mathmlSwitch989"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></math></epub:case><epub:default></epub:default></epub:switch>, subject to the requirements that path endpoints, path concatenations, and path equivalences are preserved, this will turn out to give the correct notion. In fact, since a path is a concatenation of its arrows, it is more concise to give a function <em>F</em> from the arrows of <epub:switch id="mathmlSwitch990"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> to the paths of <epub:switch id="mathmlSwitch991"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></math></epub:case><epub:default></epub:default></epub:switch>. This is how we proceed.</p>
<p>Recall from Examples <a href="chapter005.html#Exa_5-1-2-25">5.1.2.25</a> and <a href="chapter005.html#Exa_5-3-1-16">5.3.1.16</a> the paths-graph functor Paths: <strong>Grph</strong> &#x2192; <strong>Grph</strong>, the paths of paths functor Paths &#x25CB; Paths: <strong>Grph</strong> &#x2192; <strong>Grph</strong>, and the natural transformations for any graph <em>G</em>,</p>
<p class="disp-equ-no" id="eq_5-16"><epub:switch id="mathmlSwitch992"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mtable><mtr><mtd><mrow><mtable><mtr><mtd><mrow><msub><mi>&#x03B7;</mi><mi>G</mi></msub><mo>:</mo><mi>G</mi><mo>&#x2192;</mo><mtext>Paths</mtext><mo>(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow></mtd><mtd><mrow><mtext>and</mtext></mrow></mtd><mtd><mrow><msub><mi>&#x03BC;</mi><mi>G</mi></msub><mo>:</mo><mtext>Paths</mtext><mo>(</mo><mtext>Paths</mtext><mo>(</mo><mi>G</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>&#x2192;</mo><mtext>Paths</mtext><mo>(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>.</mo></mrow></mtd></mtr></mtable></mrow></mtd><mtd><mrow><mo stretchy='false'>(</mo><mn>5.16</mn><mo stretchy='false'>)</mo></mrow></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">The function <em>&#x03B7;<sub>G</sub></em> spells out the fact that every arrow in <em>G</em> counts as a path in <em>G</em>, and the function <em>&#x03BC;<sub>G</sub></em> spells out the fact that a head-to-tail sequence of paths (a path of paths) in <em>G</em> can be concatenated to a single path in <em>G</em>.</p>
<p class="noindent1-top-exe" id="Exe_5-4-1-1"><em>Exercise</em> 5.4.1.1.</p>
<p>Let [2] denote the graph <epub:switch id="mathmlSwitch993"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover><mo>&#x2022;</mo><mn>0</mn></mover><mover><mo>&#x2192;</mo><mrow><msub><mi>e</mi><mn>1</mn></msub></mrow></mover><mover><mo>&#x2022;</mo><mn>1</mn></mover><mover><mo>&#x2192;</mo><mrow><msub><mi>e</mi><mn>2</mn></msub></mrow></mover><mover><mo>&#x2022;</mo><mn>2</mn></mover></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and let <epub:switch id="mathmlSwitch994"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> denote the unique graph having one vertex and one arrow</p>
<p class="fig-img"><img src="images/Art_P219.jpg" alt="art"/></p>
<p class="nl1-list">a. Find a graph homomorphism <em>f</em> : [2] &#x2192; Paths(<epub:switch id="mathmlSwitch995"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>) that is injective on arrows (i.e., such that no two arrows in the graph [2] are sent by <em>f</em> to the same arrow in Paths(<epub:switch id="mathmlSwitch996"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>)).</p>
<p class="nl1-list">b. The graph [2] has six paths, so Paths([2]) has six arrows. What are the images of these arrows under the graph homomorphism Paths(<em>f</em>): Paths([2]) &#x2192; Paths(Paths(<epub:switch id="mathmlSwitch997"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>)), where <em>f</em> is the morphism you chose in part (a)?</p>

<p class="nl1-list">c. Finally, using <em>&#x03BC;<sub><epub:switch id="mathmlSwitch998"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch></sub></em> : Paths(Paths(<epub:switch id="mathmlSwitch999"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>)) &#x2192; Paths(<epub:switch id="mathmlSwitch1000"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>), a path of paths in <epub:switch id="mathmlSwitch1001"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> can be concatenated to a path. Write what the composite graph homomorphism</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1002"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mtext>Paths</mtext><mo stretchy="false">(</mo><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mover><mo>&#x2192;</mo><mrow><mtext>Paths</mtext><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mover><mtext>Paths</mtext><mo stretchy="false">(</mo><mtext>Paths</mtext><mo stretchy="false">(</mo><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mover><mo>&#x2192;</mo><mrow><msub><mi>&#x03BC;</mi><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></msub></mrow></mover><mtext>Paths</mtext><mo stretchy="false">(</mo><mi>&#x2112;</mi><mi>o</mi><mi>o</mi><mi>p</mi><mo stretchy="false">)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class=" nl1-list-para">does to the six arrows in Paths([2]).</p>
<p class="space-break">Before we look at the definition of schema morphism, let&#x2019;s return to the original question. Given graphs <em>G</em>, <em>G</em>&#x2032; (underlying schemas <epub:switch id="mathmlSwitch1003"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, <epub:switch id="mathmlSwitch1004"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></math></epub:case><epub:default></epub:default></epub:switch>) we wanted a function from the <a id="p243"></a>paths in <em>G</em> to the paths in <em>G</em>&#x2032;, but it was more concise to speak of a function from arrows in <em>G</em> to paths in <em>G</em>&#x2032;. How do we get what we originally wanted from the concise version?</p>
<p>Given a graph homomorphism <em>f</em> : <em>G</em> &#x2192; Paths(<em>G</em>&#x2032;), we use (<a href="chapter005.html#eq_5-16">5.16</a>) to form the following composition, denoted simply Paths<em><sub>f</sub></em> : Paths(<em>G</em>) &#x2192; Paths(<em>G</em>&#x2032;):</p>
<p class="disp-equ" id="eq_5-17"><epub:switch id="mathmlSwitch1005"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"> <mtable><mtr><mtd columalign='left'><mrow><mtext>Paths</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mover><mo>&#x2192;</mo><mrow><mtext>Paths</mtext><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mover><mtext>Paths</mtext><mo stretchy="false">(</mo><mtext>Paths</mtext><mo stretchy="false">(</mo><mi>G</mi><mo>&#x2032;</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mover><mo>&#x2192;</mo><mrow><msub><mi>&#x03BC;</mi><mrow><mi>G</mi><mo>&#x2032;</mo></mrow></msub></mrow></mover><mtext>Paths</mtext><mo stretchy="false">(</mo><mi>G</mi><mo>&#x2032;</mo><mo stretchy="false">)</mo></mrow></mtd><mtd columalign='right'><mo>&#x00A0;</mo><mo stretchy="false">(</mo><mn>5.17</mn><mo>)</mo></mtd></mtr></mtable></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">This says that given a function from arrows in <em>G</em> to paths in <em>G</em>&#x2032;, a path in <em>G</em> becomes a path of paths in <em>G</em>&#x2032;, which can be concatenated to a path in <em>G</em>&#x2032;.</p>
<p class="noindent1-top-def" id="Def_5-4-1-2"><strong>Definition 5.4.1.2</strong> (Schema morphism). Let <em>G</em> &#x003D; (<em>V</em>, <em>A</em>, <em>src</em>, <em>tgt</em>) and <em>G</em>&#x2032; &#x003D; (<em>V</em>&#x2032;, <em>A</em>&#x2032;, <em>src</em>&#x2032;, <em>tgt</em>&#x2032;) be graphs, and let <epub:switch id="mathmlSwitch1006"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi mathvariant='script'>C</mi><mo>=</mo><mo stretchy='false'>(</mo><mi>G</mi><mo>,</mo><msub><mo>&#x2243;</mo><mi>G</mi></msub><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch1007"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi mathvariant='script'>C</mi><mo>&#x2032;</mo><mo>=</mo><mo stretchy='false'>(</mo><mi>G</mi><mo>&#x2032;</mo><mo>,</mo><msub><mo>&#x2243;</mo><mrow><mi>G</mi><mo>&#x2032;</mo></mrow></msub><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be schemas. A <em>schema morphism F from</em> <epub:switch id="mathmlSwitch1008"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> <em>to</em> <epub:switch id="mathmlSwitch1009"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch>, denoted <epub:switch id="mathmlSwitch1010"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, is a graph homomorphism <sup><a id="endnote_ref_19" href="chapter005.html#endnote_19">19</a></sup></p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1011"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi>G</mi><mo>&#x2192;</mo><mtext>Paths</mtext><mo stretchy="false">(</mo><mi>G</mi><mo>&#x2032;</mo><mo stretchy="false">)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">that satisfies the following condition for any paths <em>p</em> and <em>q</em> in <em>G</em>:</p>
<p class="disp-equ-no" id="eq_5-18"><epub:switch id="mathmlSwitch1012"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mtable><mtr><mtd><mrow><mtext>if</mtext><mo>&#x00A0;&#x00A0;</mo><mi>p</mi><msub><mo>&#x2243;</mo><mi>G</mi></msub><mo>&#x00A0;</mo><mi>q</mi><mo>&#x00A0;&#x00A0;</mo><mtext>then</mtext><mo>&#x00A0;&#x00A0;</mo><msub><mrow><mtext>Paths</mtext></mrow><mi>F</mi></msub><mo stretchy='false'>(</mo><mi>p</mi><mo stretchy='false'>)</mo><mo>&#x00A0;</mo><msub><mo>&#x2243;</mo><mrow><mi>G</mi><mo>&#x2032;</mo></mrow></msub><mo>&#x00A0;</mo><msub><mrow><mtext>Paths</mtext></mrow><mi>F</mi></msub><mo stretchy='false'>(</mo><mi>q</mi><mo stretchy='false'>)</mo><mo>.</mo></mrow></mtd><mtd><mrow><mo stretchy='false'>(</mo><mn>5.18</mn><mo stretchy='false'>)</mo></mrow></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p>Two schema morphisms <epub:switch id="mathmlSwitch1013"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>E</mi><mo>,</mo><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> are considered identical if they agree on vertices (i.e., <em>E</em><sub>0</sub> &#x003D; <em>F</em><sub>0</sub>) and if, for every arrow <em>f</em> in <em>G</em>, there is a path equivalence in <em>G</em>&#x2032;</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1014"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><msub><mi>E</mi><mn>1</mn></msub><mo stretchy='false'>(</mo><mi>f</mi><mo stretchy='false'>)</mo><msub><mo>&#x2243;</mo><mrow><mi>G</mi><mo>&#x2032;</mo></mrow></msub><msub><mi>F</mi><mn>1</mn></msub><mo stretchy='false'>(</mo><mi>f</mi><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>

<p>We now define the <em>category of schemas</em>, denoted <strong>Sch</strong>, to be the category whose objects are schemas as in Definition <a href="chapter004.html#Def_4-5-2-7">4.5.2.7</a> and whose morphisms are schema morphisms, as in Definition <a href="chapter005.html#Def_5-4-1-2">5.4.1.2</a>. The identity morphism on schema <epub:switch id="mathmlSwitch1015"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi mathvariant='script'>C</mi><mo>=</mo><mo stretchy='false'>(</mo><mi>G</mi><mo>,</mo><msub><mo>&#x2243;</mo><mi>G</mi></msub><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is the schema morphism <epub:switch id="mathmlSwitch1016"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <msub><mrow><mtext>id</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo>&#x2254;</mo><msub><mi>&#x03B7;</mi><mi>G</mi></msub><mo>:</mo><mi>G</mi><mo>&#x2192;</mo><mtext>Paths</mtext><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></math></epub:case><epub:default></epub:default></epub:switch>, as defined in Equation (<a href="chapter005.html#eq_5-16">5.16</a>). We need only understand how to compose schema morphisms <epub:switch id="mathmlSwitch1017"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch1018"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>F</mi><mo>&#x2032;</mo><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2033;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. On objects their composition is clear. Given an arrow in <epub:switch id="mathmlSwitch1019"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, it is sent to a path in <epub:switch id="mathmlSwitch1020"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></math></epub:case><epub:default></epub:default></epub:switch>; each arrow in that path is sent to a path in <epub:switch id="mathmlSwitch1021"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi><mo>&#x2033;</mo></math></epub:case><epub:default></epub:default></epub:switch>. We then have a path of paths, which we can concatenate (via <em>&#x03BC;</em><sub><em>G</em>&#x2033;</sub> : Paths(Paths(<em>G</em>&#x2033;)) &#x2192; Paths(<em>G</em>&#x2033;), as in (<a href="chapter005.html#eq_5-16">5.16</a>)) to get a path in <epub:switch id="mathmlSwitch1022"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi><mo>&#x2033;</mo></math></epub:case><epub:default></epub:default></epub:switch> as desired.</p>
<p class="noindent1-top-slo"><em>Slogan</em> 5.4.1.3.</p>
<div class="pull-quote">
<p class="pq-noindent"><em>A schema morphism sends vertices to vertices, arrows to paths, and path equivalences to path equivalences</em>.</p></div>
<a id="p244"></a>
<p class="noindent1-top-exe" id="Exa_5-4-1-4"><em>Example</em> 5.4.1.4. Let [2] be the linear order graph of length 2, at the left, and let <epub:switch id="mathmlSwitch1023"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> denote the diagram at the right:</p>
<p class="fig-img" id="eq_5-19"><img src="images/Art_P220.jpg" alt="art"/></p>
<p class="noindent">We impose on <epub:switch id="mathmlSwitch1024"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> the path equivalence declaration <sub><em>a</em></sub>[<em>g</em>, <em>h</em>] &#x2243;<sub><em>a</em></sub>[<em>i</em>] and show that in this case <epub:switch id="mathmlSwitch1025"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> and [2] are isomorphic in <strong>Sch</strong>. There is a unique schema morphism <epub:switch id="mathmlSwitch1026"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mo>:</mo><mo>[</mo><mn>2</mn><mo>]</mo><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> such that 0 &#x21A6;<em>a</em>, 1 &#x21A6;<em>b</em>, 2 &#x21A6;<em>c</em>; it sends each arrow in [2] to a path of length 1 in <epub:switch id="mathmlSwitch1027"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>. And we have a schema morphism <epub:switch id="mathmlSwitch1028"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>F</mi><mo>&#x2032;</mo><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mo stretchy='false'>[</mo><mn>2</mn><mo stretchy='false'>]</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, which reverses this mapping on vertices; note that <em>F</em>&#x2032; must send the arrow <em>i</em> in <epub:switch id="mathmlSwitch1029"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> to the path <sub>0</sub>[<em>f</em><sub>1</sub>, <em>f</em><sub>2</sub>] in [2], which is okay. The round-trip <em>F</em> &#x2032; &#x25CB; <em>F</em> : [2] &#x2192; [2] is identity. The round-trip <epub:switch id="mathmlSwitch1030"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>F</mi><mo>&#x25CB;</mo><mi>F</mi><mo>&#x2032;</mo><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> may look like it is not the identity; indeed it sends vertices to themselves and sends <em>i</em> to the path <sub><em>a</em></sub>[<em>g</em>, <em>h</em>]. But according to Definition <a href="chapter005.html#Def_5-4-1-2">5.4.1.2</a>, this schema morphism is considered identical to <epub:switch id="mathmlSwitch1031"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><msub><mrow><mtext>id</mtext></mrow><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> because there is a path equivalence <epub:switch id="mathmlSwitch1032"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><msub><mrow><mtext>id</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>i</mi><mo stretchy='false'>)</mo><mo>=</mo><mmultiscripts><mrow><mo stretchy='false'>[</mo><mi>i</mi><mo stretchy='false'>]</mo></mrow><mprescripts/><mi>a</mi><none/></mmultiscripts><mo>&#x2243;</mo><mmultiscripts><mrow><mo stretchy='false'>[</mo><mi>g</mi><mo>,</mo><mi>h</mi><mo stretchy='false'>]</mo></mrow><mprescripts/><mi>a</mi><none/></mmultiscripts><mo>=</mo><mi>F</mi><mo>&#x25CB;</mo><mi>F</mi><mo>&#x2032;</mo><mo stretchy='false'>(</mo><mi>i</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="noindent1-top-exe" id="Exe_5-4-1-5"><em>Exercise</em> 5.4.1.5.</p>
<p>Consider the schema [2] and the schema <epub:switch id="mathmlSwitch1033"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> pictured in (<a href="chapter005.html#eq_5-19">5.19</a>); this time we <em>do not</em> impose any path equivalence declarations on <epub:switch id="mathmlSwitch1034"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, so <sub><em>a</em></sub>[<em>g</em>, <em>h</em>] &#x2244; <em><sub>a</sub></em>[<em>i</em>] in the current version of <epub:switch id="mathmlSwitch1035"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="nl1-list">a. How many schema morphisms are there <epub:switch id="mathmlSwitch1036"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy='false'>[</mo><mn>2</mn><mo stretchy='false'>]</mo><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> that send 0 to <em>a</em>?</p>
<p class="nl1-list">b. How many schema morphisms are there <epub:switch id="mathmlSwitch1037"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mo stretchy='false'>[</mo><mn>2</mn><mo stretchy='false'>]</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> that send <em>a</em> to 0?</p>

<p class="noindent1-top-exe" id="Exe_5-4-1-6"><em>Exercise</em> 5.4.1.6.</p>
<p>Consider the graph <epub:switch id="mathmlSwitch1038"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> as follows:</p>
<p class="fig-img"><img src="images/Art_P221.jpg" alt="art"/></p>
<p class="noindent">and for any natural number <em>n</em> &#x2208; &#x2115;, let <epub:switch id="mathmlSwitch1039"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant="script">L</mi><mi>n</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> denote the schema (<epub:switch id="mathmlSwitch1040"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, &#x2243;<em><sub>n</sub></em>), where &#x2243;<em><sub>n</sub></em> is the PED <em>f</em><sup><em>n</em>&#x002B;1</sup> &#x2243; <em>f<sup>n</sup></em>. Then <epub:switch id="mathmlSwitch1041"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant="script">L</mi><mi>n</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> is the &#x201C;finite hierarchy of height <em>n</em>&#x201D; schema of Example <a href="chapter004.html#Exa_4-5-2-12">4.5.2.12</a>. Let <span class="underline">1</span> denote the graph with one vertex and no arrows; consider it a schema.</p>
<a id="p245"></a>
<p class="nl1-list">a. Is <span class="underline">1</span> isomorphic to <epub:switch id="mathmlSwitch1042"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant="script">L</mi><mn>1</mn></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> in <strong>Sch</strong>?</p>
<p class="nl1-list">b. Is <span class="underline">1</span> isomorphic to any (other) <epub:switch id="mathmlSwitch1043"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant="script">L</mi><mi>n</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>?</p>
<p class="noindent1-top-sol"><em>Solution</em> 5.4.1.6.</p>
<p class="nl1-list">a. No. The schema <epub:switch id="mathmlSwitch1044"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant="script">L</mi><mn>1</mn></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> is the graph <epub:switch id="mathmlSwitch1045"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> with the PED <em>f</em><sup>2</sup> &#x003D; <em>f</em>, so there is still one nontrivial arrow in <epub:switch id="mathmlSwitch1046"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant="script">L</mi><mn>1</mn></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>, namely, <em>f</em><sup>1</sup> &#x2244; <em>f</em><sup>0</sup>, whereas <span class="underline">1</span> has only the identity arrow.</p>

<p class="nl1-list">b. Yes, there is an isomorphism of schemas <span class="underline">1</span> &#x2245; <epub:switch id="mathmlSwitch1047"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant="script">L</mi><mn>0</mn></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>, because <em>f</em> &#x2243; <em>f</em><sup>0</sup> &#x003D; id<em><sub>s</sub></em> in <epub:switch id="mathmlSwitch1048"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant="script">L</mi><mn>0</mn></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="noindent1-top-exe" id="Exe_5-4-1-7"><em>Exercise</em> 5.4.1.7.</p>
<p>Let <epub:switch id="mathmlSwitch1049"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch1050"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant="script">L</mi><mi>n</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> be schemas as defined in Exercise <a href="chapter005.html#Exe_5-4-1-6">5.4.1.6</a>.</p>
<p class="nl1-list">a. What is the cardinality of the set Hom<strong><sub>Sch</sub></strong>(<epub:switch id="mathmlSwitch1051"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant="script">L</mi><mn>3</mn></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <epub:switch id="mathmlSwitch1052"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant="script">L</mi><mn>5</mn></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>)?</p>
<p class="nl1-list">b. What is the cardinality of the set Hom<strong><sub>Sch</sub></strong>(<epub:switch id="mathmlSwitch1053"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant="script">L</mi><mn>5</mn></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <epub:switch id="mathmlSwitch1054"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant="script">L</mi><mn>3</mn></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>)? Hint: The cardinality of the set Hom<strong><sub>Sch</sub></strong>(<epub:switch id="mathmlSwitch1055"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant="script">L</mi><mn>4</mn></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <epub:switch id="mathmlSwitch1056"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant="script">L</mi><mn>9</mn></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>) is 8.</p>
</section>


<section title="Proving the equivalence">
<h2 class="level2" id="lev_5-4-2"><strong>5.4.2&#160;&#160;&#160;Proving the equivalence</strong></h2>
<p class="noindent">This section proves the equivalence of categories, <strong>Sch</strong> &#x2243; <strong>Cat</strong>. We construct the two functors <strong>Sch</strong> &#x2192; <strong>Cat</strong> and <strong>Cat</strong> &#x2192; <strong>Sch</strong> and then prove that these are mutually inverse equivalences (see Theorem <a href="chapter005.html#The_5-4-2-3">5.4.2.3</a>).</p>
<p class="noindent1-top" id="Con_5-4-2-1"><em>Construction</em> 5.4.2.1 (From schema to category). We first define a functor <em>L</em> : <strong>Sch</strong> &#x2192; <strong>Cat</strong>. Let <epub:switch id="mathmlSwitch1057"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi mathvariant='script'>C</mi><mo>=</mo><mo stretchy='false'>(</mo><mi>G</mi><mo>,</mo><mo>&#x2243;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be a schema, where <em>G</em> &#x003D; (<em>V</em>, <em>A</em>, <em>src</em>, <em>tgt</em>). Define <epub:switch id="mathmlSwitch1058"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>L</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> to be the category with <epub:switch id="mathmlSwitch1059"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mtext>Ob</mtext><mo stretchy="false">(</mo><mi>L</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>=</mo><mi>V</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and with <epub:switch id="mathmlSwitch1060"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi>L</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></msub><mo stretchy='false'>(</mo><msub><mi>v</mi><mn>1</mn></msub><mo>,</mo><msub><mi>v</mi><mn>2</mn></msub><mo stretchy='false'>)</mo><mo>&#x2254;</mo><msub><mrow><mtext>Path</mtext></mrow><mi>G</mi></msub><mo stretchy='false'>(</mo><mi>v</mi><mo>,</mo><mi>w</mi><mo stretchy='false'>)</mo><mo>/</mo><mo>&#x2243;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, i.e., the set of paths in <em>G</em> modulo the path equivalence relation for <epub:switch id="mathmlSwitch1061"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>. The composition of morphisms is defined by concatenation of paths, and part (4) of Definition <a href="chapter004.html#Def_4-5-2-3">4.5.2.3</a> implies that such composition is well defined. We have thus defined <em>L</em> on objects of <strong>Sch</strong>.</p>
<p>Given a schema morphism <epub:switch id="mathmlSwitch1062"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, where <epub:switch id="mathmlSwitch1063"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi mathvariant='script'>C</mi><mo>&#x2032;</mo><mo>=</mo><mo stretchy='false'>(</mo> <mi>G</mi><mo>&#x2032;</mo><mo>,</mo><mo>&#x2243;</mo><mo>&#x2032;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we need to produce a functor <epub:switch id="mathmlSwitch1064"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>L</mi><mo stretchy='false'>(</mo><mi>F</mi><mo stretchy='false'>)</mo><mo>:</mo><mi>L</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mi>L</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. The objects of <epub:switch id="mathmlSwitch1065"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>L</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch1066"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>L</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> are the vertices of <em>G</em> and <em>G</em>&#x2032; respectively, and <em>F</em> provides the necessary function on objects. Diagram (<a href="chapter005.html#eq_5-17">5.17</a>) provides a function Paths<em><sub>F</sub></em> : Paths(<em>G</em>) &#x2192; Paths(<em>G</em>&#x2032;) provides the requisite function for morphisms.</p>
<p>A morphism in <epub:switch id="mathmlSwitch1067"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>L</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is an equivalence class of paths in <epub:switch id="mathmlSwitch1068"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>. For any representative path <em>p</em> &#x2208; Paths(<em>G</em>), we have Paths<em><sub>F</sub></em>(<em>p</em>) &#x2208; Paths(<em>G</em>&#x2032;), and if <em>p</em> &#x2243; <em>q</em>, then Paths<em><sub>F</sub></em>(<em>p</em>) &#x2243;&#x2032; Paths<em><sub>F</sub></em>(<em>q</em>) <a id="p246"></a>by condition (<a href="chapter005.html#eq_5-18">5.18</a>). Thus Paths<em><sub>F</sub></em> indeed provides us with a function <epub:switch id="mathmlSwitch1069"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi>L</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></msub><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi>L</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo></mrow></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>. This defines <em>L</em> on morphisms in <strong>Sch</strong>. It is clear that <em>L</em> preserves composition and identities, so it is a functor.</p>
<p class="noindent1-top" id="Con_5-4-2-2"><em>Construction</em> 5.4.2.2 (From category to schema). We first define a functor <em>R</em> : <strong>Cat</strong> &#x2192; <strong>Sch</strong>. Let <epub:switch id="mathmlSwitch1070"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>=</mo><mo stretchy='false'>(</mo><mtext>Ob</mtext><mo stretchy="false">(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo><mo>,</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo>,</mo><mi>d</mi><mi>o</mi><mi>m</mi><mo>,</mo><mi>c</mi><mi>o</mi><mi>d</mi><mo>,</mo><mi>i</mi><mi>d</mi><mi>s</mi><mo>,</mo><mi>c</mi><mi>o</mi><mi>m</mi><mi>p</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be a category (see Exercise <a href="chapter005.html#Exe_5-1-1-27">5.1.1.27</a>). Let <epub:switch id="mathmlSwitch1071"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>R</mi><mo stretchy="false">(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo><mo>=</mo><mo stretchy='false'>(</mo><mi>G</mi><mo>,</mo><mo>&#x2243;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, where <em>G</em> is the graph</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1072"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>G</mi><mo>=</mo><mo stretchy='false'>(</mo><mtext>Ob</mtext><mo stretchy="false">(</mo><mi mathvariant='script'>C</mi><mo>)</mo><mo>,</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo>,</mo><mi>d</mi><mi>o</mi><mi>m</mi><mo>,</mo><mi>c</mi><mi>o</mi><mi>d</mi><mo stretchy='false'>)</mo><mo>,</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">and with &#x2243; defined as the congruence generated by the following path equivalence declarations: for any composable sequence of morphisms <em>f</em><sub>1</sub>, <em>f</em><sub>2</sub>, &#x2026;, <em>f<sub>n</sub></em> (with <em>dom</em>(<em>f</em><sub><em>i</em>&#x002B;1</sub>) &#x003D; <em>cod</em>(<em>f<sub>i</sub></em>) for each 1 &#x2A7D; <em>i</em> &#x2A7D; <em>n</em> &#x2212; 1), we put</p>
<p class="disp-equ" id="eq_5-20"><epub:switch id="mathmlSwitch1073"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"> <mtable><mtr><mtd><mrow><mmultiscripts><mrow><mo stretchy='false'>[</mo><msub><mi>f</mi><mn>1</mn></msub><mo>,</mo><msub><mi>f</mi><mn>2</mn></msub><mo>,</mo><mn>...</mn><mo>,</mo><msub><mi>f</mi><mi>n</mi></msub><mo stretchy='false'>]</mo></mrow><mprescripts/><mrow><mi>d</mi><mi>o</mi><mi>m</mi><mo stretchy='false'>(</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy='false'>)</mo></mrow><none/></mmultiscripts><mo>&#x2243;</mo><mmultiscripts><mrow><mo stretchy='false'>[</mo><msub><mi>f</mi><mi>n</mi></msub><mo>&#x25CB;</mo><mo>&#x22EF;</mo><mo>&#x25CB;</mo><msub><mi>f</mi><mn>2</mn></msub><mo>&#x25CB;</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy='false'>]</mo></mrow><mprescripts/><mrow><mi>d</mi><mi>o</mi><mi>m</mi><mo stretchy='false'>(</mo><msub><mi>f</mi><mn>1</mn></msub><mo stretchy='false'>)</mo></mrow><none/></mmultiscripts><mo>,</mo></mrow></mtd><mtd columnalign='right'><mo>&#x00A0;</mo><mrow><mo stretchy='false'>(</mo><mn>5.20</mn><mo stretchy='false'>)</mo></mrow></mtd></mtr></mtable></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">equating a path of length <em>n</em> with a path of length 1. This defines <em>R</em> on objects of <strong>Cat</strong>.</p>
<p>A functor <epub:switch id="mathmlSwitch1074"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> induces a schema morphism <epub:switch id="mathmlSwitch1075"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>R</mi><mo stretchy='false'>(</mo><mi>F</mi><mo stretchy='false'>)</mo><mo>:</mo><mi>R</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mi>R</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, because vertices are sent to vertices, arrows are sent to arrows (as paths of length 1), and path equivalence is preserved by (<a href="chapter007.html#eq_7-17">7.17</a>) and the fact that <em>F</em> preserves the composition formula. This defines <em>R</em> on morphisms in <strong>Cat</strong>. It is clear that <em>R</em> preserves compositions, so it is a functor.</p>

<p class="noindent1-top-the" id="The_5-4-2-3"><strong>Theorem 5.4.2.3</strong>. <em>The functors</em></p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1076"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>L</mi><mo>:</mo><mstyle mathvariant='bold' mathsize='normal'><mi>S</mi><mi>c</mi><mi>h</mi></mstyle><mo>&#x21C4;</mo><mstyle mathvariant='bold' mathsize='normal'><mi>C</mi><mi>a</mi><mi>t</mi></mstyle><mo>:</mo><mi>R</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent"><em>are mutually inverse equivalences of categories.</em></p>
<p class="noindent1-top1"><em>Sketch of proof.</em> It is clear that there is a natural isomorphism <epub:switch id="mathmlSwitch1077"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x03B1;</mi><mo>:</mo><msub><mrow><mtext>id</mtext></mrow><mrow><mstyle mathvariant='bold' mathsize='normal'><mi>C</mi><mi>a</mi><mi>t</mi></mstyle></mrow></msub><mover><mo>&#x2192;</mo><mo>&#x2245;</mo></mover><mi>L</mi><mo>&#x25CB;</mo><mi>R</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>; i.e., for any category <epub:switch id="mathmlSwitch1078"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, there is an isomorphism <epub:switch id="mathmlSwitch1079"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi mathvariant='script'>C</mi><mo>&#x2245;</mo><mi>L</mi><mo stretchy='false'>(</mo><mi>R</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p>Before giving an isomorphism <epub:switch id="mathmlSwitch1080"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x03B2;</mi><mo>:</mo><msub><mrow><mtext>id</mtext></mrow><mrow><mstyle mathvariant='bold' mathsize='normal'><mi>S</mi><mi>c</mi><mi>h</mi></mstyle></mrow></msub><mover><mo>&#x2192;</mo><mo>&#x2245;</mo></mover><mi>R</mi><mo>&#x25CB;</mo><mi>L</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we look at <epub:switch id="mathmlSwitch1081"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>R</mi><mo stretchy='false'>(</mo><mi>L</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>G</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>&#x2255;</mo><mo stretchy='false'>(</mo> <mi>G</mi><mo>&#x2032;</mo><mo>,</mo><mo>&#x2243;</mo><mo>&#x2032;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> for a schema <epub:switch id="mathmlSwitch1082"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi mathvariant='script'>G</mi><mo>=</mo><mo stretchy='false'>(</mo><mi>G</mi><mo>,</mo><mo>&#x2243;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Write <em>G</em> &#x003D; (<em>V</em>, <em>A</em>, <em>src</em>, <em>tgt</em>) and <em>G</em>&#x2032; &#x003D; (<em>V</em> &#x2032;, <em>A</em>&#x2032;, <em>src</em>&#x2032;, <em>tgt</em>&#x2032;). On vertices we have <em>V</em> &#x003D; <em>V</em>&#x2032;. On arrows we have <em>A</em>&#x2032; &#x003D; Path<em><sub>G</sub></em>/&#x2243;. The congruence &#x2243;&#x2032; for <epub:switch id="mathmlSwitch1083"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>R</mi><mo stretchy='false'>(</mo><mi>L</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>G</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is imposed in (<a href="chapter005.html#eq_5-20">5.20</a>). Under &#x2243;&#x2032;, every path of paths in <em>G</em> is made equivalent to its concatenation, considered as a single path of length 1 in <em>G</em>&#x2032;.</p>
<p>There is a natural transformation <em>&#x003B2;</em> : id<strong><sub>Sch</sub></strong> &#x2192; <em>R</em> &#x25CB; <em>L</em> whose <epub:switch id="mathmlSwitch1084"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>G</mi></math></epub:case><epub:default></epub:default></epub:switch> component sends each arrow in <em>G</em> to a certain path of length 1 in <em>G</em>&#x2032;. We need to see that <epub:switch id="mathmlSwitch1085"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><msub><mi>&#x03B2;</mi><mi mathvariant='script'>G</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> has an inverse. But this is straightforward: every arrow <em>f</em> in <epub:switch id="mathmlSwitch1086"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"> <mrow><mi>R</mi><mo>&#x25CB;</mo><mi>L</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>G</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is an equivalence class of paths in <epub:switch id="mathmlSwitch1087"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>G</mi></math></epub:case><epub:default></epub:default></epub:switch>; choose any one, and have <em>&#x03B2;</em><sup>&#x2212;1</sup> send <em>f</em> there; by Definition <a href="chapter005.html#Def_5-4-1-2">5.4.1.2</a>, any other choice will give the identical morphism of schemas. It is easy to show that each round-trip is equal to the identity (again up to the notion of equality of schema morphism given in Definition <a href="chapter005.html#Def_5-4-1-2">5.4.1.2</a>).</p>
<a id="p247"></a>
<figure>
<img src="images/Art_P222.jpg" alt="art"/>
<figcaption id="Fig_5-1"><strong>Figure 5.1</strong> Finite state machines <em>X</em> and <em>Y</em> with alphabet &#x03A3; &#x003D; {<em>a</em>, <em>b</em>} and three states (left) or six states (right), and their associated action tables.</figcaption>
</figure>
<a id="p248"></a>
<p class="noindent1-top">__________________</p>
<p class="ntx" id="endnote_1"><a epub:type="noteref" href="chapter005.html#endnote_ref_1"><sup>1</sup></a>In <em>Society of Mind</em> [32].</p>
<p class="ntx" id="endnote_2"><a epub:type="noteref" href="chapter005.html#endnote_ref_2"><sup>2</sup></a>The reason for the notation Hom and the word <em>hom-set</em> is that morphisms are often called <em>homomorphisms</em>, e.g., in group theory.</p>
<p class="ntx" id="endnote_3"><a epub:type="noteref" href="chapter005.html#endnote_ref_3"><sup>3</sup></a>Full subcategory will be defined in Definition <a href="chapter006.html#Def_6-2-3-1">6.2.3.1</a>.</p>
<p class="ntx" id="endnote_4"><a epub:type="noteref" href="chapter005.html#endnote_ref_4"><sup>4</sup></a>See Remark <a href="chapter005.html#Rem_5-1-1-2">5.1.1.2</a>.</p>
<p class="ntx" id="endnote_5"><a epub:type="noteref" href="chapter005.html#endnote_ref_5"><sup>5</sup></a>See Exercise <a href="chapter002.html#Exe_2-1-2-22">2.1.2.22</a> if there is any confusion about this.</p>
<p class="ntx" id="endnote_6"><a epub:type="noteref" href="chapter005.html#endnote_ref_6"><sup>6</sup></a>The name of this morphism is unimportant. What matters is that <epub:switch id="mathmlSwitch1088"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>X</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> has exactly one element iff <em>x</em> &#x2264; <em>y</em>.</p>
<p class="ntx" id="endnote_7"><a epub:type="noteref" href="chapter005.html#endnote_ref_7"><sup>7</sup></a>The topology is given by saying that <em>U</em> &#x2286; &#x211D; is open iff for every <em>x</em> &#x2208; <em>U</em>, there exists <em>&#x03F5;</em> &#x003E; 0 such that {<em>y</em> &#x2208; &#x211D; &#x007C; &#x007C;<em>y</em> &#x2212; <em>x</em>&#x007C; &#x003C; <em>&#x03F5;</em>} &#x2286; <em>U</em>}. One says, &#x201C;<em>U</em> &#x2286; &#x211D; is open if every point in <em>U</em> has an epsilon-neighborhood fully contained in <em>U</em>.&#x201D;</p>
<p class="ntx" id="endnote_8"><a epub:type="noteref" href="chapter005.html#endnote_ref_8"><sup>8</sup></a>The topology on &#x211D; &#x00D7; &#x211D; is similar; a subset <em>U</em> &#x2286; &#x211D; &#x00D7; &#x211D; is open if every point <em>x</em> &#x2208; <em>U</em> has an epsilon-neighborhood (a disk around <em>x</em> of some positive radius) fully contained in <em>U</em>.</p>
<p class="ntx" id="endnote_9"><a epub:type="noteref" href="chapter005.html#endnote_ref_9"><sup>9</sup></a>This example may be somewhat crude, in accordance with the crudeness of my understanding of materials science.</p>
<p class="ntx" id="endnote_10"><a epub:type="noteref" href="chapter005.html#endnote_ref_10"><sup>10</sup></a> Let <em>I</em> &#x00D7; <em>I</em> &#x003D; {(<em>x</em>, <em>y</em>) &#x2208; &#x211D;<sup>2</sup> &#x007C; 0 &#x2264; <em>x</em> &#x2264; 1 and 0 &#x2264; <em>y</em> &#x2264; 1} denote the square. There are two inclusions <em>i</em><sub>0</sub>, <em>i</em><sub>1</sub> : <em>I</em> &#x2192; <em>S</em> that put the interval inside the square at the left and right sides. Two paths <em>f</em><sub>0</sub>, <em>f</em><sub>1</sub> : <em>I</em> &#x2192; <em>X</em> are homotopic if there exists a continuous map <em>f</em> : <em>I</em> &#x00D7; <em>I</em> &#x2192; <em>X</em> such that <em>f</em><sub>0</sub> &#x003D; <em>f</em> &#x25CB; <em>i</em><sub>0</sub> and <em>f</em><sub>1</sub> &#x003D; <em>f</em> &#x25CB; <em>i</em><sub>1</sub>,</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1089"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>I</mi><munderover><mrow><mo>&#x21C9;</mo></mrow><mrow><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><msub><mi>i</mi><mn>1</mn></msub></mrow><mrow><msub><mi>i</mi><mn>0</mn></msub></mrow></munderover><mi>I</mi><mo>&#x00D7;</mo><mi>I</mi><mover><mo>&#x2192;</mo><mrow><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mi>f</mi><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo></mrow></mover><mi>X</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="ntx" id="endnote_11"><a epub:type="noteref" href="chapter005.html#endnote_ref_11"><sup>11</sup></a>The discipline called <em>information theory</em>, invented by Claude Shannon, is concerned only with ideal compression schemes. It does not pay attention to the content of the messages&#x2014;what they mean&#x2014;as Shannon says specifically in his seminal paper: &#x201C;Frequently the messages have meaning; that is they refer to or are correlated according to some system with certain physical or conceptual entities. These semantic aspects of communication are irrelevant to the engineering problem.&#x201D; Thus I think the subject is badly named. It should be called compression theory or redundancy theory.</p>
<p class="ntxp">Information is inherently meaningful&#x2014;that is its purpose&#x2014;so a theory unconcerned with meaning is not really studying information per se. (The people who decide on speed limits for roads and highways may care about human health, but a study limited to understanding ideal speed limit schemes would not be called &#x201C;human health theory.&#x201D;)</p>
<p class="ntxp">Information theory is extremely important in a diverse array of fields, including computer science [28], neuroscience [5], [27], and physics [16]. I am not trying to denigrate the field; I only disagree with its name.</p>
<p class="ntx" id="endnote_12"><a epub:type="noteref" href="chapter005.html#endnote_ref_12"><sup>12</sup></a>The function <em>&#x03B1;</em><sub>&#x25B2;</sub> : <em>Y</em> (&#x25B2;) &#x2192; <em>X</em>(&#x25B2;) makes the following assignments: State 0 &#x21A6; State 0, State 1A &#x21A6; State 1, State 1B &#x21A6; State 1, State 1C &#x21A6; State 1, State 2A &#x21A6; State 2, State 2B &#x21A6; State 2.</p>
<p class="ntx" id="endnote_13"><a epub:type="noteref" href="chapter005.html#endnote_ref_13"><sup>13</sup></a>When we have a functor, such as <em>Disc</em> : <strong>Set</strong> &#x2192; <strong>Cat</strong>, we sometimes say, &#x201C;Let <em>S</em> be a set, considered as a category.&#x201D; This means that we want to take ideas and methods available in <strong>Cat</strong> and use them on the set <em>S</em>. Having the functor <em>Disc</em>, we use it to move <em>S</em> into <strong>Cat</strong>, as <em>Disc</em>(<em>S</em>) &#x2208; Ob(<strong>Cat</strong>), upon which we can use the intended methods. However, <em>Disc</em>(<em>S</em>) is bulky, e.g., Fun(<em>Disc</em>(<span class="underline">3</span>), <em>Disc</em>(<span class="underline">2</span>)) is harder to read than Fun(<span class="underline">3</span>, <span class="underline">2</span>). So we abuse notation and write <em>S</em> instead of <em>Disc</em>(<em>S</em>), and talk about <em>S</em> as though it were still a set, e.g., discussing its elements rather than its objects. This kind of conceptual abbreviation is standard practice in mathematical discussion because it eases the mental burden, but when one says &#x201C;Let <em>S</em> be an <em>X</em> considered as a <em>Y</em>,&#x201D; the other may always ask, &#x201C;How are you considering <em>X</em>&#x2019;s to be <em>Y</em>&#x2019;s?&#x201D; and expect a functor.</p>
<p class="ntx" id="endnote_14"><a epub:type="noteref" href="chapter005.html#endnote_ref_14"><sup>14</sup></a>The <em>p</em> column comes from applying <em>b</em>, then <em>a</em>, then <em>a</em>, as specified by <em>F</em>.</p>
<p class="ntx" id="endnote_15"><a epub:type="noteref" href="chapter005.html#endnote_ref_15"><sup>15</sup></a>More precisely, given a functor between schemas <epub:switch id="mathmlSwitch1090"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, the pullback <epub:switch id="mathmlSwitch1091"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mo>&#x0394;</mo><mi>F</mi></msub><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, its left &#x03A3;<em><sub>F</sub></em> and its right adjoint &#x03A0;<em><sub>F</sub></em> constitute these important queries. See Section <a href="chapter007.html#lev_7-1-4">7.1.4</a>.</p>
<p class="ntx" id="endnote_16"><a epub:type="noteref" href="chapter005.html#endnote_ref_16"><sup>16</sup></a>The notation &#x2243; has already been used for equivalences of paths in a schema. I do not mean to equate these ideas; I am just reusing the symbol. Hopefully, no confusion will arise.</p>
<p class="ntx" id="endnote_17"><a epub:type="noteref" href="chapter005.html#endnote_ref_17"><sup>17</sup></a>One way to see this is that by Exercise <a href="chapter005.html#Exe_5-1-2-41">5.1.2.41</a>, we have a functor Ob: <strong>Cat</strong> &#x2192; <strong>Set</strong>, and we know by Exercise <a href="chapter005.html#Exe_5-1-2-27">5.1.2.27</a> that functors preserve isomorphisms, so an isomorphism between categories must restrict to an isomorphism between their sets of objects. The only sets that are isomorphic to <span class="underline">1</span> have one element.</p>
<p class="ntx" id="endnote_18"><a epub:type="noteref" href="chapter005.html#endnote_ref_18"><sup>18</sup></a>The phrase &#x201C;these fit together into&#x201D; is shorthand for, and can be replaced by, &#x201C;the naturality squares commute for these components, so together they constitute.&#x201D;</p>
<p class="ntx" id="endnote_19"><a epub:type="noteref" href="chapter005.html#endnote_ref_19"><sup>19</sup></a>By Definition <a href="chapter004.html#Def_4-3-3-1">4.3.3.1</a>, a graph homomorphism <em>F</em> : <em>G</em> &#x2192; Paths(<em>G</em>&#x2032;) will consist of a vertex part <em>F</em><sub>0</sub> : <em>V</em> &#x2192; <em>V</em>&#x2032; and an arrows part <em>F</em><sub>1</sub> : <em>E</em> &#x2192; Path(<em>G</em>&#x2032;). See also Definition <a href="chapter004.html#Def_4-3-2-1">4.3.2.1</a>.</p>
</section>
</section>
</section>
<p><div class=navigation>[Go to <span><a href="index.html">first</a>, <a href="chapter004.html">previous</a></span><span>, <a href="chapter006.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="toc.html">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="bookindex.html">index</a></span>]</div><p>


</div>
</body>
</html>
