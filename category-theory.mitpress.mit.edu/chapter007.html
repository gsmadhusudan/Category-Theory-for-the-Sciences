<!DOCTYPE html>
<html>
<head>
<title>Category Theory for the Sciences</title>
<link rel="stylesheet" type="text/css" href="css/stylesheet.css"/>
</head>
<body>
<div class="body">
<section title="" epub:type="bodymatter chapter">
<a id="p297"></a>
<p><div class=navigation>[Go to <span><a href="index.html">first</a>, <a href="chapter006.html">previous</a></span><span>, <a href="reference.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="toc.html">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="bookindex.html">index</a></span>]</div><p>

<h1 class="chapter-number"><a href="toc.html#chap-7"><strong>Chapter 7</strong></a></h1>
<h1 class="chapter-title"><a href="toc.html#chap-7"><strong>Categories at Work</strong></a></h1>
<p class="noindent">The reader should now have an understanding of the basic notions of category theory: categories, functors, natural transformations, and universal properties. As well, we have discussed many sources of examples: orders, graphs, monoids, and databases. This chapter begins with the notion of <em>adjoint functors</em> (also known as <em>adjunctions</em>), which are like dictionaries translating back and forth between different categories.</p>
<section title="">
<h1 class="level1" id="lev_7-1"><a href="toc.html#Rlev_7-1"><strong>7.1&#160;&#160;&#160;Adjoint functors</strong></a></h1>
<p class="noindent">How far can we take this dictionary analogy?</p>
<p>In the common understanding of dictionaries, we assume that two languages (say, French and English) are equally expressive and that a good dictionary will assist in an even exchange of ideas. But in category theory we often have two categories that are not on the same conceptual level. This is most clear in the case of <em>free-forgetful adjunctions</em>. Section <a href="chapter007.html#lev_7-1-1">7.1.1</a> explores the sense in which each adjunction provides a dictionary between two categories that are not necessarily on an equal footing, so to speak.</p>
<section title="Discussion and definition">
<h2 class="level2" id="lev_7-1-1"><strong>7.1.1&#160;&#160;&#160;Discussion and definition</strong></h2>
<p class="noindent">Consider the category of monoids and the category of sets. A monoid (<em>M</em>, <em>e</em>, &#x22C6;) is a set with a unit element and a multiplication formula that is associative. A set is just a set. A dictionary between <strong>Mon</strong> and <strong>Set</strong> should not be required to set up an even exchange but rather an exchange that is appropriate to the structures at hand. It will be in the form of two functors, denoted <em>L</em>: <strong>Set</strong> &#x2192; <strong>Mon</strong> and <em>R</em>: <strong>Mon</strong> &#x2192; <strong>Set</strong>. So we can translate back and forth, but to say what kind of exchange is appropriate will require more work.</p>
<a id="p298"></a>
<p>An extended analogy will introduce the subject. A one-year-old can make repeatable noises, and an adult can make repeatable noises. One might say, &#x201C;After all, talking is nothing but making repeatable noises.&#x201D; But the adult&#x2019;s repeatable noises are called words, they form sentences, and those sentences can cause nuclear wars. There is something more in adult language than simply repeatable sounds. In the same vein, a game of tennis can be viewed in terms of physics, the movement of trillions of atoms, but in so doing one won&#x2019;t see the game aspect. So we have here something analogous to two categories here: {repeated noises} and {meaningful words}. We are looking for adjoint functors to serve as the appropriate sort of dictionary.</p>
<p>To translate baby talk into adult language we would make every repeated noise a kind of word, thereby granting it meaning. We do not know what a given repeated noise should mean, but we give it a slot in our conceptual space while always pondering, &#x201C;I wonder what she means by Koh&#x2026;.&#x201D; On the other hand, to translate from meaningful words to repeatable noises is easy. We just hear the word as a repeated noise, which is how the baby probably hears it.</p>
<p>Adjoint functors often come in the form of &#x201C;free&#x201D; and &#x201C;forgetful.&#x201D; Here we freely add Koh to our conceptual space without having any idea how it adheres to the rest of the child&#x2019;s noises or feelings. But it does not act like a sound to us, it acts like a word; we do not know what it means, but we figure it means something. Conversely, the translation going the other way is &#x201C;forgetful,&#x201D; forgetting the meaning of the words and just hearing them as sounds. The baby hears our words and accepts them as mere sounds, not knowing that there is anything extra to get.</p>
<p>Sets are like the babies in the story: they are simple objects full of unconnected dots. Monoids are like the adults, forming words and performing actions. In the monoid each element means something and combines with other elements in certain ways. There are many different sets and many different monoids, just as there are many babies and many adults, but there are differences in how they interact, so we put them in different categories.</p>
<p>Applying free functor <em>L</em>: <strong>Set</strong> &#x2192; <strong>Mon</strong> to a set <em>X</em> makes every element <em>x</em> &#x2208; <em>X</em> a word, and these words can be strung together to form more complex words. (Section <a href="chapter004.html#lev_4-1-1-12">4.1.1.12</a> discussed the free monoid functor <em>L</em>.) Since a set such as <em>X</em> carries no information about the meaning or structure of its various elements, the free monoid <em>F</em>(<em>X</em>) does not relate different words in any way. To apply the forgetful functor <em>R</em>: <strong>Mon</strong> &#x2192; <strong>Set</strong> to a monoid, even a structured one, is to simply forget that its elements are anything but mere elements of a set. It sends a monoid (<em>M</em>, <em>e</em>, &#x22C6;) to the set <em>M</em>.</p>

<p class="noindent1-top-def" id="Def_7-1-1-1"><strong>Definition 7.1.1.1</strong>. Let <epub:switch id="mathmlSwitch1493"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>B</mi></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch1494"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>A</mi></math></epub:case><epub:default></epub:default></epub:switch> be categories.<sup><a id="endnote_ref_1" href="chapter007.html#endnote_1">1</a></sup> An <em>adjunction between</em> <epub:switch id="mathmlSwitch1495"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>B</mi></math></epub:case><epub:default></epub:default></epub:switch> <em>and</em> <epub:switch id="mathmlSwitch1496"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>A</mi></math></epub:case><epub:default></epub:default></epub:switch> is a <a id="p299"></a>pair of functors</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1497"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd><mrow><mi>L</mi><mo>:</mo><mi mathvariant='script'>B</mi><mo>&#x2192;</mo><mi mathvariant='script'>A</mi></mrow></mtd><mtd><mrow><mtext>and</mtext></mrow></mtd><mtd><mrow><mi>R</mi><mo>:</mo><mi mathvariant='script'>A</mi><mo>&#x2192;</mo><mi mathvariant='script'>B</mi></mrow></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">together with a natural isomorphism<sup><a id="endnote_ref_2" href="chapter007.html#endnote_2">2</a></sup> whose component for any objects <epub:switch id="mathmlSwitch1498"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy="false">(</mo><mi mathvariant='script'>A</mi><mo stretchy="false">)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch1499"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy="false">(</mo><mi mathvariant='script'>B</mi><mo stretchy="false">)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>) is</p>
<p class="disp-equ-no" id="eq_7-1"><epub:switch id="mathmlSwitch1500"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd columnalign="left"><mrow><msub><mi>&#x03B1;</mi><mrow><mi>B</mi><mo>,</mo><mi>A</mi></mrow></msub><mo>:</mo><msub><mrow><mtext>HOM</mtext></mrow><mi mathvariant='script'>A</mi></msub><mo stretchy="false">(</mo><mi>L</mi><mo stretchy='false'>(</mo><mi>B</mi><mo stretchy="false">)</mo><mo>,</mo><mi>A</mi><mo stretchy="false">)</mo><mover><mo>&#x2192;</mo><mo>&#x2245;</mo></mover><msub><mrow><mtext>HOM</mtext></mrow><mi mathvariant='script'>B</mi></msub><mo stretchy="false">(</mo><mi>B</mi><mo>,</mo><mi>R</mi><mo stretchy='false'>(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>.</mo></mrow></mtd><mtd columnalign="right"><mo stretchy='false'>(</mo><mn>7.1</mn><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">This isomorphism is called the <em>adjunction isomorphism</em> for the (<em>L</em>, <em>R</em>) adjunction, and for any morphism <em>f</em> : <em>L</em>(<em>B</em>) &#x2192; <em>A</em> in <epub:switch id="mathmlSwitch1501"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>A</mi></math></epub:case><epub:default></epub:default></epub:switch>, we refer to <em>&#x03B1;</em><sub><em>B</em>,<em>A</em></sub>(<em>f</em>): <em>B</em> &#x2192; <em>R</em>(<em>A</em>) as <em>the adjunct</em> of <em>f</em>.<sup><a id="endnote_ref_3" href="chapter007.html#endnote_3">3</a></sup></p>
<p>The functor <em>L</em> is called the <em>left adjoint</em> and the functor <em>R</em> is called the <em>right adjoint</em>. We may say that <em>L is the left adjoint of R</em> or that <em>R is the right adjoint of L</em>.<sup><a id="endnote_ref_4" href="chapter007.html#endnote_4">4</a></sup> We often denote this setup</p>
<p class="disp-equ-no" id="eq_7-2"><epub:switch id="mathmlSwitch1502"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd columnalign="left"><mrow><mi>L</mi><mo>:</mo><mi mathvariant='script'>B</mi><mo>&#x21C4;</mo><mi mathvariant='script'>A</mi><mo>:</mo><mi>R</mi></mrow></mtd><mtd columnalign="right"><mo stretchy="false">(</mo><mn>7.2</mn><mo stretchy="false">)</mo></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top-pro" id="Pro_7-1-1-2"><strong>Proposition 7.1.1.2</strong>. <em>Let L</em>: <strong>Set</strong> &#x2192; <strong>Mon</strong> <em>be the functor sending X</em> &#x2208; Ob(<strong>Set</strong>) <em>to the free monoid L</em>(<em>X</em>) &#x2254; (List(<em>X</em>), [ ], ++), <em>as in Definition</em> <a href="chapter004.html#Def_4-1-1-15">4.1.1.15</a>. <em>Let R</em>: <strong>Mon</strong> &#x2192; <strong>Set</strong> <em>be the functor sending each monoid</em> <epub:switch id="mathmlSwitch1503"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch> &#x2254; (<em>M</em>, <em>e</em>, &#x22C6;) <em>to its underlying set R</em>(<epub:switch id="mathmlSwitch1504"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch>) &#x2254; <em>M. Then L is left adjoint to R</em>.</p>
<p class="noindent1-top"><em>Proof</em>. This is precisely the content of Proposition <a href="chapter004.html#Pro_4-1-4-9">4.1.4.9</a>.</p>
<p class="noindent1-top-exe" id="Exa_7-1-1-3"><em>Example</em> 7.1.1.3. We need to ground the discussion in some concrete mathematics. In Proposition <a href="chapter007.html#Pro_7-1-1-2">7.1.1.2</a> we provided an adjunction between sets and monoids. A set <em>X</em> gets transformed into a monoid by considering lists in <em>X</em>; a monoid <epub:switch id="mathmlSwitch1505"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch> gets transformed into a set by forgetting the multiplication law. So we have a functor for translating each way,</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1506"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd><mrow><mi>L</mi><mo>:</mo><mtext mathvariant='bold'>Set</mtext><mo>&#x2192;</mo><mtext mathvariant='bold'>Mon</mtext><mo>,</mo><mo>&#x00A0;</mo></mrow></mtd><mtd><mo>&#x00A0;</mo><mrow><mi>R</mi><mo>:</mo><mtext mathvariant='bold'>Mon</mtext><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext><mo>,</mo></mrow></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">but an adjunction is more than that: it includes a guarantee about the relationship between these two functors. What is the relationship between <em>L</em> and <em>R</em>? Consider an arbitrary monoid <epub:switch id="mathmlSwitch1507"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch> = (<em>M</em>, <em>e</em>, &#x22C6;).</p>

<p>If we want to pick out three elements of the set <em>M</em>, that is the same thing as giving a function {<em>a</em>, <em>b</em>, <em>c</em>} &#x2192; <em>M</em>. But that function exists in the category of sets; in fact it is an element of Hom<strong><sub>Set</sub></strong>({<em>a</em>, <em>b</em>, <em>c</em>}, <em>M</em>). But since <em>M</em> = <em>R</em>(<epub:switch id="mathmlSwitch1508"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch>) is the underlying set of the <a id="p300"></a>monoid, we can view the current paragraph in the light of adjunction (<a href="chapter007.html#eq_7-1">7.1</a>) by saying the set</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1509"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant='bold'>Set</mtext></mrow></msub><mo stretchy='false'>(</mo><mo stretchy="false">&#x007B;</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false">&#x007D;</mo><mo>,</mo><mi>R</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>M</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">classifies all the ways to choose three elements out of the underlying set of monoid <epub:switch id="mathmlSwitch1510"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch>. It was constructed completely from within the context of sets and functions.</p>
<p>Now, what does (<a href="chapter007.html#eq_7-1">7.1</a>) mean? The equation</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1511"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant='bold'>Mon</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>L</mi><mo stretchy='false'>(</mo><mo stretchy="false">&#x007B;</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false">&#x007D;</mo><mo stretchy='false'>)</mo><mo>,</mo><mi mathvariant='script'>M</mi><mo stretchy='false'>)</mo><mo>&#x2245;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant='bold'>Set</mtext></mrow></msub><mo stretchy='false'>(</mo><mo stretchy="false">&#x007B;</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo>,</mo><mi>c</mi><mo stretchy="false">&#x007D;</mo><mo>,</mo><mi>R</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>M</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">tells us that somehow we can classify all the ways to choose three elements from <em>M</em>, while staying in the context of monoids and monoid homomorphisms. In fact, it tells us how to do so, namely, as Hom<strong><sub>Mon</sub></strong>(List({1, 2, 3}), <epub:switch id="mathmlSwitch1512"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch>). Exercise <a href="chapter007.html#Exe_7-1-1-4">7.1.1.4</a> looks at that. The answer can be extracted from the proof of Proposition <a href="chapter004.html#Pro_4-1-4-9">4.1.4.9</a>.</p>
<p class="noindent1-top-exe" id="Exe_7-1-1-4"><em>Exercise</em> 7.1.1.4.</p>
<p>Let <em>X</em> = {<em>a</em>, <em>b</em>, <em>c</em>}, and let <epub:switch id="mathmlSwitch1513"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch> = (&#x2115;, 1, &#x002A;) be the multiplicative monoid of natural numbers (see Example <a href="chapter004.html#Exa_4-1-3-2">4.1.3.2</a>). Let <em>g</em> : <em>X</em> &#x2192; &#x2115; be the function given by <em>g</em>(<em>a</em>) = 7, <em>g</em>(<em>b</em>) = 2, <em>g</em>(<em>c</em>) = 2, and let <em>&#x03B2;</em><sub><em>X</em>,<epub:switch id="mathmlSwitch1514"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch></sub> : Hom<strong><sub>Set</sub></strong>(<em>X</em>, <em>R</em>(<epub:switch id="mathmlSwitch1515"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch>)) &#x2192; Hom<strong><sub>Mon</sub></strong>(<em>L</em>(<em>X</em>), <epub:switch id="mathmlSwitch1516"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch>) be as in the proof of Proposition <a href="chapter004.html#Pro_4-1-4-9">4.1.4.9</a>.</p>
<p>Consider the list [<em>b</em>, <em>b</em>, <em>a</em>, <em>c</em>] &#x2208; <em>L</em>(<em>X</em>). What is <em>&#x03B2;</em><sub><em>X</em>,<epub:switch id="mathmlSwitch1517"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch></sub>(<em>g</em>)([<em>b</em>, <em>b</em>, <em>a</em>, <em>c</em>])?</p>
<p class="space-break">Let us look once more at the adjunction between adults and babies. Using the notation of Definition <a href="chapter007.html#Def_7-1-1-1">7.1.1.1</a>, <epub:switch id="mathmlSwitch1518"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>A</mi></math></epub:case><epub:default></epub:default></epub:switch> is the adult category of meaningful words, and <epub:switch id="mathmlSwitch1519"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>B</mi></math></epub:case><epub:default></epub:default></epub:switch> is the baby category of repeated noises. The left adjoint turns every repeated sound into a meaningful word (having free meaning), and the right adjoint forgets the meaning of any word and considers it merely as a sound.</p>
<p>At the risk of taking this simple analogy too far, let&#x2019;s look at the heart of the issue: how to conceive of the isomorphism (<a href="chapter007.html#eq_7-1">7.1</a>) of hom-sets. Once we have freely given a slot to each of the baby&#x2019;s repeated sounds, we try to find a mapping from the lexicon <em>L</em>(<em>B</em>) of these new words to the adult lexicon <em>A</em> of meaningful words; these are mappings in the adult category <epub:switch id="mathmlSwitch1520"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>A</mi></math></epub:case><epub:default></epub:default></epub:switch> of the form <em>L</em>(<em>B</em>) &#x2192; <em>A</em>. And (stretching it) the baby tries to find a mapping (which we might see as emulation) from her set <em>B</em> of repeatable sounds to the set <em>R</em>(<em>A</em>) of the sounds the adult seems to repeat. If there were a global system for making these transformations, that would establish (<a href="chapter007.html#eq_7-1">7.1</a>) and hence the adjunction.</p>
<p>Note that the directionality of the adjunction makes a difference. If <epub:switch id="mathmlSwitch1521"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>L</mi><mo>:</mo><mi mathvariant='script'>B</mi><mo>&#x2192;</mo><mi mathvariant='script'>A</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is left adjoint to <epub:switch id="mathmlSwitch1522"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>R</mi><mo>:</mo><mi mathvariant='script'>A</mi><mo>&#x2192;</mo><mi mathvariant='script'>B</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, there is no reason to think that <em>L</em> is also a right adjoint. In the case of babies and adults, we see that it would make little sense to look for a mapping in the category of meaningful words from the adult lexicon to the wordifications of baby sounds <epub:switch id="mathmlSwitch1523"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>A</mi></msub><mo stretchy='false'>(</mo><mi>A</mi><mo>,</mo><mi>L</mi><mo stretchy='false'>(</mo><mi>B</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, because there is unlikely to be a good candidate for most of the words. That is, to which of the child&#x2019;s repeated noises would we assign the concept &#x201C;weekday&#x201D;?</p>
<a id="p301"></a>
<p>Again, this is simply an analogy and should not be taken to seriously. The next example shows mathematically that the directionality of an adjunction is not arbitrary.</p>
<p class="noindent1-top-exe" id="Exa_7-1-1-5"><em>Example</em> 7.1.1.5. Let <em>L</em>: <strong>Set</strong> &#x2192; <strong>Mon</strong> and <em>R</em>: <strong>Mon</strong> &#x2192; <strong>Set</strong> be the free and forgetful functors from Proposition <a href="chapter007.html#Pro_7-1-1-2">7.1.1.2</a>. We know that <em>L</em> is left adjoint to <em>R</em>; however <em>L</em> is <em>not</em> right adjoint to <em>R</em>. In other words, we can show that the necessary natural isomorphism cannot exist.</p>
<p>Let <em>X</em> = {<em>a</em>, <em>b</em>}, and let <epub:switch id="mathmlSwitch1524"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch> = <span class="underline">1</span> be the trivial monoid. Then the necessary natural isomorphism would need to give a bijection</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1525"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant='bold'>Mon</mtext></mrow></msub><mo stretchy='false'>(</mo><mi mathvariant='script'>M</mi><mo>,</mo><mi>L</mi><mo stretchy='false'>(</mo><mi>X</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><msup><mo>&#x2245;</mo><mo>?</mo></msup><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant='bold'>Set</mtext></mrow></msub><mo stretchy='false'>(</mo><mo stretchy="false">&#x007B;</mo><mn>1</mn><mo stretchy="false">&#x007D;</mo><mo>,</mo><mi>X</mi><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">But the left-hand side has one element, because <epub:switch id="mathmlSwitch1526"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch> is the initial object in <strong>Mon</strong> (see Example <a href="chapter006.html#Exa_6-1-3-7">6.1.3.7</a>), whereas the right-hand side has two elements. Therefore, no isomorphism can exist.</p>
<p class="noindent1-top-exe" id="Exa_7-1-1-6"><em>Example</em> 7.1.1.6. Preorders have underlying sets, giving rise to a functor <em>U</em> : <strong>PrO</strong> &#x2192; <strong>Set</strong>. The functor <em>U</em> has both a left adjoint and a right adjoint. The left adjoint of <em>U</em> is <em>D</em> : <strong>Set</strong> &#x2192; <strong>PrO</strong>, sending a set <em>X</em> to the discrete preorder on <em>X</em> (the preorder with underlying set <em>X</em>, having the fewest possible &#x2A7D;&#x2019;s). The right adjoint of <em>U</em> is <em>I</em> : <strong>Set</strong> &#x2192; <strong>PrO</strong>, sending a set <em>X</em> to the indiscrete preorder on <em>X</em> (the preorder with underlying set <em>X</em>, having the most possible &#x2A7D;&#x2019;s). See Example <a href="chapter004.html#Exa_4-4-4-5">4.4.4.5</a>.</p>
<p class="noindent1-top-exe" id="Exe_7-1-1-7"><em>Exercise</em> 7.1.1.7.</p>
<p>Let <em>U</em> : <strong>Grph</strong> &#x2192; <strong>Set</strong> denote the functor sending a graph to its underlying set of vertices. This functor has both a left and a right adjoint.</p>
<p class="nl1-list">a. What functor <strong>Set</strong> &#x2192; <strong>Grph</strong> is the left adjoint of <em>U</em>?</p>
<p class="nl1-list">b. What functor <strong>Set</strong> &#x2192; <strong>Grph</strong> is the right adjoint of <em>U</em>?</p>

<p class="noindent1-top-exe" id="Exa_7-1-1-8"><em>Example</em> 7.1.1.8. Here are some other adjunctions:</p>
<ul class="ulindent"><li class="litop">Ob: <strong>Cat</strong> &#x2192; <strong>Set</strong> has a left adjoint <em>Disc</em>: <strong>Set</strong> &#x2192; <strong>Cat</strong> given by the discrete category.</li>
<li class="litop">Ob: <strong>Cat</strong> &#x2192; <strong>Set</strong> has a right adjoint <em>Ind</em>: <strong>Set</strong> &#x2192; <strong>Cat</strong> given by the indiscrete category.</li>
<li class="litop">The underlying graph functor <strong>Cat</strong> &#x2192; <strong>Grph</strong> has a left adjoint <strong>Grph</strong> &#x2192; <strong>Cat</strong> given by the free category.</li>
<li class="litop">The inclusion <strong>Grp</strong> &#x2192; <strong>Mon</strong> has a right adjoint <epub:switch id="mathmlSwitch1527"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext mathvariant='bold'>Mon</mtext><mover><mo>&#x2192;</mo><mtext>Core</mtext></mover><mtext mathvariant='bold'>Grp</mtext></math></epub:case><epub:default></epub:default></epub:switch>, called the <em>core</em>, that sends a monoid to its subgroup of invertible elements.</li>
<li class="litop"><a id="p302"></a>The functor <strong>PrO</strong> &#x2192; <strong>Grph</strong>, given by drawing edges for &#x2A7D;&#x2019;s, has a left adjoint given by existence of paths.</li>
<li class="litop">The forgetful functor from partial orders to preorders has a left adjoint given by quotienting out the cliques (see Exercise <a href="chapter004.html#Exe_4-4-1-15">4.4.1.15</a>).</li>
<li class="litop">Given a set <em>A</em>, the functor (&#x2212; &#x00D7; <em>A</em>): <strong>Set</strong> &#x2192; <strong>Set</strong> has a right adjoint Hom(<em>A</em>, &#x2212;) (this was called currying in Section <a href="chapter003.html#lev_3-4-2">3.4.2</a>).</li></ul>
<p class="noindent1-top-exe" id="Exe_7-1-1-9"><em>Exercise</em> 7.1.1.9.</p>
<p>Let <span class="underline">1</span> denote the terminal category. There is a unique functor &#x0021;: <strong>Set</strong> &#x2192; <span class="underline">1</span>.</p>
<p class="nl1-list">a. Does &#x0021; have a left adjoint? If so, what is it; if not, why not?</p>
<p class="nl1-list">b. Does &#x0021; have a right adjoint? If so, what is it; if not, why not?</p>

<p class="noindent1-top-exe" id="Exe_7-1-1-10"><em>Exercise</em> 7.1.1.10.</p>
<p>The discrete category functor <em>Disc</em>: <strong>Set</strong> &#x2192; <strong>Cat</strong> has a left adjoint <em>p</em>: <strong>Cat</strong> &#x2192; <strong>Set</strong>. In this exercise you will work out how to unpack this idea and begin to deduce how <em>p</em> must behave.</p>
<p class="nl1-list">a. For an arbitrary object <em>X</em> &#x2208; Ob(<strong>Set</strong>) and an arbitrary object <epub:switch id="mathmlSwitch1528"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mtext mathvariant="bold">Cat</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, write the adjunction in the style of (<a href="chapter007.html#eq_7-2">7.2</a>), appropriately filling in all the variables (e.g., decide whether <epub:switch id="mathmlSwitch1529"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>B</mi></math></epub:case><epub:default></epub:default></epub:switch> = <strong>Cat</strong> or <epub:switch id="mathmlSwitch1530"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>B</mi></math></epub:case><epub:default></epub:default></epub:switch> = <strong>Set</strong>, etc.).</p>
<p class="nl1-list">b. For <em>X</em> and <epub:switch id="mathmlSwitch1531"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> as in part (a), write the adjunction isomorphism in the style of (<a href="chapter007.html#eq_7-1">7.1</a>), appropriately filling in all the variables.</p>
<p class="nl1-list">c. Let <epub:switch id="mathmlSwitch1532"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> be the free category on the graph <em>G</em></p>
<p class="fig-img"><img src="images/Art_P278.jpg" alt="art"/></p>
<p class="nl1-list-para">and let <em>X</em> = {1, 2, 3}. How many elements does the set <epub:switch id="mathmlSwitch1533"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant='bold'>Cat</mtext></mrow></msub><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>,</mo><mi mathvariant="italic">Disc</mi><mo stretchy='false'>(</mo><mi>X</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> have?</p>
<p class="nl1-list"><a id="p303"></a>d. What can you do to an arbitrary category <epub:switch id="mathmlSwitch1534"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mtext mathvariant="bold">Cat</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> to make a set <epub:switch id="mathmlSwitch1535"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>p</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> such that the adjunction isomorphism holds? That is, how does the functor <em>p</em>: <strong>Cat</strong> &#x2192; <strong>Set</strong> behave on objects?</p>

<p class="space-break">The following proposition says that all adjoints to a given functor are isomorphic to each other.</p>
<p class="noindent1-top-pro" id="Pro_7-1-1-11"><strong>Proposition 7.1.1.11</strong>. <em>Let</em> <epub:switch id="mathmlSwitch1536"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> <em>and</em> <epub:switch id="mathmlSwitch1537"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> <em>be categories, let</em> <epub:switch id="mathmlSwitch1538"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>be a functor, and let</em> <epub:switch id="mathmlSwitch1539"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>G</mi><mo>,</mo><mi>G</mi><mo>&#x2032;</mo><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>also be functors. If both G and G&#x2032; are right adjoint (resp. if both are left adjoint) to F, then there is a natural isomorphism</em> <epub:switch id="mathmlSwitch1540"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x03D5;</mi><mo>:</mo><mi>G</mi><mover><mo>&#x2192;</mo><mo>&#x2245;</mo></mover><mi>G</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="noindent1-top"><em>Proof</em>. Suppose that both <em>G</em> and <em>G</em>&#x2032; are right adjoint to <em>F</em> (the case of <em>G</em> and <em>G</em>&#x2032; being left adjoint is similarly proved). We first give a formula for the components of <em>&#x03D5;</em>: <em>G</em> &#x2192; <em>G</em>&#x2032; and its inverse <em>&#x03C8;</em> : <em>G</em>&#x2032; &#x2192; <em>G</em>. Given an object <epub:switch id="mathmlSwitch1541"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>d</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy="false">(</mo><mi mathvariant='script'>D</mi><mo stretchy="false">)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we use <em>c</em> = <em>G</em>(<em>d</em>) to obtain two natural isomorphisms, one from each adjunction:</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1542"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>G</mi><mo stretchy='false'>(</mo><mi>d</mi><mo stretchy='false'>)</mo><mo>,</mo><mi>G</mi><mo stretchy='false'>(</mo><mi>d</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>&#x2245;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>D</mi></msub><mo stretchy='false'>(</mo><mi>F</mi><mo stretchy='false'>(</mo><mi>G</mi><mo stretchy='false'>(</mo><mi>d</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>,</mo><mi>d</mi><mo stretchy='false'>)</mo><mo>&#x2245;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>G</mi><mo stretchy='false'>(</mo><mi>d</mi><mo stretchy='false'>)</mo><mo>,</mo><mi>G</mi><mo>&#x2032;</mo><mo stretchy='false'>(</mo><mi>d</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">The identity morphism id<sub><em>G</em>(<em>d</em>)</sub> is then sent to some morphism <em>G</em>(<em>d</em>) &#x2192; <em>G</em>&#x2032;(<em>d</em>), which we take to be the component <em>&#x03D5;<sub>d</sub></em>. Similarly, we use <em>c</em>&#x2032; = <em>G</em>&#x2032;(<em>d</em>) to obtain two natural isomorphisms, one from each adjunction:</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1543"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>G</mi><mo>&#x2032;</mo><mo stretchy='false'>(</mo><mi>d</mi><mo stretchy='false'>)</mo><mo>,</mo><mi>G</mi><mo>&#x2032;</mo><mo stretchy='false'>(</mo><mi>d</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>&#x2245;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>D</mi></msub><mo stretchy='false'>(</mo><mi>F</mi><mo stretchy='false'>(</mo><mi>G</mi><mo>&#x2032;</mo><mo stretchy='false'>(</mo><mi>d</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>,</mo><mi>d</mi><mo stretchy='false'>)</mo><mo>&#x2245;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>G</mi><mo>&#x2032;</mo><mo stretchy='false'>(</mo><mi>d</mi><mo stretchy='false'>)</mo><mo>,</mo><mi>G</mi><mo stretchy='false'>(</mo><mi>d</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">Again, the identity element id<sub><em>G</em>&#x2032;(<em>d</em>)</sub> is sent to some morphism <em>G</em>&#x2032;(<em>d</em>) &#x2192; <em>G</em>(<em>d</em>), which we take to be the <em>d</em>-component <em>&#x03C8;<sub>d</sub></em>. The naturality of the adjunction isomorphisms implies that <em>&#x03D5;</em> and <em>&#x03C8;</em> are natural transformations, and it is straightforward to check that they are mutually inverse.</p>
<section title="Quantifiers as adjoints">
<h3 class="level3" id="lev_7-1-1-12"><strong>7.1.1.12&#160;&#160;&#160;Quantifiers as adjoints</strong></h3>
<p class="noindent">One of the simplest places where adjoints show up is between preimages and the logical quantifiers &#x2203; and &#x2200;, ideas first discussed in Notation <a href="chapter002.html#Not_2-1-1-1">2.1.1.1</a>. The setting in which to discuss this is that of sets and their power preorders. That is, if <em>X</em> is a set, then recall from Section <a href="chapter004.html#lev_4-4-2">4.4.2</a> that the power-set &#x2119;(<em>X</em>) has a natural ordering by inclusion of subsets.</p>
<p>Given a function <em>f</em> : <em>X</em> &#x2192; <em>Y</em> and a subset <em>V</em> &#x2286; <em>Y</em> the preimage is <em>f</em><sup>&#x2212;1</sup>(<em>V</em>) &#x2254; {<em>x</em> &#x2208; <em>X</em> &#x007C; <em>f</em>(<em>x</em>) &#x2208; <em>V</em>}. If <em>V</em>&#x2032; &#x2286; <em>V</em>, then <em>f</em><sup>&#x2212;1</sup>(<em>V</em>&#x2032;) &#x2286; <em>f</em><sup>&#x2212;1</sup>(<em>V</em>), so in fact <em>f</em><sup>&#x2212;1</sup> : &#x2119;(<em>Y</em>) &#x2192; &#x2119;(<em>X</em>) can be considered a functor (where of course we are thinking of preorders as categories). The quantifiers &#x2203; and &#x2200; appear as adjoints of <em>f</em><sup>&#x2212;1</sup>.</p>
<a id="p304"></a>
<p>Let&#x2019;s begin with the left adjoint of <em>f</em><sup>&#x2212;1</sup> : &#x2119;(<em>Y</em>) &#x2192; &#x2119;(<em>X</em>). It is a functor <em>L<sub>f</sub></em> : &#x2119;(<em>X</em>) &#x2192; &#x2119;(<em>Y</em>). Choose an object <em>U</em> &#x2286; <em>X</em> in &#x2119;(<em>X</em>). It turns out that</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1544"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>L</mi><mi>f</mi></msub><mo stretchy='false'>(</mo><mi>U</mi><mo stretchy='false'>)</mo><mo>=</mo><mo stretchy="false">&#x007B;</mo><mi>y</mi><mo>&#x2208;</mo><mi>Y</mi><mo stretchy="false">&#x007C;</mo><mo>&#x2203;</mo><mi>x</mi><mo>&#x2208;</mo><msup><mi>f</mi><mrow><mo>&#x2212;</mo><mn>1</mn></mrow></msup><mo stretchy='false'>(</mo><mi>y</mi><mo stretchy='false'>)</mo><mo>&#x00A0;</mo><mtext>such that</mtext><mo>&#x00A0;</mo><mi>x</mi><mo>&#x2208;</mo><mi>U</mi><mo stretchy="false">&#x007D;</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">And the right adjoint <em>R<sub>f</sub></em> : &#x2119;(<em>X</em>) &#x2192; &#x2119;(<em>Y</em>), when applied to <em>U</em>, is</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1545"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>R</mi><mi>f</mi></msub><mo stretchy='false'>(</mo><mi>U</mi><mo stretchy='false'>)</mo><mo>=</mo><mo stretchy="false">&#x007B;</mo><mi>y</mi><mo>&#x2208;</mo><mi>Y</mi><mo stretchy="false">&#x007C;</mo><mo>&#x2200;</mo><mi>x</mi><mo>&#x2208;</mo><msup><mi>f</mi><mrow><mo>&#x2212;</mo><mn>1</mn></mrow></msup><mo stretchy='false'>(</mo><mi>y</mi><mo stretchy='false'>)</mo><mo>,</mo><mi>x</mi><mo>&#x2208;</mo><mi>U</mi><mo stretchy="false">&#x007D;</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">In fact, the functor <em>L<sub>f</sub></em> is generally denoted &#x2203;<em><sub>f</sub></em> : &#x2119;(<em>X</em>) &#x2192; &#x2119;(<em>Y</em>), and <em>R<sub>f</sub></em> is generally denoted &#x2200;<em><sub>f</sub></em> : &#x2119;(<em>X</em>) &#x2192; &#x2119;(<em>Y</em>).</p>
<p class="fig-img"><img src="images/Art_P279.jpg" alt="art"/></p>
<p class="noindent">The next example shows why this notation is apt.</p>

<p class="noindent1-top-exe" id="Exa_7-1-1-13"><em>Example</em> 7.1.1.13. In logic or computer science the quantifiers &#x2203; and &#x2200; are used to ask whether any or all elements of a set have a certain property. For example, one may have a set <em>U</em> of natural numbers and want to know whether any or all are even or odd. Let <em>Y</em> = {<span class="font1">even</span>, <span class="font1">odd</span>}, and let</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1546"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>p</mi><mo>:</mo><mi>&#x2115;</mi><mo>&#x2192;</mo><mi>Y</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">be the function that assigns to each natural number its parity (even or odd). Because the elements of &#x2119;(&#x2115;) and &#x2119;(<em>Y</em>) are ordered by inclusion of subsets, we can construe these orders as categories (by Proposition <a href="chapter005.html#Pro_5-2-1-13">5.2.1.13</a>). What is new is that we have adjunctions between these categories:</p>
<p class="fig-img"><img src="images/Art_P280.jpg" alt="art"/></p>
<p class="noindent">Given a subset <em>U</em> &#x2286; &#x2115;, i.e., an object <em>U</em> &#x2208; Ob(&#x2119;(&#x2115;)), we investigate the objects &#x2203;<em><sub>p</sub></em>(<em>U</em>), &#x2200;<em><sub>p</sub></em>(<em>U</em>). These are both subsets of {<span class="font1">even</span>, <span class="font1">odd</span>}. The set &#x2203;<em><sub>p</sub></em>(<em>U</em>) includes the element <span class="font1">even</span> if there exists an even number in <em>U</em>; it includes the element <span class="font1">odd</span> if there exists an odd number in <em>U</em>. Similarly, the set &#x2200;<em><sub>p</sub></em>(<em>U</em>) includes the element <span class="font1">even</span> if every even number is in <em>U</em>, and it includes <span class="font1">odd</span> if every odd number is in <em>U</em>.</p>
<p>Let&#x2019;s use the definition of adjunction to ask whether every element of <em>U</em> &#x2286; &#x2115; is even. Let <em>V</em> = {<span class="font1">even</span>} &#x2286; <em>Y</em>. Then <em>f</em><sup>&#x2212;1</sup>(<em>V</em>) &#x2286; &#x2115; is the set of even numbers, and there is a morphism <em>U</em> &#x2192; <em>f</em><sup>&#x2212;1</sup>(<em>V</em>) in the preorder &#x2119;(&#x2115;) if and only if every element of <em>U</em> is even. Therefore, the adjunction isomorphism Hom<sub>&#x2119;(&#x2115;)</sub>(<em>U</em>, <em>f</em><sup>&#x2212;1</sup>(<em>V</em>)) &#x2245; Hom<sub>&#x2119;(<em>Y</em>)</sub>(&#x2203;<em><sub>p</sub></em><em>U</em>, <em>V</em>) says that &#x2203;<em><sub>p</sub>U</em> &#x2286; {<span class="font1">even</span>} if and only if every element of <em>U</em> is even.</p>
<a id="p305"></a>
<p class="noindent1-top-exe" id="Exe_7-1-1-14"><em>Exercise</em> 7.1.1.14.</p>
<p>The national scout jamboree is a gathering of Boy Scouts from troops across the United States. Let <em>S</em> be the set of Boy Scouts in the U.S., and let <em>T</em> be the set of Boy Scout troops in the U.S. Let <em>t</em>: <em>S</em> &#x2192; <em>T</em> be the function that assigns to each Boy Scout his troop. Let <em>U</em> &#x2286; <em>S</em> be the set of Boy Scouts in attendance at this year&#x2019;s jamboree.</p>
<p class="nl1-list">a. What is the meaning of the object &#x2203;<em><sub>t</sub>U</em></p>
<p class="nl1-list">b. What is the meaning of the object &#x2200;<em><sub>t</sub>U</em>?</p>

<p class="noindent1-top-exe" id="Exe_7-1-1-15"><em>Exercise</em> 7.1.1.15.</p>
<p>Let <em>X</em> be an arbitrary set and <em>U</em> &#x2286; <em>X</em> a subset.</p>
<p class="nl1-list">a. Find a set <em>Y</em> and a function <em>f</em> : <em>X</em> &#x2192; <em>Y</em> such that &#x2203;<em><sub>f</sub>U</em> tells you whether <em>U</em> is nonempty.</p>
<p class="nl1-list">b. What is the meaning of &#x2200;<em><sub>f</sub>U</em> for your choice of <em>Y</em> and <em>f</em>?</p>
<p class="space-break">In fact, the idea of quantifiers as adjoints is part of a larger story. Suppose we think of elements of a set <em>X</em> as bins, or storage areas. An element of &#x2119;(<em>X</em>) can be construed as an injection <em>U</em> &#x21AA; <em>X</em>, i.e., an assignment of a bin to each element of <em>U</em>, with at most one element of <em>U</em> in each bin. Relaxing the injectivity restriction, we may consider arbitrary sets <em>U</em> and assignments <em>U</em> &#x2192; <em>X</em> of a bin to each element <em>u</em> &#x2208; <em>U</em>. Given a function <em>f</em> : <em>X</em> &#x2192; <em>Y</em> , we can generalize &#x2203;<em><sub>f</sub></em> and &#x2200;<em><sub>f</sub></em> to functors denoted &#x03A3;<em><sub>f</sub></em> and &#x03A0;<em><sub>f</sub></em>, which will parameterize disjoint unions and products (respectively) over <em>y</em> &#x2208; <em>Y</em> . This is discussed in Section <a href="chapter007.html#lev_7-1-4">7.1.4</a>.</p>
</section>
</section>
<section title="Universal concepts in terms of adjoints">
<h2 class="level2" id="lev_7-1-2"><strong>7.1.2&#160;&#160;&#160;Universal concepts in terms of adjoints</strong></h2>
<p class="noindent">This section explores how universal concepts, i.e., initial objects and terminal objects, colimits and limits, are easily phrased in the language of adjoint functors. We say that a functor <epub:switch id="mathmlSwitch1547"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>is a left adjoint</em> or <em>has a right adjoint</em> if there exists a functor <epub:switch id="mathmlSwitch1548"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>G</mi><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> such that <em>F</em> is a left adjoint of <em>G</em>. Proposition <a href="chapter007.html#Pro_7-1-1-11">7.1.1.11</a> showed that if <em>F</em> is a left adjoint of some functor <em>G</em>, then it is isomorphic to every other left adjoint of <em>G</em>, and <em>G</em> is isomorphic to every other right adjoint of <em>F</em>.</p>

<p class="noindent1-top-exe" id="Exa_7-1-2-1"><em>Example</em> 7.1.2.1. Let <epub:switch id="mathmlSwitch1549"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> be a category and <epub:switch id="mathmlSwitch1550"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>t</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder></mrow></math></epub:case><epub:default></epub:default></epub:switch> the unique functor to the terminal category. Then <em>t</em> has a right adjoint if and only if <epub:switch id="mathmlSwitch1551"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> has a terminal object, and <em>t</em> has a left adjoint if and only if <epub:switch id="mathmlSwitch1552"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> has an initial object. The proofs are dual, so let&#x2019;s focus on the first.</p>
<a id="p306"></a>
<p>The functor <em>t</em> has a right adjoint <epub:switch id="mathmlSwitch1553"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>R</mi><mo>:</mo><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> if and only if for every object <epub:switch id="mathmlSwitch1554"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> there is an isomorphism</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1555"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>r</mi><mo stretchy='false'>)</mo><mo>&#x2245;</mo><msub><mstyle displaystyle='true'><mrow><mtext>Hom</mtext></mrow></mstyle><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder></msub><mo stretchy='false'>(</mo><mi>t</mi><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>,</mo><mn>1</mn><mo stretchy='false'>)</mo><mo>,</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">where <em>r</em> = <em>R</em>(1). But Hom<sub><span class="underline">1</span></sub>(<em>t</em>(<em>c</em>), 1) has one element. Thus <em>t</em> has a right adjoint iff <epub:switch id="mathmlSwitch1556"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>r</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> has one element for each <epub:switch id="mathmlSwitch1557"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. This is the definition of <em>r</em> being a terminal object.</p>
<p>When colimits and limits were defined in Definitions <a href="chapter006.html#Def_6-1-3-31">6.1.3.31</a> and <a href="chapter006.html#Def_6-1-3-20">6.1.3.20</a>, it was for individual <em>I</em>-shaped diagrams <epub:switch id="mathmlSwitch1558"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi><mo>:</mo><mi>I</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Using adjoints we can define the limit of every <em>I</em>-shaped diagram in <epub:switch id="mathmlSwitch1559"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> at once.</p>
<p>Let <em>t</em>: <em>I</em> &#x2192; <span class="underline">1</span> denote the unique functor to the terminal category. Suppose given an object <epub:switch id="mathmlSwitch1560"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, represented by the functor <epub:switch id="mathmlSwitch1561"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>:</mo><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Then <epub:switch id="mathmlSwitch1562"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x25CB;</mo><mi>t</mi><mo>:</mo><mi>I</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is the <em>constant functor at c</em>, sending each object in <em>I</em> to the same <epub:switch id="mathmlSwitch1563"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mtext>-object</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <em>c</em>, and every morphism in <em>I</em> to id<em><sub>c</sub></em>. Thus composing with <em>t</em> induces a functor <epub:switch id="mathmlSwitch1564"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2245;</mo><mtext>Fun</mtext><mo stretchy='false'>(</mo><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder><mo>,</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi>I</mi><mo>,</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, denoted <epub:switch id="mathmlSwitch1565"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x0394;</mo><mi>t</mi></msub><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi>I</mi><mo>,</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. It sends each object <em>c</em> to the associated constant functor <em>c</em> &#x25CB; <em>t</em>.</p>
<p>Suppose we want to take the colimit or limit of <em>X</em>. We are given an object <em>X</em> of <epub:switch id="mathmlSwitch1566"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi>I</mi><mo>,</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and we want back an object of <epub:switch id="mathmlSwitch1567"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>. We could hope, and it turns out to be true, that the adjoints of &#x0394;<em><sub>t</sub></em> are the limit and colimit. Indeed, let <epub:switch id="mathmlSwitch1568"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A3;</mo><mi>t</mi></msub><mo>:</mo><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi>I</mi><mo>,</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> denote the left adjoint of &#x0394;<em><sub>t</sub></em>, and let <epub:switch id="mathmlSwitch1569"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A0;</mo><mi>t</mi></msub><mo>:</mo><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi>I</mi><mo>,</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> denote the right adjoint of &#x0394;<em><sub>t</sub></em>. Then &#x03A3;<em><sub>t</sub></em> is the functor that takes colimits, and &#x03A0;<em><sub>t</sub></em> is the functor that takes limits.</p>
<p>A generalization of colimits and limits is given in Section <a href="chapter007.html#lev_7-1-4">7.1.4</a>. But for now, let&#x2019;s consider a concrete example.</p>
<p class="noindent1-top-exe" id="Exa_7-1-2-2"><em>Example</em> 7.1.2.2. Let <epub:switch id="mathmlSwitch1570"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>=</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and let <em>I</em> = <span class="underline">3</span>. The category Fun(<span class="underline">3</span>, <strong>Set</strong>) is the category of {1, 2, 3}-indexed sets, e.g., (&#x2124;, &#x2115;, &#x2124;) &#x2208; Ob(Fun(<span class="underline">3</span>, <strong>Set</strong>)) is an object of it. We will obtain the limit, i.e., the product of these three sets <span class="underline">3</span> &#x2192; <strong>Set</strong> using adjoints.</p>
<p>In fact, the limit will be right adjoint to a functor &#x0394;<em><sub>t</sub></em>: <strong>Set</strong> &#x2192; Fun(<span class="underline">3</span>, <strong>Set</strong>), defined as follows. Given a set <em>c</em> &#x2208; Ob(<strong>Set</strong>), represented by a functor <em>c</em>: <span class="underline">1</span> &#x2192; <strong>Set</strong>, and define &#x0394;<em><sub>t</sub></em>(<em>c</em>) to be the composite <em>c</em> &#x25CB; <em>t</em>: <span class="underline">3</span> &#x2192; <strong>Set</strong>; it is the constant functor. That is, &#x0394;<em><sub>t</sub></em>(<em>c</em>): <span class="underline">3</span> &#x2192; <strong>Set</strong> is the {1, 2, 3}-indexed set (<em>c</em>, <em>c</em>, <em>c</em>).</p>
<p>To say that &#x0394;<em><sub>t</sub></em> has a right adjoint called &#x03A0;<em><sub>t</sub></em> : Fun(<span class="underline">3</span>, <strong>Set</strong>) &#x2192; <strong>Set</strong> and that &#x03A0;<em><sub>t</sub></em> takes limits should mean that the definition of right adjoint provides the formula that yields the appropriate limit. Fix a functor <em>D</em> : <span class="underline">3</span> &#x2192; <strong>Set</strong>, so <em>D</em>(1), <em>D</em>(2), and <em>D</em>(3) are sets. We know from Example <a href="chapter006.html#Exa_6-1-3-25">6.1.3.25</a> that the limit, lim <em>D</em>, of <em>D</em> is supposed to be the product <em>D</em>(1) &#x00D7; <em>D</em>(2) &#x00D7; <em>D</em>(3). For example, if <em>D</em> = (&#x2124;, &#x2115;, &#x2124;), then lim <em>D</em> = &#x2124; &#x00D7; &#x2115; &#x00D7; &#x2124;. How does this fact arise in the definition of adjoint?</p>

<p>The definition of &#x03A0;<em><sub>t</sub></em> being the right adjoint to &#x0394;<em><sub>t</sub></em> says that for any <em>c</em> &#x2208; Ob(<strong>Set</strong>) and <em>D</em> &#x2208; Fun(<span class="underline">3</span>, <strong>Set</strong>), there is a natural isomorphism of sets,</p>
<p class="disp-equ" id="eq_7-3"><epub:switch id="mathmlSwitch1571"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd columnalign="left"><mrow><msub><mi>&#x03B1;</mi><mrow><mi>c</mi><mo>,</mo><mi>D</mi></mrow></msub><mo>:</mo><msub><mstyle displaystyle='true'><mrow><mtext>Hom</mtext></mrow></mstyle><mrow><mtext>Fun</mtext><mo stretchy="false">(</mo><munder accentunder='true'><mn> 3</mn><mo>&#x00AF;</mo></munder><mo>,</mo><mtext mathvariant='bold'>Set</mtext><mo stretchy="false">)</mo></mrow></msub><mo stretchy='false'>(</mo><msub><mo>&#x0394;</mo><mi>t</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>,</mo><mi>D</mi><mo stretchy='false'>)</mo><mo>&#x2245;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant='bold'>Set</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><msub><mo>&#x03A0;</mo><mi>t</mi></msub><mo stretchy='false'>(</mo><mi>D</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>.</mo></mrow></mtd><mtd columnalign="right"><mrow><mo stretchy='false'>(</mo><mn>7.3</mn><mo stretchy='false'>)</mo></mrow></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<a id="p307"></a>
<p class="noindent">The domain of <em>&#x03B1;</em><sub><em>c</em>,<em>D</em></sub> has elements <em>f</em> &#x2208; Hom<sub>Fun(<span class="underline">3</span>,<strong>Set</strong>)</sub>(&#x0394;<sub><em>t</em></sub>(<em>c</em>), <em>D</em>) that look like the left-hand drawing, but having these three maps is equivalent to having the right-hand diagram:</p>
<p class="fig-img"><img src="images/Art_P281.jpg" alt="art"/></p>
<p class="noindent">The isomorphism <em>&#x03B1;</em><sub><em>c</em>,<em>D</em></sub> in (<a href="chapter007.html#eq_7-3">7.3</a>) says that choosing the three functions <em>f</em>(1), <em>f</em>(2), <em>f</em>(3) is the same thing as choosing a function <em>c</em> &#x2192; &#x03A0;<em><sub>t</sub></em>(<em>D</em>). This is basically the universal property for limits: there is a unique function <em>&#x2113;</em>: <em>c</em> &#x2192; <em>D</em>(1) &#x00D7; <em>D</em>(2) &#x00D7; <em>D</em>(3), so this product is isomorphic to &#x03A0;<em><sub>t</sub></em>. I have not given a formal proof here but hopefully enough for the interested reader to work it out.</p>
</section>
<section title="Preservation of colimits or limits">
<h2 class="level2" id="lev_7-1-3"><strong>7.1.3&#160;&#160;&#160;Preservation of colimits or limits</strong></h2>
<p class="noindent">One useful fact about adjunctions is that left adjoints preserve all colimits, and right adjoints preserve all limits.</p>
<p class="noindent1-top-pro" id="Pro_7-1-3-1"><strong>Proposition 7.1.3.1</strong>. <em>Let</em> <epub:switch id="mathmlSwitch1572"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>L</mi><mo>:</mo><mi mathvariant='script'>B</mi><mo>&#x21C4;</mo><mi mathvariant='script'>A</mi><mo>&#x00A0;</mo><mo>:</mo><mi>R</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>be an adjunction. For any indexing category I and functor D</em> : <em>I</em> &#x2192; <epub:switch id="mathmlSwitch1573"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>B</mi></math></epub:case><epub:default></epub:default></epub:switch>, <em>if D has a colimit in</em> <epub:switch id="mathmlSwitch1574"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>B</mi></math></epub:case><epub:default></epub:default></epub:switch>, <em>then there is a unique isomorphism</em></p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1575"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>L</mi><mo stretchy='false'>(</mo><mtext>colim</mtext><mo>&#x00A0;</mo><mi>D</mi><mo stretchy='false'>)</mo><mo>&#x2245;</mo><mtext>colim</mtext><mo stretchy='false'>(</mo><mi>L</mi><mo>&#x25CB;</mo><mi>D</mi><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p><em>Similarly, for any I</em> &#x2208; Ob(<strong>Cat</strong>) <em>and functor</em> <epub:switch id="mathmlSwitch1576"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>D</mi><mo>:</mo><mi>I</mi><mo>&#x2192;</mo><mi mathvariant='script'>A</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <em>if D has a limit in</em> <epub:switch id="mathmlSwitch1577"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>A</mi></math></epub:case><epub:default></epub:default></epub:switch><em>, then there is a unique isomorphism</em></p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1578"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>R</mi><mo stretchy='false'>(</mo><mi>lim</mi><mo>&#x2061;</mo><mi>D</mi><mo stretchy='false'>)</mo><mo>&#x2245;</mo><mi>lim</mi><mo>&#x2061;</mo><mo stretchy='false'>(</mo><mi>R</mi><mo>&#x25CB;</mo><mi>D</mi><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top"><em>Proof</em>. The proof is simple if one knows the Yoneda lemma (Section <a href="chapter007.html#lev_7-2-1-14">7.2.1.14</a>). See Mac Lane [29] for details.</p>

<p class="noindent1-top-exe" id="Exa_7-1-3-2"><em>Example</em> 7.1.3.2. Since Ob: <strong>Cat</strong> &#x2192; <strong>Set</strong> is both a left adjoint and a right adjoint, it must preserve both limits and colimits. This means that if one wants to know the set of objects in the fiber product of some categories, one can simply take the fiber product of the set of objects in those categories,</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1579"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo stretchy="false">(</mo><mi mathvariant='script'>A</mi><msub><mo>&#x00D7;</mo><mi mathvariant='script'>C</mi></msub><mi mathvariant='script'>B</mi><mo stretchy="false">)</mo><mo>&#x2245;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>A</mi><mo stretchy='false'>)</mo><msub><mo>&#x00D7;</mo><mrow><mtext>Ob</mtext><mo stretchy="false">(</mo><mi mathvariant='script'>C</mi><mo stretchy="false">)</mo></mrow></msub><mtext>Ob</mtext><mo stretchy="false">(</mo><mi mathvariant='script'>B</mi><mo stretchy="false">)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<a id="p308"></a>
<p class="noindent">While the right-hand side might look daunting, it is just a fiber product in <strong>Set</strong>, which is quite understandable (see Definition <a href="chapter003.html#Def_3-2-1-1">3.2.1.1</a>).</p>
<p>This is greatly simplifying. If one thinks through what defines a limit in <strong>Cat</strong>, one encounters notions of slice categories and terminal objects in them. These slice categories are in <strong>Cat</strong> so they involve several categories and functors, and it is difficult for a beginner. Knowing that the objects are given by a simple fiber product makes the search for limits in <strong>Cat</strong> much simpler.</p>
<p>For example, if [<em>n</em>] is the linear order category of length <em>n</em>, then [<em>n</em>] &#x00D7; [<em>m</em>] has (<em>n</em> + 1)(<em>m</em> + 1) objects because [<em>n</em>] has <em>n</em> + 1 objects and [<em>m</em>] has <em>m</em> + 1 objects.</p>
<p class="noindent1-top-exe" id="Exa_7-1-3-3"><em>Example</em> 7.1.3.3. The path preorder functor <em>L</em>: <strong>Grph</strong> &#x2192; <strong>PrO</strong> given by existence of paths (see Exercise <a href="chapter005.html#Exe_5-1-2-13">5.1.2.13</a>) is left adjoint to the functor <em>R</em>: <strong>PrO</strong> &#x2192; <strong>Grph</strong> given by replacing &#x2A7D;&#x2019;s by arrows. This means that <em>L</em> preserves colimits. So taking the union of graphs <em>G</em> and <em>H</em> results in a graph whose path poset <em>L</em>(<em>G</em> &#x2294; <em>H</em>) is the union of the path posets of <em>G</em> and <em>H</em>. But this is not so for products, i.e., we do not expect to have an isomorphism <em>L</em>(<em>G</em> &#x00D7; <em>H</em>) &#x2245;<sup>?</sup> <em>L</em>(<em>G</em>) &#x00D7; <em>L</em>(<em>H</em>).</p>
<p>As an example, let <img src="images/Art_P282.jpg" alt="art"/>. Then <em>L</em>(<em>G</em>) = <em>L</em>(<em>H</em>) = [1], the linear order of length 1. But the product <em>G</em> &#x00D7; <em>H</em> in <strong>Grph</strong> looks like the graph</p>
<p class="fig-img"><img src="images/Art_P283.jpg" alt="art"/></p>
<p class="noindent">Its preorder <em>L</em>(<em>G</em> &#x00D7; <em>H</em>) does not have (<em>a</em>, <em>a</em>) &#x2A7D; (<em>a</em>, <em>b</em>), whereas this is the case in the preorder <em>L</em>(<em>G</em>) &#x00D7; <em>L</em>(<em>H</em>). So <em>L</em>(<em>G</em> &#x00D7; <em>H</em>) &#x2247; <em>L</em>(<em>G</em>) &#x00D7; <em>L</em>(<em>H</em>). The left adjoint preservers all colimits, but not necessarily limits.</p>
</section>
<section title="Data migration">
<h2 class="level2" id="lev_7-1-4"><strong>7.1.4&#160;&#160;&#160;Data migration</strong></h2>
<p class="noindent">As we saw in Sections <a href="chapter005.html#lev_5-2-2">5.2.2</a> and <a href="chapter005.html#lev_5-2-2-6">5.2.2.6</a>, a database schema is a category <epub:switch id="mathmlSwitch1580"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, and an instance is a functor <epub:switch id="mathmlSwitch1581"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>

<p class="noindent1-top-not" id="Not_7-1-4-1"><em>Notation</em> 7.1.4.1. Let <epub:switch id="mathmlSwitch1582"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> be a category. The category <epub:switch id="mathmlSwitch1583"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>,</mo><mtext mathvariant='bold'>Set</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> of functors from <epub:switch id="mathmlSwitch1584"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> to <strong>Set</strong>, i.e., the category of instances on <epub:switch id="mathmlSwitch1585"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, is denoted <epub:switch id="mathmlSwitch1586"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi><mo>&#x2013;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p>This section discusses what happens to the resulting instances when different schemas are connected by a functor, say, <epub:switch id="mathmlSwitch1587"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>. It turns out that three adjoint functors emerge: <epub:switch id="mathmlSwitch1588"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x0394;</mo><mi>F</mi></msub><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <epub:switch id="mathmlSwitch1589"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A3;</mo><mi>F</mi></msub><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo>&#x2192;</mo><mi mathvariant='script'>D</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and <epub:switch id="mathmlSwitch1590"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A0;</mo><mi>F</mi></msub><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo>&#x2192;</mo><mi mathvariant='script'>D</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, where <a id="p309"></a>&#x0394;<em><sub>F</sub></em> is adjoint to both of them:</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1591"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd><mrow><msub><mo>&#x03A3;</mo><mi>F</mi></msub><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo>&#x21C4;</mo><mi mathvariant='script'>D</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo>&#x00A0;</mo><mo>:</mo><msub><mo>&#x0394;</mo><mi>F</mi></msub></mrow></mtd><mtd><mrow><msub><mo>&#x0394;</mo><mi>F</mi></msub><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo>&#x21C4;</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo>&#x00A0;</mo><mo>:</mo><msub><mo>&#x03A0;</mo><mi>F</mi></msub><mo>.</mo></mrow></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">Interestingly, many of the basic database operations are captured by these three functors. For example, &#x0394;<em><sub>F</sub></em> handles the job of duplicating or deleting tables as well as duplicating or deleting columns in a single table. The functor &#x03A3;<em><sub>F</sub></em> handles taking unions, and the functor &#x03A0;<em><sub>F</sub></em> handles joining tables together, matching columns, or selecting the rows with certain properties (e.g., everyone whose first name is Mary).</p>
<p>This section is challenging, and it can be safely skipped, resuming at Section <a href="chapter007.html#lev_7-2">7.2</a>. For those who want to pursue it, there is an open source implementation of these ideas and more, called FQL,<sup><a id="endnote_ref_5" href="chapter007.html#endnote_5">5</a></sup> which stands for <em>functorial query language</em> (not to be confused with Facebook query language).</p>
</section>
<section title="Pullback:">
<h3 class="level3" id="lev_7-1-4-2"><strong>7.1.4.2&#160;&#160;&#160;Pullback:</strong> &#x0394;</h3>
<p class="noindent">Given a functor <epub:switch id="mathmlSwitch1592"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and a functor <epub:switch id="mathmlSwitch1593"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we can compose them to get a functor <epub:switch id="mathmlSwitch1594"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>&#x25CB;</mo><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>. In other words, the presence of <em>F</em> provides a way to convert <epub:switch id="mathmlSwitch1595"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>D</mi><mtext>-instances</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> into <epub:switch id="mathmlSwitch1596"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mtext>-instances</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>. In fact, this conversion is functorial, meaning that a morphism of <epub:switch id="mathmlSwitch1597"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>D</mi><mtext>-instances</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>&#x03B1;</em>: <em>I</em> &#x2192; <em>I</em>&#x2032; is sent to a morphism of <epub:switch id="mathmlSwitch1598"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mtext>-instances</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>. This can be seen by whiskering (see Definition <a href="chapter005.html#Def_5-3-2-16">5.3.2.16</a>):</p>
<p class="fig-img"><img src="images/Art_P284.jpg" alt="art"/></p>
<p class="noindent">We denote the resulting functor <epub:switch id="mathmlSwitch1599"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x0394;</mo><mi>F</mi></msub><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> and call it <em>pullback along F</em> .</p>
<p>An example of this was given in Example <a href="chapter005.html#Exa_5-3-2-15">5.3.2.15</a>, which showed how a monoid homomorphism <epub:switch id="mathmlSwitch1600"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>F</mi><mo>:</mo><msup><mi mathvariant='script'>M</mi><mo>&#x2032;</mo></msup><mo>&#x2192;</mo><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch> could add functionality to a finite state machine. More generally, we can use pullbacks to reorganize data, copying and deleting tables and columns.</p>
<p class="noindent1-top-rem" id="Rem_7-1-4-3"><em>Remark</em> 7.1.4.3. Given a functor <epub:switch id="mathmlSwitch1601"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, which we think of as a schema translation, the functor <epub:switch id="mathmlSwitch1602"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x0394;</mo><mi>F</mi></msub><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> goes the opposite way. The reasoning is simple to explain (we are composing functors) but something about it often seems strange at first. The rough idea of this contravariance is captured by the role-reversal in the following slogan:</p>
<a id="p310"></a>
<p class="noindent1-top-slo"><em>Slogan</em> 7.1.4.4.</p>
<div class="pull-quote">
<p class="pq-noindent"><em>If I get my information from you, then your information becomes my information</em>.</p></div>
<p>Consider the following functor <epub:switch id="mathmlSwitch1603"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>:<sup><a id="endnote_ref_6" href="chapter007.html#endnote_6">6</a></sup></p>
<p class="fig-img" id="eq_7-4"><img src="images/Art_P285.jpg" alt="art"/></p>
<p>Recall how to read schemas. In schema <epub:switch id="mathmlSwitch1604"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> there are leaf tables <span class="font1">SSN</span>, <span class="font1">First</span>, <span class="font1">Last</span>, <span class="font1">Salary</span>, which represent different kinds of basic data. More interestingly, there are two <em>fact tables</em>. The first is called <span class="font1">T1</span>, and it relates <span class="font1">SSN</span>, <span class="font1">First</span>, and <span class="font1">Last</span>. The second is called <span class="font1">T2</span>, and it relates <span class="font1">First</span>, <span class="font1">Last</span>, and <span class="font1">Salary</span>.</p>
<p>The functor <epub:switch id="mathmlSwitch1605"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> relates <epub:switch id="mathmlSwitch1606"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> to a schema <epub:switch id="mathmlSwitch1607"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> which has a single fact table relating all four attributes: <span class="font1">SSN</span>, <span class="font1">First</span>, <span class="font1">Last</span>, and <span class="font1">Salary</span>. We are interested in <epub:switch id="mathmlSwitch1608"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x0394;</mo><mi>F</mi></msub><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Suppose given the following database instance <epub:switch id="mathmlSwitch1609"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> on <epub:switch id="mathmlSwitch1610"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch>:</p>
<p class="fig-img"><img src="images/Art_P286.jpg" alt="art"/></p>

<p class="fig-img"><img src="images/Art_P286a.jpg" alt="art"/></p>
<a id="p311"></a>
<p>How does one get the instance <epub:switch id="mathmlSwitch1611"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x0394;</mo><mi>F</mi></msub><mo stretchy='false'>(</mo><mi>I</mi><mo stretchy='false'>)</mo><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>? The formula was given: compose <em>I</em> with <em>F</em> . In terms of tables, it is like duplicating table <span class="font1">T</span> as <span class="font1">T1</span> and <span class="font1">T2</span> but deleting a column from each in accordance with the definition of <epub:switch id="mathmlSwitch1612"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> in (<a href="chapter007.html#eq_7-4">7.4</a>). Here is the result, &#x0394;<em><sub>F</sub></em> (<em>I</em>), in table form:</p>
<p class="fig-img"><img src="images/Art_P287.jpg" alt="art"/></p>
<p class="noindent1-top-exe" id="Exe_7-1-4-5"><em>Exercise</em> 7.1.4.5.</p>
<p>Consider the schemas</p>
<p class="fig-img"><img src="images/Art_P288.jpg" alt="art"/></p>
<p class="noindent">and the functor <em>F</em> : [1] &#x2192; [2] given by sending 0 &#x21A6; 0 and 1 &#x21A6; 2.</p>
<p class="nl1-list">a. How many possibilities are there for <em>F</em>(<em>f</em>)?</p>

<p class="nl1-list"><a id="p312"></a>b. Suppose <em>I</em> : [2] &#x2192; <strong>Set</strong> is given by the following tables:</p>
<p class="fig-img"><img src="images/Art_P289.jpg" alt="art"/></p>
<p class="nl1-list-para">Write the two tables associated to the [1]-instance &#x0394;<em><sub>F</sub></em>(<em>I</em>): [1] &#x2192; <strong>Set</strong>.</p>
</section>
<section title="Left pushforward">
<h3 class="level3" id="lev_7-1-4-6"><strong>7.1.4.6&#160;&#160;&#160;Left pushforward:</strong> &#x03A3;</h3>
<p class="noindent">Let <epub:switch id="mathmlSwitch1613"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> be a functor. The functor <epub:switch id="mathmlSwitch1614"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x0394;</mo><mi>F</mi></msub><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> has a left adjoint, <epub:switch id="mathmlSwitch1615"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A3;</mo><mi>F</mi></msub><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo>&#x2192;</mo><mi mathvariant='script'>D</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>. The rough idea is that &#x03A3;<em><sub>F</sub></em> performs parameterized colimits. Given an instance <epub:switch id="mathmlSwitch1616"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we get an instance on <epub:switch id="mathmlSwitch1617"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> that acts as follows. For each object <epub:switch id="mathmlSwitch1618"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>d</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, the set &#x03A3;<em><sub>F</sub></em>(<em>I</em>)(<em>d</em>) is the colimit (think of union) of some diagram in <epub:switch id="mathmlSwitch1619"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p>Left pushforwards (also known as left Kan extensions) are discussed at length in Spivak [38]; here we examine some examples from that paper.</p>

<p class="noindent1-top-exe" id="Exa_7-1-4-7"><em>Example</em> 7.1.4.7. We again use the functor <epub:switch id="mathmlSwitch1620"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> from (<a href="chapter007.html#eq_7-4">7.4</a>):</p>
<p class="fig-img"><img src="images/Art_P290.jpg" alt="art"/></p>
<a id="p313"></a>
<p class="noindent1-top">We apply the left pushforward <epub:switch id="mathmlSwitch1621"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A3;</mo><mi>F</mi></msub><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo>&#x2192;</mo><mi mathvariant='script'>D</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> to the following instance <epub:switch id="mathmlSwitch1622"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>:</p>
<p class="fig-img"><img src="images/Art_P291.jpg" alt="art"/></p>
<p class="space-break">The functor <epub:switch id="mathmlSwitch1623"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> sends both tables <span class="font1">T1</span> and <span class="font1">T2</span> to table <span class="font1">T</span>. Applying &#x03A3;<em><sub>F</sub></em> takes what was in <span class="font1">T1</span> and <span class="font1">T2</span> and puts the union in <span class="font1">T</span>. The result, <epub:switch id="mathmlSwitch1624"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A3;</mo><mi>F</mi></msub><mi>I</mi><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, is as follows:</p>
<p class="fig-img"><img src="images/Art_P292.jpg" alt="art"/></p>
<a id="p314"></a>
<p class="fig-img"><img src="images/Art_P292a.jpg" alt="art"/></p>
<p>As one can see, no set salary information for any data comes from table <span class="font1">T1</span>, nor does any set SSN information come form table <span class="font1">T2</span>. But the definition of adjoint, given in Definition <a href="chapter007.html#Def_7-1-1-1">7.1.1.1</a>, yields the universal response: freely add new variables that take the place of missing information. It turns out that this idea already has a name in logic, <em>Skolem variables</em>, and a name in database theory, <em>labeled nulls</em>.</p>
<p class="noindent1-top-exe" id="Exe_7-1-4-8"><em>Exercise</em> 7.1.4.8.</p>
<p>Consider the functor <em>F</em> : <span class="underline">3</span> &#x2192; <span class="underline">2</span> given by the sequence (1, 2, 2).</p>
<p class="nl1-list">a. Write an instance <em>I</em> : <span class="underline">3</span> &#x2192; <strong>Set</strong>.</p>
<p class="nl1-list">b. Given the description &#x201C;&#x03A3;<em><sub>F</sub></em> performs a parameterized colimit,&#x201D; make an educated guess about what &#x03A3;<em><sub>F</sub></em>(<em>I</em>): <span class="underline">2</span> &#x2192; <strong>Set</strong> is. Give your answer in the form of two sets that are made up from the three sets you already wrote.</p>

<p class="space-break">Here is the actual formula for computing left pushforwards. Suppose that <epub:switch id="mathmlSwitch1625"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a functor, and let <epub:switch id="mathmlSwitch1626"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> be a set-valued functor on <epub:switch id="mathmlSwitch1627"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>. Then <epub:switch id="mathmlSwitch1628"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A3;</mo><mi>F</mi></msub><mo stretchy='false'>(</mo><mi>I</mi><mo stretchy='false'>)</mo><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> is defined as follows. Given an object <epub:switch id="mathmlSwitch1629"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>d</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we first form the comma category (see Definition <a href="chapter006.html#Def_6-2-4-1">6.2.4.1</a>) for the cospan</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1630"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mover><mo>&#x2192;</mo><mi>F</mi></mover><mi mathvariant='script'>D</mi><mover><mo>&#x2190;</mo><mi>d</mi></mover><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">and denote it (<em>F</em> &#x2193; <em>d</em>). There is a canonical projection functor <epub:switch id="mathmlSwitch1631"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x03C0;</mi><mo>:</mo><mo stretchy='false'>(</mo><mi>F</mi><mo>&#x2193;</mo><mi>d</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, which we can compose with <epub:switch id="mathmlSwitch1632"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> to obtain a functor (<em>F</em> &#x2193; <em>d</em>) &#x2192; <strong>Set</strong>. We are ready to define &#x03A3;<em><sub>F</sub></em>(<em>I</em>)(<em>d</em>) to be its colimit,</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1633"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A3;</mo><mi>F</mi></msub><mo stretchy='false'>(</mo><mi>I</mi><mo stretchy='false'>)</mo><mo stretchy='false'>(</mo><mi>d</mi><mo stretchy='false'>)</mo><mo>&#x2254;</mo><munder><mrow><mtext>colim</mtext></mrow><mrow><mo stretchy='false'>(</mo><mi>F</mi><mo>&#x2193;</mo><mi>d</mi><mo stretchy='false'>)</mo></mrow></munder><mo>&#x00A0;</mo><mi>I</mi><mo>&#x25CB;</mo><mi>&#x03C0;</mi><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<a id="p315"></a>
<p class="noindent"><epub:switch id="mathmlSwitch1634"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A3;</mo><mi>F</mi></msub><mo stretchy='false'>(</mo><mi>I</mi><mo stretchy='false'>)</mo><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> has been defined on objects <epub:switch id="mathmlSwitch1635"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>d</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Morphisms are treated here only briefly; see Spivak [38] for details. Given a morphism <em>g</em> : <em>d</em> &#x2192; <em>d</em>&#x2032;, there is an induced functor (<em>F</em> &#x2193; <em>g</em>): (<em>F</em> &#x2193; <em>d</em>) &#x2192; (<em>F</em> &#x2193; <em>d</em>&#x2032;) and a commutative diagram of categories:</p>
<p class="fig-img"><img src="images/Art_P293.jpg" alt="art"/></p>
<p class="noindent1-top">By the universal property for colimits, this induces the required function</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1636"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><munder><mrow><mtext>colim</mtext></mrow><mrow><mo stretchy='false'>(</mo><mi>F</mi><mo>&#x2193;</mo><mi>d</mi><mo stretchy='false'>)</mo></mrow></munder><mo>&#x00A0;</mo><mi>I</mi><mo>&#x25CB;</mo><mi>&#x03C0;</mi><mover><mo>&#x2192;</mo><mrow><msub><mo>&#x03A3;</mo><mi>F</mi></msub><mo stretchy='false'>(</mo><mi>I</mi><mo stretchy='false'>)</mo><mo stretchy='false'>(</mo><mi>g</mi><mo stretchy='false'>)</mo></mrow></mover><munder><mrow><mtext>colim</mtext></mrow><mrow><mo stretchy='false'>(</mo><mi>F</mi><mo>&#x2193;</mo><mi>d</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo></mrow></munder><mo>&#x00A0;</mo><mi>I</mi><mo>&#x25CB;</mo><mi>&#x03C0;</mi><mo>&#x2032;</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
</section>
<section title="Right pushforward">
<h3 class="level3" id="lev_7-1-4-9"><strong>7.1.4.9&#160;&#160;&#160;Right pushforward:</strong> &#x03A0;</h3>
<p class="noindent">Let <epub:switch id="mathmlSwitch1637"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> be a functor. Section <a href="chapter007.html#lev_7-1-4-6">7.1.4.6</a> explained that the functor <epub:switch id="mathmlSwitch1638"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x0394;</mo><mi>F</mi></msub><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> has a left adjoint. The present section explains that &#x0394;<em><sub>F</sub></em> has a right adjoint, <epub:switch id="mathmlSwitch1639"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A0;</mo><mi>F</mi></msub><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo>&#x2192;</mo><mi mathvariant='script'>D</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> as well. The rough idea is that &#x03A0;<em><sub>F</sub></em> performs parameterized limits. Given an instance <epub:switch id="mathmlSwitch1640"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we get an instance on <epub:switch id="mathmlSwitch1641"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> that acts as follows. For each object <epub:switch id="mathmlSwitch1642"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>d</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, the set &#x03A0;<em><sub>F</sub></em>(<em>I</em>)(<em>d</em>) is the limit (think of fiber product) of some diagram in <epub:switch id="mathmlSwitch1643"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p>Right pushforwards (also known as right Kan extensions) are discussed at length in Spivak [38]; here we look at some examples from that paper.</p>

<p class="noindent1-top-exe" id="Exa_7-1-4-10"><em>Example</em> 7.1.4.10. We again use the functor <epub:switch id="mathmlSwitch1644"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> from (<a href="chapter007.html#eq_7-4">7.4</a>) and Example <a href="chapter007.html#Exa_7-1-4-7">7.1.4.7</a>. <a id="p316"></a>We apply the right pushforward &#x03A0;<em><sub>F</sub></em> to instance <epub:switch id="mathmlSwitch1645"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> from that example.<sup><a id="endnote_ref_7" href="chapter007.html#endnote_7">7</a></sup></p>
<p>The instance &#x03A0;<em><sub>F</sub></em>(<em>I</em>) puts data in all five tables in <epub:switch id="mathmlSwitch1646"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch>. In <span class="font1">T</span> it puts pairs (<em>t</em><sub>1</sub>, <em>t</em><sub>2</sub>), where <em>t</em><sub>1</sub> is a row in <span class="font1">T1</span>, and <em>t</em><sub>2</sub> is a row in <span class="font1">T2</span>, for which the first and last names agree. It copies the leaf tables exactly, so they are not displayed here; the following is the table <span class="font1">T</span> for &#x03A0;<em><sub>F</sub></em>(<em>I</em>):</p>
<table>
<tbody>
<tr>
<td class="td1all" colspan="6"><p class="center"><span class="font1">T</span></p></td>
</tr>
<tr>
<td class="td1all"><strong>ID</strong></td>
<td class="td1all"></td>
<td class="td1all"><strong>SSN</strong></td>
<td class="td1all"><strong>First</strong></td>
<td class="td1all"><strong>Last</strong></td>
<td class="td1all"><strong>Salary</strong></td>
</tr>
<tr>
<td class="td1all">T1-002T2-A104</td>
<td class="td1all"></td>
<td class="td1all"><p class="center">122-988</p></td>
<td class="td1all"><p class="center">Sue</p></td>
<td class="td1all"><p class="center">Smith</p></td>
<td class="td1all"><p class="center">&#x0024;300</p></td>
</tr>
<tr>
<td class="td1all">T1-003T2-A101</td>
<td class="td1all"></td>
<td class="td1all"><p class="center">198-877</p></td>
<td class="td1all"><p class="center">Alice</p></td>
<td class="td1all"><p class="center">Jones</p></td>
<td class="td1all"><p class="center">&#x0024;100</p></td>
</tr>
</tbody>
</table>
<p class="noindent">From <span class="font1">T1</span> and <span class="font1">T2</span> there are only two ways to match first and last names.</p>
<a id="p317"></a>
<p class="noindent1-top-exe" id="Exe_7-1-4-11"><em>Exercise</em> 7.1.4.11.</p>
<p>Consider the functor <em>F</em> : <span class="underline">3</span> &#x2192; <span class="underline">2</span> given by the sequence (1, 2, 2).</p>
<p class="nl1-list">a. Write an instance <em>I</em> : <span class="underline">3</span> &#x2192; <strong>Set</strong>.</p>
<p class="nl1-list">b. Given the description &#x201C;&#x03A0;<em><sub>F</sub></em> performs a parameterized limit,&#x201D; make an educated guess about what &#x03A0;<em><sub>F</sub></em>(<em>I</em>): <span class="underline">2</span> &#x2192; <strong>Set</strong> is. Give your answer in the form of two sets that are made up from the three sets you already wrote down.</p>

<p class="space-break">Here is the actual formula for computing right pushforwards. Suppose that <epub:switch id="mathmlSwitch1647"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a functor, and let <epub:switch id="mathmlSwitch1648"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> be a set-valued functor on <epub:switch id="mathmlSwitch1649"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>. Then <epub:switch id="mathmlSwitch1650"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A0;</mo><mi>F</mi></msub><mo stretchy='false'>(</mo><mi>I</mi><mo stretchy='false'>)</mo><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> is defined as follows. Given an object <epub:switch id="mathmlSwitch1651"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>d</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we first form the comma category (see Definition <a href="chapter006.html#Def_6-2-4-1">6.2.4.1</a>) for the cospan</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1652"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder><mover><mo>&#x2192;</mo><mi>d</mi></mover><mi mathvariant='script'>D</mi><mover><mo>&#x2190;</mo><mi>F</mi></mover><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">and denote it (<em>d</em> &#x2193; <em>F</em>). There is a canonical projection functor <epub:switch id="mathmlSwitch1653"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x03C0;</mi><mo>:</mo><mo stretchy='false'>(</mo><mi>d</mi><mo>&#x2193;</mo><mi>F</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, which we can compose with <epub:switch id="mathmlSwitch1654"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> to obtain a functor (<em>d</em> &#x2193; <em>F</em>) &#x2192; <strong>Set</strong>. We are ready to define &#x03A0;<em><sub>F</sub></em>(<em>I</em>)(<em>d</em>) to be its limit,</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1655"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A0;</mo><mi>F</mi></msub><mo stretchy='false'>(</mo><mi>I</mi><mo stretchy='false'>)</mo><mo stretchy='false'>(</mo><mi>d</mi><mo stretchy='false'>)</mo><mo>&#x2254;</mo><munder><mrow><mi>lim</mi><mo>&#x2061;</mo></mrow><mrow><mo stretchy='false'>(</mo><mi>d</mi><mo>&#x2193;</mo><mi>F</mi><mo stretchy='false'>)</mo></mrow></munder><mi>I</mi><mo>&#x25CB;</mo><mi>&#x03C0;</mi><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent"><epub:switch id="mathmlSwitch1656"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A0;</mo><mi>F</mi></msub><mo stretchy='false'>(</mo><mi>I</mi><mo stretchy='false'>)</mo><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> has been defined on objects <epub:switch id="mathmlSwitch1657"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>d</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and morphisms are treated only briefly; see Spivak [38] for details. Given a morphism <em>g</em> : <em>d</em> &#x2192; <em>d</em>&#x2032;, there is an induced functor (<em>g</em> &#x2193; <em>F</em>) : (<em>d</em>&#x2032; &#x2193; <em>F</em>) &#x2192; (<em>d</em> &#x2193; <em>F</em>) and a commutative diagram of categories:</p>
<p class="fig-img"><img src="images/Art_P294.jpg" alt="art"/></p>
<p class="noindent1-top">By the universal property for limits, this induces the required function</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1658"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><munder><mrow><mi>lim</mi><mo>&#x2061;</mo></mrow><mrow><mo stretchy='false'>(</mo><mi>d</mi><mo>&#x2193;</mo><mi>F</mi><mo stretchy='false'>)</mo></mrow></munder><mi>I</mi><mo>&#x25CB;</mo><mi>&#x03C0;</mi><mover><mo>&#x2192;</mo><mrow><msub><mo>&#x03A0;</mo><mi>F</mi></msub><mo stretchy='false'>(</mo><mi>I</mi><mo stretchy='false'>)</mo><mo stretchy='false'>(</mo><mi>g</mi><mo stretchy='false'>)</mo></mrow></mover><munder><mrow><mi>lim</mi><mo>&#x2061;</mo></mrow><mrow><mo stretchy='false'>(</mo><mi>d</mi><mo>&#x2032;</mo><mo>&#x2193;</mo><mi>F</mi><mo stretchy='false'>)</mo></mrow></munder><mi>I</mi><mo>&#x25CB;</mo><mi>&#x03C0;</mi><mo>&#x2032;</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<a id="p318"></a>
<p class="noindent1-top-pro" id="Pro_7-1-4-12"><strong>Proposition 7.1.4.12</strong>. <em>Left adjoints are closed under composition, as are right adjoints. That is, given adjunctions,</em></p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1659"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><munderover><mo>&#x21C4;</mo><mi>R</mi><mi>L</mi></munderover><mi mathvariant='script'>D</mi><munderover><mo>&#x21C4;</mo><mrow><mi>R</mi><mo>&#x2032;</mo></mrow><mrow><mi>L</mi><mo>&#x2032;</mo></mrow></munderover><mi>&#x2130;</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent"><em>their composite is also an adjunction:</em></p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1660"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><munderover><mo>&#x21C4;</mo><mrow><mi>R</mi><mo>&#x25CB;</mo><mi>R</mi><mo>&#x2032;</mo></mrow><mrow><mi>L</mi><mo>&#x2032;</mo><mo>&#x25CB;</mo><mi>L</mi></mrow></munderover><mi>&#x2130;</mi><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>

<p class="noindent1-top"><em>Proof</em>. This is a straightforward calculation. For any objects <epub:switch id="mathmlSwitch1661"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <em>e</em> &#x2208; Ob(<epub:switch id="mathmlSwitch1662"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>E</mi></epub:case><epub:default></epub:default></epub:switch>) we have adjunction isomorphisms:</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1663"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi>&#x2130;</mi></msub><mo stretchy='false'>(</mo><mi>L</mi><mo>&#x2032;</mo><mo stretchy='false'>(</mo><mi>L</mi><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>,</mo><mi>e</mi><mo stretchy='false'>)</mo><mo>&#x2245;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>D</mi></msub><mo stretchy='false'>(</mo><mi>L</mi><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>,</mo><mi>R</mi><mo>&#x2032;</mo><mo stretchy='false'>(</mo><mi>e</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>&#x2245;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>R</mi><mo stretchy='false'>(</mo><mi>R</mi><mo>&#x2032;</mo><mo stretchy='false'>(</mo><mi>e</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">whose composite is the required adjunction isomorphism. It is natural in our choice of objects <em>c</em> and <em>e</em>.</p>
<p class="noindent1-top-exe" id="Exa_7-1-4-13"><em>Example</em> 7.1.4.13 (Currying via &#x0394;, &#x03A3;, &#x03A0;). This example shows how currying (as in Sections <a href="chapter003.html#lev_3-4-2">3.4.2</a> and <a href="chapter007.html#Exa_7-1-1-8">7.1.1.8</a>) arises out of a certain combination of data migration functors.</p>
<p>Let <em>A</em>, <em>B</em>, and <em>C</em> be sets. Consider the unique functor <em>a</em>: <em>A</em> &#x2192; <span class="underline">1</span> and consider <em>B</em> and <em>C</em> as functors <epub:switch id="mathmlSwitch1664"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder><mover><mo>&#x2192;</mo><mi>B</mi></mover><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch1665"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder><mover><mo>&#x2192;</mo><mi>C</mi></mover><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> respectively.</p>
<p class="fig-img"><img src="images/Art_P295.jpg" alt="art"/></p>
<p class="noindent1-top">Note that <span class="underline">1</span>&#x2013;<strong>Set</strong> &#x2245; <strong>Set</strong>, and we elide the difference.</p>
<p>We know that &#x03A3;<em><sub>a</sub></em> is left adjoint to &#x0394;<em><sub>a</sub></em> and that &#x0394;<em><sub>a</sub></em> is left adjoint to &#x03A0;<em><sub>a</sub></em>, so by Proposition <a href="chapter007.html#Pro_7-1-4-12">7.1.4.12</a>, the composite &#x03A3;<em><sub>a</sub></em> &#x25CB; &#x0394;<em><sub>a</sub></em> is left adjoint to &#x03A0;<em><sub>a</sub></em>&#x0394;<em><sub>a</sub></em>. The goal is to see currying arise out of the adjunction isomorphism</p>
<p class="disp-equ-no" id="eq_7-5"><epub:switch id="mathmlSwitch1666"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd columnalign="left"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant='bold'>Set</mtext></mrow></msub><mo stretchy='false'>(</mo><msub><mo>&#x03A3;</mo><mi>a</mi></msub><msub><mo>&#x0394;</mo><mi>a</mi></msub><mo stretchy='false'>(</mo><mi>B</mi><mo stretchy='false'>)</mo><mo>,</mo><mi>C</mi><mo stretchy='false'>)</mo><mo>&#x2245;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant='bold'>Set</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>B</mi><mo>,</mo><msub><mo>&#x03A0;</mo><mi>a</mi></msub><msub><mo>&#x0394;</mo><mi>a</mi></msub><mo stretchy='false'>(</mo><mi>C</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>.</mo></mrow></mtd><mtd columnalign="right"><mrow><mo stretchy='false'>(</mo><mn>7.5</mn><mo stretchy='false'>)</mo></mrow></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p>By definition, &#x0394;<em><sub>a</sub></em>(<em>B</em>): <em>A</em> &#x2192; <strong>Set</strong> assigns to each element <em>a</em> &#x2208; <em>A</em> the set <em>B</em>. Since &#x03A3;<em><sub>A</sub></em> takes disjoint unions, we have a bijection</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1667"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A3;</mo><mi>a</mi></msub><mo stretchy='false'>(</mo><msub><mo>&#x0394;</mo><mi>a</mi></msub><mo stretchy='false'>(</mo><mi>B</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>=</mo><mrow><mo>(</mo><mrow><mstyle displaystyle='true'><munder><mo>&#x2210;</mo><mrow><mi>a</mi><mo>&#x2208;</mo><mi>A</mi></mrow></munder><mi>B</mi></mstyle></mrow><mo>)</mo></mrow><mo>&#x2245;</mo><mi>A</mi><mo>&#x00D7;</mo><mi>B</mi><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<a id="p319"></a>
<p class="noindent">Similarly, &#x0394;<em><sub>a</sub></em>(<em>C</em>): <em>A</em> &#x2192; <strong>Set</strong> assigns to each element <em>a</em> &#x2208; <em>A</em> the set <em>C</em>. Since &#x03A0;<em><sub>A</sub></em> takes products, we have a bijection</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1668"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A0;</mo><mi>a</mi></msub><mo stretchy='false'>(</mo><msub><mo>&#x0394;</mo><mi>a</mi></msub><mo stretchy='false'>(</mo><mi>C</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>=</mo><mrow><mo>(</mo><mrow><mstyle displaystyle='true'><munder><mo>&#x2210;</mo><mrow><mi>a</mi><mo>&#x2208;</mo><mi>A</mi></mrow></munder><mi>C</mi></mstyle></mrow><mo>)</mo></mrow><mo>&#x2245;</mo><msup><mi>C</mi><mi>A</mi></msup><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">The currying isomorphism Hom<strong><sub>Set</sub></strong>(<em>A</em> &#x00D7; <em>B</em>, <em>C</em>) &#x2245; Hom<strong><sub>Set</sub></strong>(<em>B</em>, <em>C<sup>A</sup></em>) falls out of (<a href="chapter007.html#eq_7-5">7.5</a>).</p>
</section>
</section>
</section>
<section title="">
<h1 class="level1" id="lev_7-2"><a href="toc.html#Rlev_7-2"><strong>7.2&#160;&#160;&#160;Categories of functors</strong></a></h1>
<p class="noindent">For any two categories <epub:switch id="mathmlSwitch1669"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch1670"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch>,<sup><a id="endnote_ref_8" href="chapter007.html#endnote_8">8</a></sup> Section <a href="chapter005.html#lev_5-3-2">5.3.2</a>.1 discussed the category <epub:switch id="mathmlSwitch1671"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>,</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> of functors and natural transformations between them. This section discusses functor categories a bit more and gives some important applications in mathematics (sheaves) that extend to the real world.</p>
<section title="Set-valued functors">
<h2 class="level2" id="lev_7-2-1"><strong>7.2.1&#160;&#160;&#160;Set-valued functors</strong></h2>
<p class="noindent">Let <epub:switch id="mathmlSwitch1672"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> be a category. We have been denoted by <epub:switch id="mathmlSwitch1673"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> the functor category <epub:switch id="mathmlSwitch1674"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>,</mo><mtext mathvariant='bold'>Set</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Here is a nice result about these categories.</p>
<p class="noindent1-top-pro" id="Pro_7-2-1-1"><strong>Proposition 7.2.1.1</strong>. <em>Let</em> <epub:switch id="mathmlSwitch1675"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> <em>be a category. The category</em> <epub:switch id="mathmlSwitch1676"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>is closed under colimits and limits. That is, for any category I and functor</em> <epub:switch id="mathmlSwitch1677"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>D</mi><mo>:</mo><mi>I</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <em>both the limit and the colimit of D exist in</em> <epub:switch id="mathmlSwitch1678"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="noindent1-top"><em>Sketch of proof</em>. We rely on the fact that the category <strong>Set</strong> is complete and cocomplete (see Remark <a href="chapter006.html#Rem_6-1-3-37">6.1.3.37</a>), i.e., that it has all limits and colimits (see Theorems <a href="chapter006.html#The_6-1-3-28">6.1.3.28</a> and <a href="chapter006.html#The_6-1-3-35">6.1.3.35</a> for constructions). Let <em>J</em> be an indexing category and <epub:switch id="mathmlSwitch1679"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>D</mi><mo>:</mo><mi>J</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> a functor. For each object <epub:switch id="mathmlSwitch1680"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we have a functor <epub:switch id="mathmlSwitch1681"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>D</mi><mi>c</mi></msub><mo>:</mo><mi>J</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> defined by <em>D<sub>c</sub></em>(<em>j</em>) = <em>D</em>(<em>j</em>)(<em>c</em>). Define a functor <epub:switch id="mathmlSwitch1682"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>L</mi><mo>:</mo><mi mathvariant="script">C</mi><mo>&#x2192;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch> by <em>L</em>(<em>c</em>) = lim<em><sub>J</sub> D<sub>c</sub></em>, and note that for each <em>f</em> : <em>c</em> &#x2192; <em>c</em>&#x2032; in <epub:switch id="mathmlSwitch1683"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> there is an induced function <em>L</em>(<em>f</em>): <em>L</em>(<em>c</em>) &#x2192; <em>L</em>(<em>c</em>&#x2032;). One can check that <em>L</em> is a limit of <em>J</em>, because it satisfies the relevant universal property.</p>
<p>The dual proof holds for colimits.</p>
<p class="noindent1-top-app" id="App_7-2-1-2"><em>Application</em> 7.2.1.2. When taking in data about a scientific subject, one often finds that how one thinks about the problem changes over time. We understand this phenomenon in the language of databases in terms of a <span class="underline">series of schemas</span> <epub:switch id="mathmlSwitch1684"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant='script'>C</mi><mn>1</mn></msub><mo>,</mo><msub><mi mathvariant='script'>C</mi><mn>2</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><msub><mi mathvariant='script'>C</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>, perhaps indexed chronologically. The problem is that previously-collected data is held in what <a id="p320"></a>may be outdated schemas, and we want to work with it in our current understanding. By finding appropriate functors between these schemas, or possibly with the help of auxiliary schemas, we can make a chain of categories and functors</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1685"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant='script'>C</mi><mn>1</mn></msub><mover><mo>&#x2190;</mo><mrow><msub><mi>F</mi><mn>1</mn></msub></mrow></mover><msub><mi mathvariant='script'>D</mi><mn>1</mn></msub><mover><mo>&#x2192;</mo><mrow><msub><mi>G</mi><mn>1</mn></msub></mrow></mover><msub><mi>&#x2130;</mi><mn>1</mn></msub><mover><mo>&#x2192;</mo><mrow><msub><mi>H</mi><mn>1</mn></msub></mrow></mover><msub><mi mathvariant='script'>C</mi><mn>2</mn></msub><mover><mo>&#x2190;</mo><mrow><msub><mi>F</mi><mn>2</mn></msub></mrow></mover><msub><mi mathvariant='script'>D</mi><mn>2</mn></msub><mover><mo>&#x2192;</mo><mrow><msub><mi>G</mi><mn>2</mn></msub></mrow></mover><msub><mi>&#x2130;</mi><mn>2</mn></msub><mover><mo>&#x2192;</mo><mrow><msub><mi>H</mi><mn>2</mn></msub></mrow></mover><mo>&#x2026;</mo><mover><mo>&#x2192;</mo><mrow><msub><mi>G</mi><mi>n</mi></msub></mrow></mover><msub><mi>&#x2130;</mi><mi>n</mi></msub><mover><mo>&#x2192;</mo><mrow><msub><mi>H</mi><mi>n</mi></msub></mrow></mover><msub><mi mathvariant='script'>C</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">We can then use the data migration functors &#x0394;<em><sub>F</sub></em>, &#x03A0;<em><sub>G</sub></em>, and &#x03A3;<em><sub>H</sub></em> to move data from category <epub:switch id="mathmlSwitch1686"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant='script'>C</mi><mn>1</mn></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> to category <epub:switch id="mathmlSwitch1687"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant='script'>C</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> using projections, joins, and unions in any combination. Theorems about sequences of &#x0394;&#x2019;s, &#x03A0;&#x2019;s, and &#x03A3;&#x2019;s can help us understand how such a transformation will behave, before we spend the resources to enact it.</p>
<p class="noindent1-top-exe" id="Exe_7-2-1-3"><em>Exercise</em> 7.2.1.3.</p>
<p>By Proposition <a href="chapter007.html#Pro_7-2-1-1">7.2.1.1</a>, the category <epub:switch id="mathmlSwitch1688"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi><mo>&#x2013;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch> is closed under taking colimits and limits. By Exercises <a href="chapter006.html#Exe_6-1-3-24">6.1.3.24</a> and <a href="chapter006.html#Exe_6-1-3-34">6.1.3.34</a>, this means in particular, that <epub:switch id="mathmlSwitch1689"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi><mo>&#x2013;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch> has an initial object and a terminal object.</p>
<p class="nl1-list">a. Let <epub:switch id="mathmlSwitch1690"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant="bold">Set</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be the initial object, considered as a functor <epub:switch id="mathmlSwitch1691"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>. For any <epub:switch id="mathmlSwitch1692"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, what is the set <em>A</em>(<em>c</em>)?</p>
<p class="nl1-list">b. Let <epub:switch id="mathmlSwitch1693"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Z</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant="bold">Set</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be the terminal object, considered as a functor <epub:switch id="mathmlSwitch1694"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Z</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>. For any <epub:switch id="mathmlSwitch1695"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, what is the set <em>Z</em>(<em>c</em>)?</p>
<p class="space-break">Proposition <a href="chapter007.html#Pro_7-2-1-1">7.2.1.1</a> says that we can add or multiply database instances together. In fact, database instances on <epub:switch id="mathmlSwitch1696"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> form a <em>topos</em>, which means that just about every consideration we made for sets holds for instances on any schema. Perhaps the simplest schema is <img src="images/Art_P296.jpg" alt="art"/>, on which the relevant topos <img src="images/Art_P297.jpg" alt="art"/> is indeed equivalent to <strong>Set</strong>. But schemas can be arbitrarily complex categories, and it is impressive that all these set-theoretic notions make sense in such generality. Here is a table that compares these domains:</p>
<a id="p321"></a>
<table>
<tbody>
<tr>
<td class="td1all" colspan="2"><p class="center">Dictionary between <strong>Set</strong> and <epub:switch id="mathmlSwitch1697"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch></p></td>
</tr>
<tr>
<td class="td1all"><strong>Concept in Set</strong></td>
<td class="td1all"><strong>Concept in</strong> <epub:switch id="mathmlSwitch1698"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi><mo>&#x2013;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch></td>
</tr>
<tr>
<td class="td1all">Set</td>
<td class="td1all">Object in <epub:switch id="mathmlSwitch1699"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi><mo>&#x2013;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch></td>
</tr>
<tr>
<td class="td1all">Function</td>
<td class="td1all">Morphism in <epub:switch id="mathmlSwitch1700"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi><mo>&#x2013;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch></td>
</tr>
<tr>
<td class="td1all">Element</td>
<td class="td1all">Representable functor</td>
</tr>
<tr>
<td class="td1all">Empty set</td>
<td class="td1all">Initial object</td>
</tr>
<tr>
<td class="td1all">Natural numbers</td>
<td class="td1all">Natural numbers object</td>
</tr>
<tr>
<td class="td1all">Image</td>
<td class="td1all">Image</td>
</tr>
<tr>
<td class="td1all">(Co)limits</td>
<td class="td1all">(Co)limits</td>
</tr>
<tr>
<td class="td1all">Exponential objects</td>
<td class="td1all">Exponential objects</td>
</tr>
<tr>
<td class="td1all">&#x201C;Familiar&#x201D; arithmetic</td>
<td class="td1all">&#x201C;Familiar&#x201D; arithmetic</td>
</tr>
<tr>
<td class="td1all">Power-sets 2<em><sup>X</sup></em></td>
<td class="td1all">Power objects &#x03A9;<em><sup>X</sup></em></td>
</tr>
<tr>
<td class="td1all">Characteristic functions</td>
<td class="td1all">Characteristic morphisms</td>
</tr>
<tr>
<td class="td1all">Surjections, injections</td>
<td class="td1all">Epimorphisms, monomorphisms</td>
</tr>
</tbody>
</table>
<p>Thus elements of a set are akin to representable functors in <epub:switch id="mathmlSwitch1701"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi><mo>&#x2013;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch>, which are defined in Section <a href="chapter007.html#lev_7-2-1-6">7.2.1.6</a>. We briefly discuss monomorphisms and epimorphisms first in general (Definition <a href="chapter007.html#Def_7-2-1-4">7.2.1.4</a>) and then in <epub:switch id="mathmlSwitch1702"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi><mo>&#x2013;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch> (Proposition <a href="chapter007.html#Pro_7-2-1-5">7.2.1.5</a>).</p>
<p class="noindent1-top-def" id="Def_7-2-1-4"><strong>Definition 7.2.1.4</strong> (Monomorphism, epimorphism). Let <epub:switch id="mathmlSwitch1703"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>S</mi></math></epub:case><epub:default></epub:default></epub:switch> be a category, and let <em>f</em> : <em>X</em> &#x2192; <em>Y</em> be a morphism. We say that <em>f</em> is a <em>monomorphism</em> if it has the following property. For all objects <epub:switch id="mathmlSwitch1704"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>S</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and morphisms <em>g</em>, <em>g</em>&#x2032; : <em>A</em> &#x2192; <em>X</em> in <epub:switch id="mathmlSwitch1705"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>S</mi></math></epub:case><epub:default></epub:default></epub:switch>,</p>
<p class="fig-img"><img src="images/Art_P298.jpg" alt="art"/></p>
<p class="noindent">if <em>f</em> &#x25CB; <em>g</em> = <em>f</em> &#x25CB; <em>g</em>&#x2032;, then <em>g</em> = <em>g</em>&#x2032;.</p>
<p>We say that <em>f</em> : <em>X</em> &#x2192; <em>Y</em> is an <em>epimorphism</em> if it has the following property. For all objects <epub:switch id="mathmlSwitch1706"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>S</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and morphisms <em>h</em>, <em>h</em>&#x2032; : <em>Y</em> &#x2192; <em>B</em> in <epub:switch id="mathmlSwitch1707"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>S</mi></math></epub:case><epub:default></epub:default></epub:switch>,</p>
<p class="fig-img"><img src="images/Art_P299.jpg" alt="art"/></p>
<p class="noindent">if <em>h</em> &#x25CB; <em>f</em> = <em>h</em>&#x2032; &#x25CB; <em>f</em>, then <em>h</em> = <em>h</em>&#x2032;.</p>
<p>In the category of sets, monomorphisms are the same as injections, and epimorphisms are the same as surjections (see Proposition <a href="chapter003.html#Pro_3-4-5-8">3.4.5.8</a>). The same is true in <epub:switch id="mathmlSwitch1708"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi><mo>&#x2013;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch>: one can check table by table that a morphism of instances is mono or epi.</p>
<a id="p322"></a>
<p class="noindent1-top-pro" id="Pro_7-2-1-5"><strong>Proposition 7.2.1.5</strong>. <em>Let</em> <epub:switch id="mathmlSwitch1709"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> <em>be a category, let</em> <epub:switch id="mathmlSwitch1710"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi><mo>,</mo><mi>Y</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch> <em>be objects in</em> <epub:switch id="mathmlSwitch1711"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <em>and let f</em> : <em>X</em> &#x2192; <em>Y be a morphism in</em> <epub:switch id="mathmlSwitch1712"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>. <em>Then f is a monomorphism (resp. an epimorphism) if and only if for every object</em> <epub:switch id="mathmlSwitch1713"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <em>the function f</em>(<em>c</em>): <em>X</em>(<em>c</em>) &#x2192; <em>Y</em>(<em>c</em>) <em>is injective (resp. surjective)</em>.</p>
<p class="noindent1-top"><em>Sketch of proof</em>. We first show that if <em>f</em> is mono (resp. epi), then so is <em>f</em>(<em>c</em>), for all <epub:switch id="mathmlSwitch1714"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Considering <em>c</em> as a functor <epub:switch id="mathmlSwitch1715"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>:</mo><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, this result follows from the fact that &#x0394;<em><sub>c</sub></em> preserves limits and colimits, hence monos and epis.</p>
<p>We now check that if <em>f</em>(<em>c</em>) is mono for all <epub:switch id="mathmlSwitch1716"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, then <em>f</em> is mono. Suppose that <em>g</em>, <em>g</em>&#x2032; : <em>A</em> &#x2192; <em>X</em> are morphisms in <epub:switch id="mathmlSwitch1717"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi><mo>&#x2013;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch> such that <em>f</em> &#x25CB; <em>g</em> = <em>f</em> &#x25CB; <em>g</em>&#x2032;. Then for every <em>c</em>, we have <em>f</em> &#x25CB; <em>g</em>(<em>c</em>) = <em>f</em> &#x25CB; <em>g</em>&#x2032;(<em>c</em>), which implies by hypothesis that <em>g</em>(<em>c</em>) = <em>g</em>&#x2032;(<em>c</em>). But the morphisms in <epub:switch id="mathmlSwitch1718"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi><mo>&#x2013;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch> are natural transformations, and if two natural transformations <em>g</em>, <em>g</em>&#x2032; have the same components, then they are the same.</p>
<p>A similar argument works to show the analogous result for epimorphisms.</p>
<section title="Representable functors">
<h3 class="level3" id="lev_7-2-1-6"><strong>7.2.1.6&#160;&#160;&#160;Representable functors</strong></h3>
<p class="noindent">Given a category <epub:switch id="mathmlSwitch1719"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, there are certain functors <epub:switch id="mathmlSwitch1720"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch> that come with the package, i.e., that are not arbitrary from a mathematical perspective as database instances usually are. In fact, there is a certain instance corresponding to each object in <epub:switch id="mathmlSwitch1721"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>. So if <epub:switch id="mathmlSwitch1722"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> is a database schema, then for every table <epub:switch id="mathmlSwitch1723"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> there is a certain database instance associated to it. These instances, i.e., set-valued functors, are called representable functors (see Definition <a href="chapter007.html#Def_7-2-1-7">7.2.1.7</a>). The idea is that if a database schema is a conceptual layout of types (e.g., as an olog), then each type <em>c</em> has an instance associated to it, standing for &#x201C;the generic thing of type <em>c</em> with all its generic attributes.&#x201D;</p>
<p class="noindent1-top-def" id="Def_7-2-1-7"><strong>Definition 7.2.1.7</strong>. Let <epub:switch id="mathmlSwitch1724"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> be a category, and let <epub:switch id="mathmlSwitch1725"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be an object. The functor <epub:switch id="mathmlSwitch1726"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mo>&#x2212;</mo><mo stretchy='false'>)</mo><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, sending <epub:switch id="mathmlSwitch1727"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>d</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy="false">(</mo><mi mathvariant='script'>C</mi><mo stretchy="false">)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> to the set <epub:switch id="mathmlSwitch1728"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and acting similarly on morphisms <em>d</em> &#x2192; <em>d</em>&#x2032;, is said to be <em>represented by c</em>. If a functor <epub:switch id="mathmlSwitch1729"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> is isomorphic to <epub:switch id="mathmlSwitch1730"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mo>&#x2212;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we say that <em>F</em> is <em>a representable functor</em>. To shorten notation we sometimes write</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1731"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>Y</mi><mi>c</mi></msub><mo>&#x2254;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mo>&#x2212;</mo><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top-exe" id="Exa_7-2-1-8"><em>Example</em> 7.2.1.8. Given a category <epub:switch id="mathmlSwitch1732"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> and an object <epub:switch id="mathmlSwitch1733"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we get a representable functor <em>Y<sub>c</sub></em>. If we think of <epub:switch id="mathmlSwitch1734"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> as a database schema and <em>c</em> as a table, then what does the representable functor <epub:switch id="mathmlSwitch1735"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>Y</mi><mi>c</mi></msub><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> look like in terms of databases? It turns out that the following procedure will generate it.</p>
<p>Begin by writing a new row, say, &#x201C;&#x263A;,&#x201D; in the ID column of table <em>c</em>. For each foreign key column <em>f</em> : <em>c</em> &#x2192; <em>c</em>&#x2032;, add a row in the ID column of table <em>c</em>&#x2032; called &#x201C;<em>f</em>(&#x263A;)&#x201D; and record that result, &#x201C;<em>f</em>(&#x263A;),&#x201D; in the <em>f</em> column of table <em>c</em>. Repeat as follows: for each table <em>d</em>, <a id="p323"></a>identify all rows <em>r</em> that have a blank cell in column <em>g</em> : <em>d</em> &#x2192; <em>e</em>. Add a new row called &#x201C;<em>g</em>(<em>r</em>)&#x201D; to table <em>e</em> and record that result, &#x201C;<em>g</em>(<em>r</em>),&#x201D; in the (<em>r</em>, <em>g</em>) cell of table <em>d</em>.</p>
<p>Here is a concrete example. Let <epub:switch id="mathmlSwitch1736"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> be the following schema:</p>
<p class="fig-img"><img src="images/Art_P300.jpg" alt="art"/></p>
<p class="noindent">Then <epub:switch id="mathmlSwitch1737"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>Y</mi><mi>B</mi></msub><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> is given by &#x201C;morphisms from <em>B</em> to &#x2212;,&#x201D; i.e., it is the following instance:</p>
<p class="fig-img"><img src="images/Art_P301.jpg" alt="art"/></p>
<p>To create <em>Y<sub>B</sub></em> we began with a single element in table <em>B</em> and followed the arrows, putting new entries wherever they were required. One might call this the <em>schematically implied reference spread</em> or SIRS of the element &#x263A; in table <em>B</em>. Notice that the table at <em>A</em> is empty, because there are no morphisms <em>B</em> &#x2192; <em>A</em> in <epub:switch id="mathmlSwitch1738"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="space-break">Representable functors <em>Y<sub>c</sub></em> yield database instances that are as free as possible, subject to having the initial row &#x263A; in table <em>c</em>. We saw this before (as Skolem variables) when studying the left pushforward &#x03A3;. Indeed, suppose <epub:switch id="mathmlSwitch1739"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is an object represented by the functor <epub:switch id="mathmlSwitch1740"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>c</mi><mo>:</mo><munder><mn>1</mn><mo>&#x00AF;</mo></munder><mo>&#x2192;</mo><mi mathvariant="script">C</mi></math></epub:case><epub:default></epub:default></epub:switch>. A database instance on <span class="underline">1</span> is the same thing as a set <em>X</em>. The left pushforward &#x03A3;<em><sub>c</sub></em>(<em>X</em>) has the same kinds of Skolem variables as <em>Y<sub>c</sub></em> does. In fact, if <em>X</em> = {&#x263A;} is a one-element set, then we get the representable functor</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1741"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>Y</mi><mi>c</mi></msub><mo>&#x2245;</mo><msub><mo>&#x03A3;</mo><mi>c</mi></msub><mo stretchy="false">&#x007B;</mo><mo>&#x263A;</mo><mo stretchy="false">&#x007D;</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>

<p class="noindent1-top-exe" id="Exe_7-2-1-9"><em>Exercise</em> 7.2.1.9.</p>
<a id="p324"></a>
<p>Consider the schema for graphs,</p>
<p class="fig-img"><img src="images/Art_P302.jpg" alt="art"/></p>
<p class="nl1-list">a. Write the representable functor <em>Y<sub>Ar</sub></em> : <strong>GrIn</strong> &#x2192; <strong>Set</strong> as two tables.</p>
<p class="nl1-list">b. Write the representable functor <em>Y<sub>Ve</sub></em> as two tables.</p>
<p class="noindent1-top-sol"><em>Solution</em> 7.2.1.9.</p>
<p class="nl1-list">a. This was done in Exercise <a href="chapter005.html#Exe_5-3-3-7">5.3.3.7</a>, although not with the most natural names. Here we rewrite <em>Y<sub>Ar</sub></em> = Hom<strong><sub>GrIn</sub></strong>(<em>Ar</em>, &#x2212;) as</p>
<p class="fig-img"><img src="images/Art_P303.jpg" alt="art"/></p>
<p class="nl1-list">b. Here is <em>Y<sub>Ve</sub></em> = Hom<strong><sub>GrIn</sub></strong>(<em>Ve</em>, &#x2212;) with &#x201C;natural names&#x201D;:</p>
<p class="fig-img"><img src="images/Art_P304.jpg" alt="art"/></p>
<p class="nl1-list-para">(The left-hand table is empty because there are no morphisms <em>Ve</em> &#x2192; <em>Ar</em> in <strong>GrIn</strong>.)</p>
<p class="noindent1-top-exe" id="Exe_7-2-1-10"><em>Exercise</em> 7.2.1.10.</p>
<p>Consider the loop schema</p>
<p class="fig-img"><img src="images/Art_P305.jpg" alt="art"/></p>
<p class="noindent">Express the representable functor <epub:switch id="mathmlSwitch1742"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>Y</mi><mi>s</mi></msub><mo>:</mo><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow><mo>&#x2192;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch> in table form.</p>
<a id="p325"></a>
<p class="noindent1-top-sol"><em>Solution</em> 7.2.1.10.</p>
<p>We have <epub:switch id="mathmlSwitch1743"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mi>Y</mi><mi>s</mi></msub><mo>=</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></msub><mrow><mo>(</mo><mrow><mi>s</mi><mo>,</mo><mo>&#x2212;</mo></mrow><mo>)</mo></mrow><mo>:</mo><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext><mo>&#x2192;</mo><mtext mathvariant="bold">Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>. On objects, of which there is only <epub:switch id="mathmlSwitch1744"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext>Ob</mtext><mrow><mo>(</mo><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext><mo>)</mo></mrow><mo>=</mo><mrow><mo>{</mo><mi>s</mi><mo>}</mo></mrow></mrow></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we have <em>Y<sub>s</sub></em>(<em>s</em>) = {<em>f<sup>n</sup></em> &#x007C; <em>n</em> &#x2208; &#x2115;}. The morphism <em>f</em> : <em>s</em> &#x2192; <em>s</em> acts on <em>Y<sub>s</sub></em>(<em>s</em>) by composing. Here is <em>Y<sub>s</sub></em> in table form:</p>
<table>
<tbody>
<tr>
<td class="td1all" colspan="3"><p class="center"><em><strong>s</strong></em></p></td>
</tr>
<tr>
<td class="td1all"><strong>ID</strong></td>
<td class="td1all"></td>
<td class="td1all"><strong>f</strong></td>
</tr>
<tr>
<td class="td1all">&#x263A;</td>
<td class="td1all"></td>
<td class="td1all"><em>f</em>(&#x263A;)</td>
</tr>
<tr>
<td class="td1all"><em>f</em>(&#x263A;)</td>
<td class="td1all"></td>
<td class="td1all"><em>f</em><sup>2</sup>(&#x263A;)</td>
</tr>
<tr>
<td class="td1all"><em>f</em><sup>2</sup>(&#x263A;)</td>
<td class="td1all"></td>
<td class="td1all"><em>f</em><sup>3</sup>(&#x263A;)</td>
</tr>
<tr>
<td class="td1all"><em>f</em><sup>3</sup>(&#x263A;)</td>
<td class="td1all"></td>
<td class="td1all"><em>f</em><sup>4</sup>(&#x263A;)</td>
</tr>
<tr>
<td class="td1all"><em>f</em><sup>4</sup>(&#x263A;)</td>
<td class="td1all"></td>
<td class="td1all"><em>f</em><sup>5</sup>(&#x263A;)</td>
</tr>
<tr>
<td class="td1all">&#x22EE;</td>
<td class="td1all"></td>
<td class="td1all">&#x22EE;</td>
</tr>
</tbody>
</table>
<p class="space-break">Let <em>B</em> be a box in an olog, say, &#x231C;a person&#x231D;, and recall that an aspect of <em>B</em> is an outgoing arrow, such as <epub:switch id="mathmlSwitch1745"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>&#x231C;</mo><mtext>a person</mtext><mo>&#x231D;</mo><mover><mo>&#x2192;</mo><mrow><mtext>has as height in inches</mtext></mrow></mover><mo>&#x231C;</mo><mtext>an integer</mtext><mo>&#x231D;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. The following slogan explains representable functors in those terms.</p>
<p class="noindent1-top-slo"><em>Slogan</em> 7.2.1.11.</p>
<div class="pull-quote">
<p class="pq-noindent"><em>The functor represented by</em> &#x231C;a person&#x231D; <em>simply leaves a placeholder, like</em> &#x2329;<em>person&#x2019;s name here</em>&#x232A; <em>or</em> &#x2329;<em>person&#x2019;s height here</em>&#x232A;, <em>for every aspect of</em> &#x231C;a person&#x231D;<em>. In general, there is a representable functor for every type in an olog. The representable functor for type T simply encapsulates the most generic or abstract example of type T, by leaving a placeholder for each of its attributes.</em></p></div>
<p class="noindent1-top-exe" id="Exe_7-2-1-12"><em>Exercise</em> 7.2.1.12.</p>
<p>Recall from Definition <a href="chapter007.html#Def_7-2-1-7">7.2.1.7</a> that a functor <epub:switch id="mathmlSwitch1746"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> is said to be represented by <em>c</em> if there is a natural isomorphism <epub:switch id="mathmlSwitch1747"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>&#x2245;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mo>&#x2212;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="nl1-list">a. There is a functor Ob: <strong>Cat</strong> &#x2192; <strong>Set</strong> (see Exercise <a href="chapter005.html#Exe_5-1-2-41">5.1.2.41</a>) sending a category <epub:switch id="mathmlSwitch1748"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> to its set <epub:switch id="mathmlSwitch1749"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo stretchy="false">(</mo><mi mathvariant='script'>C</mi><mo stretchy="false">)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> of objects, and sending a functor to its on-objects part. This functor is representable by some category. Name a category <em>A</em> that represents Ob.</p>
<p class="nl1-list">b. There is a functor Hom: <strong>Cat</strong> &#x2192; <strong>Set</strong> (see Exercise <a href="chapter005.html#Exe_5-1-2-42">5.1.2.42</a>) sending a category <epub:switch id="mathmlSwitch1750"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> to the set <epub:switch id="mathmlSwitch1751"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mtext>Hom</mtext><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> of all morphisms in <epub:switch id="mathmlSwitch1752"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> and sending a functor to its on-morphisms part. This functor is representable by a category. Name a category <em>B</em> that represents Hom.</p>
<a id="p326"></a>
<p class="noindent1-top-exe" id="Exe_7-2-1-13"><em>Exercise</em> 7.2.1.13.</p>
<p>Let <epub:switch id="mathmlSwitch1753"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> be a category, let <epub:switch id="mathmlSwitch1754"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>,</mo><mi>c</mi><mo>&#x2032;</mo><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be objects, and let <epub:switch id="mathmlSwitch1755"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>Y</mi><mi>c</mi></msub><mo>,</mo><msub><mi>Y</mi><mrow><mi>c</mi><mo>&#x2032;</mo></mrow></msub><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> be the associated representable functors. Given <em>f</em> : <em>c</em> &#x2192; <em>c</em>&#x2032;, we want to construct a morphism <em>Y<sub>f</sub></em> : <em>Y</em><sub><em>c</em>&#x2032;</sub> &#x2192; <em>Y<sub>c</sub></em> in <epub:switch id="mathmlSwitch1756"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Fun</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Of course, <em>Y<sub>f</sub></em> is supposed to be a natural transformation, so we need to provide a component (<em>Y<sub>f</sub></em>)<em><sub>d</sub></em> for every object <epub:switch id="mathmlSwitch1757"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>d</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="nl1-list">a. What must the domain and codomain of (<em>Y<sub>f</sub></em>)<em><sub>d</sub></em> be? (Simplify your answer using Definition <a href="chapter007.html#Def_7-2-1-7">7.2.1.7</a>.)</p>
<p class="nl1-list">b. Can you make sense of the statement, &#x201C;Define (<em>Y<sub>f</sub></em>)<em><sub>d</sub></em> by precomposition&#x201D;?</p>
<p class="nl1-list">c. If <em>h</em>: <em>d</em> &#x2192; <em>e</em> is a morphism in <epub:switch id="mathmlSwitch1758"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi></math></epub:case><epub:default></epub:default></epub:switch>, draw the naturality square for <em>Y<sub>f</sub></em>. Does it commute?</p>
<p class="noindent1-top-sol"><em>Solution</em> 7.2.1.13.</p>
<p class="nl1-list">a. We have (<em>Y<sub>f</sub></em>)<em><sub>d</sub></em> : <em>Y</em><sub><em>c</em>&#x2032;</sub>(<em>d</em>) &#x2192; <em>Y<sub>c</sub></em>(<em>d</em>). But by definition, this is <epub:switch id="mathmlSwitch1759"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mo stretchy='false'>(</mo><msub><mi>Y</mi><mi>f</mi></msub><mo stretchy='false'>)</mo></mrow><mi>d</mi></msub><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>&#x2032;</mo><mo>,</mo><mi>d</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>d</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="nl1-list">b. Given an element <epub:switch id="mathmlSwitch1760"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>g</mi><mo>&#x2208;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>&#x2032;</mo><mo>,</mo><mi>d</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we can precompose with <em>f</em> to get a morphism <epub:switch id="mathmlSwitch1761"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mover><mo>&#x2192;</mo><mi>f</mi></mover><mi>c</mi><mo>&#x2032;</mo><mover><mo>&#x2192;</mo><mi>g</mi></mover><mi>d</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, so let&#x2019;s define (<em>Y<sub>f</sub></em>)<em><sub>d</sub></em>(<em>g</em>) = <em>g</em> &#x25CB; <em>f</em>.</p>
<p class="nl1-list">c. The naturality square is as follows</p>
<p class="fig-img"><img src="images/Art_P306.jpg" alt="art"/></p>

<p class="nl1-list-para">and it commutes because, for any element <em>g</em> &#x2208; <em>Y</em><sub><em>c</em>&#x2032;</sub>(<em>d</em>), the composition <epub:switch id="mathmlSwitch1762"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mover><mo>&#x2192;</mo><mi>f</mi></mover><mi>c</mi><mo>&#x2032;</mo><mover><mo>&#x2192;</mo><mi>g</mi></mover><mi>d</mi><mover><mo>&#x2192;</mo><mi>h</mi></mover><mi>e</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is associative. More explicitly, going down then right we have (<em>Y<sub>f</sub></em>)<em><sub>d</sub></em>(<em>g</em>) = <em>g</em> &#x25CB; <em>f</em> and <em>Y<sub>c</sub></em>(<em>h</em>)(<em>g</em> &#x25CB; <em>f</em>) = <em>h</em> &#x25CB; (<em>g</em> &#x25CB; <em>f</em>). Going right then down we have <em>Y</em><sub><em>c</em>&#x2032;</sub>(<em>h</em>)(<em>g</em>) = <em>h</em> &#x25CB; <em>g</em> and (<em>Y<sub>f</sub></em>)<em><sub>e</sub></em>(<em>h</em> &#x25CB; <em>g</em>) = (<em>h</em> &#x25CB; <em>g</em>) &#x25CB; <em>f</em>. To reiterate, the associativity of composition in <epub:switch id="mathmlSwitch1763"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> insures that this square commutes.</p>
</section>
<a id="p327"></a>
<section title="Yoneda&#x2019;s lemma">
<h3 class="level3" id="lev_7-2-1-14"><strong>7.2.1.14&#160;&#160;&#160;Yoneda&#x2019;s lemma</strong></h3>
<p class="noindent">One of the most powerful tools in category theory is Yoneda&#x2019;s lemma. It is often considered by students to be quite abstract, but grounding it in databases may help.</p>
<p>Suppose that <epub:switch id="mathmlSwitch1764"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> is an arbitrary database instance, let <epub:switch id="mathmlSwitch1765"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be an object, and let <em>f</em> : <em>c</em> &#x2192; <em>c</em>&#x2032; be any outgoing arrow. Because <em>I</em> is a functor, we know that for every row <em>r</em> &#x2208; <em>I</em>(<em>c</em>) in table <em>c</em>, a value has been recorded in the <em>f</em> column. The value in the (<em>r</em>, <em>f</em>) cell refers to some row in table <em>c</em>&#x2032;. That is, each row in table <em>c</em> induces SIRS throughout the database as freely as possible (see Example <a href="chapter007.html#Exa_7-2-1-8">7.2.1.8</a>). The instance <em>Y<sub>c</sub></em> consists entirely of a single row &#x263A; in table <em>c</em> and its SIRS. The idea is that for any row <em>r</em> &#x2208; <em>I</em>(<em>c</em>) in arbitrary instance <em>I</em>, there exists a unique map <em>Y<sub>c</sub></em> &#x2192; <em>I</em> sending &#x263A; to <em>r</em>.</p>
<p class="noindent1-top-pro" id="Pro_7-2-1-15"><strong>Proposition 7.2.1.15</strong> (Yoneda&#x2019;s lemma, part 1). <em>Let</em> <epub:switch id="mathmlSwitch1766"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi></math></epub:case><epub:default></epub:default></epub:switch> <em>be a category,</em> <epub:switch id="mathmlSwitch1767"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>an object, and</em> <epub:switch id="mathmlSwitch1768"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>a set-valued functor. There is a natural bijection</em></p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1769"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></msub><mo stretchy='false'>(</mo><msub><mi>Y</mi><mi>c</mi></msub><mo>,</mo><mi>I</mi><mo stretchy='false'>)</mo><mover><mo>&#x2192;</mo><mo>&#x2245;</mo></mover><mi>I</mi><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top"><em>Proof</em>. See Mac Lane [29].</p>
<p class="noindent1-top-exe" id="Exa_7-2-1-16"><em>Example</em> 7.2.1.16. Consider the category <epub:switch id="mathmlSwitch1770"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> drawn as follows:</p>
<p class="fig-img"><img src="images/Art_P307.jpg" alt="art"/></p>
<p class="noindent">There are two representable functors, <em>Y</em><sub><span class="font1">Child</span></sub> and <em>Y</em><sub><span class="font1">Mother</span></sub>. The former, <epub:switch id="mathmlSwitch1771"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>Y</mi><mrow><mtext>Child</mtext></mrow></msub><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, is shown here:</p>

<p class="fig-img"><img src="images/Art_P308.jpg" alt="art"/></p>
<p class="noindent">The representable functor <em>Y</em><sub><span class="font1">Child</span></sub> is the freest instance possible, starting with one element in the <span class="font1">Child</span> table and satisfying the constraints. The latter, <em>Y</em><sub><span class="font1">Mother</span></sub> is the freest instance possible, starting with one element in the <span class="font1">Mother</span> table and satisfying the constraints. Since mother&#x25CB;firstChild=id<sub><span class="font1">Mother</span></sub>, this instance has just one row in each table:</p>
<a id="p328"></a>
<p class="fig-img"><img src="images/Art_P309.jpg" alt="art"/></p>
<p>Here is an arbitrary instance <epub:switch id="mathmlSwitch1772"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>:</p>
<p class="fig-img"><img src="images/Art_P310.jpg" alt="art"/></p>
<p>Yoneda&#x2019;s lemma (<a href="chapter007.html#Pro_7-2-1-15">7.2.1.15</a>) is about the set of natural transformations <em>Y</em><sub><span class="font1">Child</span></sub> &#x2192; <em>I</em>. Recall from Definition <a href="chapter005.html#Def_5-3-1-2">5.3.1.2</a> that a search for natural transformations can get tedious. Yoneda&#x2019;s lemma makes the calculation quite trivial. In this case there are exactly four such natural transformations, <epub:switch id="mathmlSwitch1773"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></msub><mo stretchy='false'>(</mo><msub><mi>Y</mi><mrow><mtext>Child</mtext></mrow></msub><mo>,</mo><mi>I</mi><mo stretchy='false'>)</mo><mo>&#x2245;</mo><mi>I</mi><mo stretchy='false'>(</mo><mtext>Child</mtext><mo stretchy='false'>)</mo><mo>&#x2245;</mo><munder accentunder='true'><mn>4</mn><mo>&#x00AF;</mo></munder></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and they are completely determined by where &#x263A; goes. In some sense the symbol &#x263A; in <em>Y</em><sub><span class="font1">Child</span></sub> <em>represents</em> childness in this database.</p>
<p class="noindent1-top-exe" id="Exe_7-2-1-17"><em>Exercise</em> 7.2.1.17.</p>
<p>Consider the schema <epub:switch id="mathmlSwitch1774"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> and instance <epub:switch id="mathmlSwitch1775"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> from Example <a href="chapter007.html#Exa_7-2-1-16">7.2.1.16</a>. Let <em>Y</em><sub><span class="font1">Child</span></sub> be the representable functor, and write (&#x263A; &#x21A6; Amy) for the unique natural transformation <em>Y</em><sub><span class="font1">Child</span></sub> &#x2192; <em>I</em> sending &#x263A; to Amy, and so on.</p>
<p class="nl1-list">a. What is (&#x263A; &#x21A6; Amy)<sub><span class="font1">Child</span></sub>(firstChild(mother(&#x263A;)))?<sup><a id="endnote_ref_9" href="chapter007.html#endnote_9">9</a></sup></p>

<p class="nl1-list">b. What is (&#x263A; &#x21A6; Bob)<sub><span class="font1">Child</span></sub>(firstChild(mother(&#x263A;)))?</p>
<p class="nl1-list">c. What is (&#x263A; &#x21A6; Carl)<sub><span class="font1">Child</span></sub>(firstChild(mother(&#x263A;)))?</p>
<p class="nl1-list">d. What is (&#x263A; &#x21A6; Amy)<sub><span class="font1">Mother</span></sub>(mother(&#x263A;))?</p>
<p class="nl1-list">e. In parts (a)&#x2013;(d), what information does the first subscript (<span class="font1">Child</span>, <span class="font1">Child</span>, <span class="font1">Child</span>, <span class="font1">Mother</span>) give you about the answer?</p>
<a id="p329"></a>
<p class="space-break">Section <a href="chapter007.html#lev_7-2-1-6">7.2.1.6</a> showed that a representable functor <epub:switch id="mathmlSwitch1776"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a mathematically generated database instance for an abstract thing of type <epub:switch id="mathmlSwitch1777"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>T</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. It creates placeholders for every attribute that things of type <em>T</em> are supposed to have.</p>
<p class="noindent1-top-slo"><em>Slogan</em> 7.2.1.18.</p>
<div class="pull-quote">
<p class="pq-noindent"><em>Yoneda&#x2019;s lemma says the following. Specifying an actual thing of type T is the same as filling in all placeholders found in the generic thing of type T</em>.</p></div>
<p>Yoneda&#x2019;s lemma is considered by many category theorists to be the most important tool in the subject. While its power is probably unclear to students whose sole background in category theory comes from this book, Yoneda&#x2019;s lemma is indeed extremely useful for reasoning. It allows us to move the notion of functor application into the realm of morphisms between functors (i.e., morphisms in <epub:switch id="mathmlSwitch1778"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi><mo>&#x2013;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch>, which are natural transformations). This keeps everything in one place&#x2014;it is all in the morphisms&#x2014;and thus more interoperable.</p>

<p class="noindent1-top-exe" id="Exa_7-2-1-19"><em>Example</em> 7.2.1.19. Example <a href="chapter004.html#Exa_4-1-1-27">4.1.1.27</a> discussed the cyclic monoid <epub:switch id="mathmlSwitch1779"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch> generated by the symbol <em>Q</em> and subject to the relation <em>Q</em><sup>7</sup> = <em>Q</em><sup>4</sup>, depicted as</p>
<p class="fig-img" id="eq_7-6"><img src="images/Art_P311.jpg" alt="art"/></p>
<p class="noindent1-top">Here is the mathematical foundation for this picture. Since <epub:switch id="mathmlSwitch1780"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch> is a category with one object, &#x25B2;, there is a unique representable functor (up to isomorphism) <epub:switch id="mathmlSwitch1781"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Y</mi><mo>&#x2254;</mo><msub><mi>Y</mi><mrow><mo>&#x25B2;</mo></mrow></msub><mo>:</mo><mi mathvariant='script'>M</mi><mo>&#x2192;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch>. Any functor <epub:switch id="mathmlSwitch1782"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi><mo>&#x2192;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch> can be thought of as a set with an <epub:switch id="mathmlSwitch1783"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch> action (see Section <a href="chapter005.html#lev_5-2-1-1">5.2.1.1</a>). In the case of <em>Y</em> , the required set is</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1784"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Y</mi><mo stretchy='false'>(</mo><mo>&#x25B2;</mo><mo stretchy='false'>)</mo><mo>=</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>M</mi></msub><mo stretchy='false'>(</mo><mo>&#x25B2;</mo><mo>,</mo><mo>&#x25B2;</mo><mo stretchy='false'>)</mo><mo>&#x2245;</mo><mo stretchy="false">&#x007B;</mo><msup><mi>Q</mi><mn>0</mn></msup><mo>,</mo><msup><mi>Q</mi><mn>1</mn></msup><mo>,</mo><msup><mi>Q</mi><mn>2</mn></msup><mo>,</mo><msup><mi>Q</mi><mn>3</mn></msup><mo>,</mo><msup><mi>Q</mi><mn>4</mn></msup><mo>,</mo><msup><mi>Q</mi><mn>5</mn></msup><mo>,</mo><msup><mi>Q</mi><mn>6</mn></msup><mo stretchy="false">&#x007D;</mo><mo>,</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">and the action is pretty straightforward (it is called the <em>principal action</em>). For example, <img src="images/Art_IP.jpg" alt="art"/>. We might say that (<a href="chapter007.html#eq_7-6">7.6</a>) is a picture of this principal action of <epub:switch id="mathmlSwitch1785"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p>However, we can go one step further. Given the functor <epub:switch id="mathmlSwitch1786"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>Y</mi><mo>:</mo><mi mathvariant='script'>M</mi><mo>&#x2192;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch>, we can take its category of elements, <epub:switch id="mathmlSwitch1787"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mo>&#x222B;</mo><mi mathvariant='script'>M</mi></msub><mi>Y</mi></math></epub:case><epub:default></epub:default></epub:switch> (see Section <a href="chapter006.html#lev_6-2-2">6.2.2</a>). The category <epub:switch id="mathmlSwitch1788"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mo>&#x222B;</mo><mi mathvariant='script'>M</mi></msub><mi>Y</mi></math></epub:case><epub:default></epub:default></epub:switch> has objects <em>Y</em>(&#x25B2;) &#x2208; Ob(<strong>Set</strong>), i.e., the set of dots in (<a href="chapter007.html#eq_7-6">7.6</a>), and it has a unique morphism <em>Q<sup>i</sup></em> &#x2192; <em>Q<sup>j</sup></em> for every path of length &#x2A7D; 6 from <em>Q<sup>i</sup></em> to <em>Q<sup>j</sup></em> in that picture. So the drawing of <epub:switch id="mathmlSwitch1789"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch> in (<a href="chapter007.html#eq_7-6">7.6</a>) is actually the category of elements of <epub:switch id="mathmlSwitch1790"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>M</mi></math></epub:case><epub:default></epub:default></epub:switch>&#x2019;s unique representable functor.</p>
<p class="noindent1-top-exe" id="Exe_7-2-1-20"><em>Exercise</em> 7.2.1.20.</p>
<a id="p330"></a>
<p>Let <epub:switch id="mathmlSwitch1791"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> be a category, let <epub:switch id="mathmlSwitch1792"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be an object, and let <epub:switch id="mathmlSwitch1793"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be in instance of <epub:switch id="mathmlSwitch1794"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi></math></epub:case><epub:default></epub:default></epub:switch>. Consider <em>c</em> also as a functor <epub:switch id="mathmlSwitch1795"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>:</mo><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and recall the pullback functor <epub:switch id="mathmlSwitch1796"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x0394;</mo><mi>c</mi></msub><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> and its left adjoint <epub:switch id="mathmlSwitch1797"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A3;</mo><mi>c</mi></msub><mo>:</mo><mtext mathvariant='bold'>Set</mtext><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> (see Section <a href="chapter007.html#lev_7-1-4">7.1.4</a>).</p>
<p class="nl1-list">a. What is the set &#x0394;<em><sub>c</sub></em>(<em>I</em>)?</p>
<p class="nl1-list">b. What is Hom<strong><sub>Set</sub></strong>({&#x263A;}, &#x0394;<em><sub>c</sub></em>(<em>I</em>))?</p>
<p class="nl1-list">c. What is <epub:switch id="mathmlSwitch1798"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></msub><mo stretchy='false'>(</mo><msub><mo>&#x03A3;</mo><mi>c</mi></msub><mo stretchy='false'>(</mo><mo stretchy="false">&#x007B;</mo><mo>&#x263A;</mo><mo stretchy="false">&#x007D;</mo><mo stretchy='false'>)</mo><mo>,</mo><mi>I</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>?</p>
<p class="nl1-list">d. How does &#x03A3;<em><sub>c</sub></em>({&#x263A;}) compare to <em>Y<sub>c</sub></em>, the functor represented by <em>c</em>, as objects in <epub:switch id="mathmlSwitch1799"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi><mo>&#x2013;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch>?</p>

<p class="noindent1-top-pro" id="Pro_7-2-1-21"><strong>Proposition 7.2.1.21</strong> (Yoneda&#x2019;s lemma, part 2). <em>Let</em> <epub:switch id="mathmlSwitch1800"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi></math></epub:case><epub:default></epub:default></epub:switch> <em>be a category. The assignment c</em> &#x21A6; <em>Y<sub>c</sub> from Proposition</em> <a href="chapter007.html#Pro_7-2-1-15">7.2.1.15</a> <em>extends to a functor</em> <epub:switch id="mathmlSwitch1801"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Y</mi><mo>:</mo><msup><mi mathvariant='script'>C</mi><mrow><mtext>op</mtext></mrow></msup><mo>&#x2192;</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <em>and this functor is fully faithful</em>.</p>
<p><em>In particular, if</em> <epub:switch id="mathmlSwitch1802"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>,</mo><mi>c</mi><mo>&#x2032;</mo><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> <em>are objects and there is an isomorphism Y<sub>c</sub></em> &#x2245; <em>Y</em><sub><em>c</em>&#x2032;</sub> <em>in</em> <epub:switch id="mathmlSwitch1803"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, <em>then there is an isomorphism c</em> &#x2245; <em>c</em>&#x2032; <em>in</em> <epub:switch id="mathmlSwitch1804"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="noindent1-top"><em>Proof</em>. See Mac Lane [29].</p>
<p class="noindent1-top-exe" id="Exe_7-2-1-22"><em>Exercise</em> 7.2.1.22.</p>
<p>The distributive law for addition of natural numbers says <em>c</em> &#x00D7; (<em>a</em> + <em>b</em>) = <em>c</em> &#x00D7; <em>a</em> + <em>c</em> &#x00D7; <em>b</em>. Following is a proof of the distributive law using category-theoretic reasoning. Annotate anything shown in red with a justification for why it is true.</p>
<p class="noindent1-top"><em>Proposition</em> (Distributive law). <em>For any natural numbers a, b, c</em> &#x2208; &#x2115;, <em>the distributive law holds:</em></p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1805"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo stretchy='false'>(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy='false'>)</mo><mo>=</mo><mi>c</mi><mi>a</mi><mo>+</mo><mi>c</mi><mi>b</mi><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top"><em>Sketch of proof. To finish, justify things shown in red</em>.</p>
<p class="noindent">Let <em>A</em>, <em>B</em>, <em>C</em> be finite sets, and let <em>X</em> be another finite set.</p>
<table>
<tbody>
<tr>
<td class="td1all">Hom<strong><sub>Set</sub></strong>(<em>C</em> &#x00D7; (<em>A</em> + <em>B</em>), <em>X</em>)</td>
<td class="td1all"><span class="color2">&#x2245;</span>Hom<strong><sub>Set</sub></strong>(<em>A</em> + <em>B</em>, <em>X<sup>C</sup></em>)</td>
</tr>
<tr>
<td class="td1all"></td>
<td class="td1all"><span class="color2">&#x2245;</span>Hom<strong><sub>Set</sub></strong>(<em>A</em>, <em>X<sup>C</sup></em>) &#x00D7; Hom<strong><sub>Set</sub></strong>(<em>B</em>, <em>X<sup>C</sup></em>)</td>
</tr>
<tr>
<td class="td1all"></td>
<td class="td1all"><span class="color2">&#x2245;</span>Hom<strong><sub>Set</sub></strong>(<em>C</em> &#x00D7; <em>A</em>, <em>X</em>) &#x00D7; Hom<strong><sub>Set</sub></strong>(<em>C</em> &#x00D7; <em>B</em>, <em>X</em>)</td>
</tr>
<tr>
<td class="td1all"></td>
<td class="td1all"><span class="color2">&#x2245;</span> Hom<strong><sub>Set</sub></strong>((<em>C</em> &#x00D7; <em>A</em>) + (<em>C</em> &#x00D7; <em>B</em>), <em>X</em>).</td>
</tr>
</tbody>
</table>

<p class="noindent">By <span class="color2">the appropriate application</span> of Yoneda&#x2019;s lemma, we see that there is an isomorphism</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1806"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi><mo>&#x00D7;</mo><mo stretchy='false'>(</mo><mi>A</mi><mo>+</mo><mi>B</mi><mo stretchy='false'>)</mo><mo>&#x2245;</mo><mo stretchy='false'>(</mo><mi>C</mi><mo>&#x00D7;</mo><mi>A</mi><mo stretchy='false'>)</mo><mo>+</mo><mo stretchy='false'>(</mo><mi>C</mi><mo>&#x00D7;</mo><mi>B</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">in <strong>Fin</strong>. The result about natural numbers <span class="color2">follows</span>.</p>
</section>
<a id="p331"></a>
<section title="The subobject classifier">
<h3 class="level3" id="lev_7-2-1-23"><strong>7.2.1.23&#160;&#160;&#160;The subobject classifier</strong> <epub:switch id="mathmlSwitch1807"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>&#x03A9;</mo><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></h3>
<p class="noindent">If <epub:switch id="mathmlSwitch1808"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> is a category, then the functor category <epub:switch id="mathmlSwitch1809"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi><mo>&#x2013;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch> is a special kind of category, called a <em>topos</em>. Note that when <epub:switch id="mathmlSwitch1810"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>=</mo><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder></mrow></math></epub:case><epub:default></epub:default></epub:switch> is the terminal category, then we have an isomorphism <span class="underline">1</span>&#x2013;<strong>Set</strong> &#x2245; <strong>Set</strong>, so the category of sets is a special case of a topos. What is interesting about toposes (or topoi) is that they generalize many properties of <strong>Set</strong>. This short section investigates only one such property, namely, that <epub:switch id="mathmlSwitch1811"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi><mo>&#x2013;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch> has a subobject classifier, denoted <epub:switch id="mathmlSwitch1812"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>&#x03A9;</mo><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. In the case <epub:switch id="mathmlSwitch1813"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>=</mo><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder></mrow></math></epub:case><epub:default></epub:default></epub:switch> the subobject classifier is {<em>True</em>, <em>False</em>} &#x2208; Ob(<strong>Set</strong>) (see Definition <a href="chapter003.html#Def_3-4-4-9">3.4.4.9</a>).</p>
<p>As usual, we consider the matter of subobject classifiers by grounding the discussion in terms of databases. The analogue of {<em>True</em>, <em>False</em>} for an arbitrary database can be quite complex&#x2014;it encodes the whole story of relational database instances for that schema.</p>

<p class="noindent1-top-def" id="Def_7-2-1-24"><strong>Definition 7.2.1.24</strong>. Let <epub:switch id="mathmlSwitch1814"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> be a category, let <epub:switch id="mathmlSwitch1815"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi><mo>&#x2013;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch> denote its category of instances, and let <epub:switch id="mathmlSwitch1816"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mn>1</mn><mi mathvariant="script">C</mi></msub><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> denote the terminal object. A <em>subobject classifier for</em> <epub:switch id="mathmlSwitch1817"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> is an object <epub:switch id="mathmlSwitch1818"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant="script">C</mi></msub><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and a morphism <epub:switch id="mathmlSwitch1819"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>t</mi><mo>:</mo><msub><mn>1</mn><mi mathvariant='script'>C</mi></msub><mo>&#x2192;</mo><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> with the following property. For any monomorphism <em>f</em> : <em>I</em> &#x2192; <em>J</em> in <epub:switch id="mathmlSwitch1820"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi><mo>&#x2013;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch>, there exists a unique morphism <epub:switch id="mathmlSwitch1821"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="italic">char</mi><mo stretchy='false'>(</mo><mi>f</mi><mo stretchy='false'>)</mo><mo>:</mo><mi>J</mi><mo>&#x2192;</mo><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> such that the following diagram is a pullback in <epub:switch id="mathmlSwitch1822"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi><mo>&#x2013;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch>:</p>
<p class="fig-img"><img src="images/Art_P312.jpg" alt="art"/></p>
<p class="noindent">That is, for any instance <em>J</em> there is a bijection</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1823"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>J</mi><mo>,</mo><mo>&#x03A9;</mo><mo stretchy='false'>)</mo><mo>&#x2245;</mo><mo stretchy="false">&#x007B;</mo><mi>I</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy="false">(</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo stretchy="false">)</mo><mo stretchy="false">&#x007C;</mo><mi>I</mi><mo>&#x2286;</mo><mi>J</mi><mo stretchy="false">&#x007D;</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p>In terms of databases, what this means is that for every schema <epub:switch id="mathmlSwitch1824"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi></math></epub:case><epub:default></epub:default></epub:switch>, there is some special instance <epub:switch id="mathmlSwitch1825"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant="script">C</mi></msub><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> that somehow classifies subinstances of anything. When the schema is the terminal category, <epub:switch id="mathmlSwitch1826"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>=</mo><munder accentunder='true'><mn>1</mn><mo>&#x00AF;</mo></munder></mrow></math></epub:case><epub:default></epub:default></epub:switch>, instances are sets and according to Definition <a href="chapter003.html#Def_3-4-4-9">3.4.4.9</a> the subobject classifier is &#x03A9;<sub><span class="underline">1</span></sub> = {<em>True</em>, <em>False</em>}. One might think that the subobject classifier for <epub:switch id="mathmlSwitch1827"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi><mo>&#x2013;</mo><mtext mathvariant="bold">Set</mtext></math></epub:case><epub:default></epub:default></epub:switch> should just consist of a two-element set table by table, i.e., that for every <epub:switch id="mathmlSwitch1828"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we should have <epub:switch id="mathmlSwitch1829"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub><msup><mo>=</mo><mo>?</mo></msup><mo stretchy="false">&#x007B;</mo><mi mathvariant="italic">True</mi><mo>,</mo><mi mathvariant="italic">False</mi><mo stretchy="false">&#x007D;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, but this is not correct.</p>
<p>In fact, for any object <epub:switch id="mathmlSwitch1830"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, there is a way to figure out what <epub:switch id="mathmlSwitch1831"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> has to be. We know by Yoneda&#x2019;s lemma (Proposition <a href="chapter007.html#Pro_7-2-1-15">7.2.1.15</a>) that <epub:switch id="mathmlSwitch1832"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>=</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></msub><mo stretchy='false'>(</mo><msub><mi>Y</mi><mi>c</mi></msub><mo>,</mo><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, where <em>Y<sub>c</sub></em> is the functor represented by <em>c</em>. There is a bijection between <epub:switch id="mathmlSwitch1833"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext></mrow></msub><mo stretchy='false'>(</mo><msub><mi>Y</mi><mi>c</mi></msub><mo>,</mo><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and the set of subinstances of <em>Y<sub>c</sub></em>. Thus we have</p>
<p class="disp-equ-no" id="eq_7-7"><epub:switch id="mathmlSwitch1834"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd columnalign="left"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>=</mo><mo stretchy="false">&#x007B;</mo><mi>I</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy="false">(</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo stretchy="false">)</mo><mo stretchy="false">&#x007C;</mo><mi>I</mi><mo>&#x2286;</mo><msub><mi>Y</mi><mi>c</mi></msub><mo stretchy="false">&#x007D;</mo><mo>.</mo></mrow></mtd><mtd columnalign="right"><mrow><mo stretchy='false'>(</mo><mn>7.7</mn><mo stretchy='false'>)</mo></mrow></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<a id="p332"></a>
<p>How should <epub:switch id="mathmlSwitch1835"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> behave on morphisms? By Exercise <a href="chapter007.html#Exe_7-2-1-13">7.2.1.13</a>, each morphism <em>f</em> : <em>c</em> &#x2192; <em>d</em> in <epub:switch id="mathmlSwitch1836"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> induces a morphism <em>Y<sub>f</sub></em> : <em>Y<sub>d</sub></em> &#x2192; <em>Y<sub>c</sub></em>, and the map <epub:switch id="mathmlSwitch1837"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>f</mi><mo stretchy='false'>)</mo><mo>:</mo><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>d</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> sends a subinstance <em>A</em> &#x2286; <em>Y<sub>c</sub></em> to the pullback</p>
<p class="fig-img" id="eq_7-8"><img src="images/Art_P313.jpg" alt="art"/></p>
<p class="noindent">That is, <epub:switch id="mathmlSwitch1838"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>f</mi><mo stretchy='false'>)</mo><mo stretchy='false'>(</mo><mi>A</mi><mo stretchy='false'>)</mo><mo>=</mo><msubsup><mi>Y</mi><mi>f</mi><mrow><mo>&#x2212;</mo><mn>1</mn></mrow></msubsup><mo stretchy='false'>(</mo><mi>A</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p>We have now fully described <epub:switch id="mathmlSwitch1839"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> as a functor, but the description is very abstract. Here is an example of a subobject classifier.</p>

<p class="noindent1-top-exe" id="Exa_7-2-1-25"><em>Example</em> 7.2.1.25. Consider the following category <epub:switch id="mathmlSwitch1840"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2245;</mo><mo stretchy='false'>[</mo><mn>3</mn><mo stretchy='false'>]</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>:</p>
<p class="fig-img"><img src="images/Art_P314.jpg" alt="art"/></p>
<p class="noindent">To write <epub:switch id="mathmlSwitch1841"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we need to understand the representable functors <epub:switch id="mathmlSwitch1842"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>Y</mi><mi>c</mi></msub><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, for <em>c</em> = <span class="font1">0</span>, <span class="font1">1</span>, <span class="font1">2</span>, <span class="font1">3</span>, as well as their subobjects. Here is <em>Y</em><sub><span class="font1">0</span></sub> as an instance:</p>
<p class="fig-img"><img src="images/Art_P315.jpg" alt="art"/></p>
<p>What are the subinstances of this? There is the empty subinstance &#x2205; &#x2286; <em>Y</em><sub><span class="font1">0</span></sub> and the identity subinstance <em>Y</em><sub><span class="font1">0</span></sub> &#x2286; <em>Y</em><sub><span class="font1">0</span></sub>. But there are three more as well. Note that if we want to keep the &#x263A; row of table <span class="font1">0</span>, then we have to keep everything. But if we throw away the &#x263A; row of table <span class="font1">0</span>, we can still keep the rest and get a subinstance. If we want to keep the after_1(&#x263A;) row of table <span class="font1">1</span>, then we have to keep its images in tables <span class="font1">2</span> <a id="p333"></a>and <span class="font1">3</span>. But we could throw away both the &#x263A; row of table <span class="font1">0</span> and the after_1(&#x263A;) row of table <span class="font1">1</span> and still keep the rest. And so on. In other words, there are five subobjects of <em>Y</em><sub><span class="font1">0</span></sub>, i.e., elements of <epub:switch id="mathmlSwitch1843"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, but they are hard to name. We arbitrarily name them by <epub:switch id="mathmlSwitch1844"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo><mo>&#x2254;</mo><mo stretchy="false">&#x007B;</mo><mi mathvariant="italic">yes</mi><mo>,</mo><mo>&#x00A0;</mo><mtext mathvariant="italic">wait 1</mtext><mo>,</mo><mo>&#x00A0;</mo><mtext mathvariant="italic">wait 2</mtext><mo>,</mo><mo>&#x00A0;</mo><mtext mathvariant="italic">wait 3</mtext><mo>,</mo><mo>&#x00A0;</mo><mtext mathvariant="italic">never</mtext><mo stretchy="false">&#x007D;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p>The same analysis holds for the other tables of <epub:switch id="mathmlSwitch1845"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>. For example, we denote the three subinstances of <em>Y</em><sub>2</sub> by <epub:switch id="mathmlSwitch1846"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mn>2</mn><mo stretchy='false'>)</mo><mo>=</mo><mo stretchy="false">&#x007B;</mo><mtext mathvariant="italic">yes</mtext><mo>,</mo><mo>&#x00A0;</mo><mtext mathvariant="italic">wait 1</mtext><mo>,</mo><mo>&#x00A0;</mo><mtext mathvariant="italic">never</mtext><mo stretchy="false">&#x007D;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. In sum, the database instance <epub:switch id="mathmlSwitch1847"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> is:</p>
<p class="fig-img"><img src="images/Art_P316.jpg" alt="art"/></p>

<p class="noindent">The morphism <epub:switch id="mathmlSwitch1848"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>1</mn><mo>&#x2192;</mo><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> picks out the <em>yes</em> row of every table.</p>
<p>Now that we have constructed <epub:switch id="mathmlSwitch1849"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we are ready to use it. What makes <epub:switch id="mathmlSwitch1850"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> special is that for any instance <epub:switch id="mathmlSwitch1851"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, the subinstances if <em>X</em> are in one-to-one correspondence with the instance morphisms <epub:switch id="mathmlSwitch1852"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi><mo>&#x2192;</mo><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Consider the following arbitrary instance <em>X</em>, where the blue rows denote a subinstance <em>A</em> &#x2286; <em>X</em>.</p>
<p class="fig-img" id="eq_7-9"><img src="images/Art_P317.jpg" alt="art"/></p>
<p>This blue subinstance <em>A</em> &#x2286; <em>X</em> corresponds to a natural transformation <epub:switch id="mathmlSwitch1853"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="italic">char</mtext><mo stretchy='false'>(</mo><mi>A</mi><mo stretchy='false'>)</mo><mo>:</mo><mi>X</mi><mo>&#x2192;</mo><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>. That is, for each <epub:switch id="mathmlSwitch1854"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, all the rows in the <em>c</em> table of <em>X</em> are sent to the rows in the <em>c</em> table of <epub:switch id="mathmlSwitch1855"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>, as they would be for any natural transformation. The way <em>char</em>(<em>A</em>) <a id="p334"></a>works is as follows. For each table <em>i</em> and row <em>x</em> &#x2208; <em>X</em>(<em>i</em>), find the first column <em>f</em> in which the entry is blue (i.e., <em>f</em>(<em>x</em>) &#x2208; <em>A</em>), and send <em>x</em> to the corresponding element of <epub:switch id="mathmlSwitch1856"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. For example, <em>char</em>(<em>A</em>)(<span class="font1">0</span>) sends <em>a</em><sub>1</sub> to <em>wait 2</em> and sends <em>a</em><sub>4</sub> to <em>never</em>, and <em>char</em>(<em>A</em>)(<span class="font1">2</span>) sends <em>c</em><sub>1</sub> to <em>yes</em> and sends <em>c</em><sub>2</sub> to <em>never</em>.</p>
<p class="noindent1-top-exe" id="Exe_7-2-1-26"><em>Exercise</em> 7.2.1.26.</p>
<p class="nl1-list">a. Write the blue subinstance <em>A</em> &#x2286; <em>X</em> shown in (<a href="chapter007.html#eq_7-9">7.9</a>) as an instance of <epub:switch id="mathmlSwitch1857"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">C</mi></math></epub:case><epub:default></epub:default></epub:switch>, i.e., as four tables.</p>
<p class="nl1-list">b. This subinstance <em>A</em> &#x2286; <em>X</em> corresponds to a map <epub:switch id="mathmlSwitch1858"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x2113;</mi><mo>&#x2254;</mo><mtext mathvariant="italic">char</mtext><mo stretchy='false'>(</mo><mi>A</mi><mo stretchy='false'>)</mo><mo>:</mo><mi>X</mi><mo>&#x2192;</mo><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>. For all <epub:switch id="mathmlSwitch1859"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we have a function <epub:switch id="mathmlSwitch1860"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x2113;</mi><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>:</mo><mi>X</mi><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. With <em>c</em> = 1, write out <epub:switch id="mathmlSwitch1861"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x2113;</mi><mo stretchy='false'>(</mo><mn>1</mn><mo stretchy='false'>)</mo><mo>:</mo><mi>X</mi><mo stretchy='false'>(</mo><mn>1</mn><mo stretchy='false'>)</mo><mo>&#x2192;</mo><msub><mo>&#x03A9;</mo><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mn>1</mn><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>

<p class="noindent1-top-exe" id="Exe_7-2-1-27"><em>Exercise</em> 7.2.1.27.</p>
<p>Let <epub:switch id="mathmlSwitch1862"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> be the loop schema</p>
<p class="fig-img"><img src="images/Art_P318.jpg" alt="art"/></p>
<p class="nl1-list">a. What is the subobject classifier <epub:switch id="mathmlSwitch1863"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mo>&#x03A9;</mo><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></msub><mo>&#x2208;</mo><mtext>Ob</mtext><mrow><mo>(</mo><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext><mo>&#x2212;</mo><mtext mathvariant="bold">Set</mtext></mrow><mo>)</mo></mrow></mrow></math></epub:case><epub:default></epub:default></epub:switch>? (Write it out in table form.)</p>
<p class="nl1-list">b. In Exercise <a href="chapter007.html#Exe_7-2-1-10">7.2.1.10</a> you computed the representable functor <em>Y<sub>s</sub></em>. How does <epub:switch id="mathmlSwitch1864"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mo>&#x03A9;</mo><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> compare to <em>Y<sub>s</sub></em>?</p>
<p class="nl1-list">c. Consider the discrete dynamical system <em>X</em> and its subset <em>W</em> &#x2286; <em>X</em>:</p>
<p class="fig-img"><img src="images/Art_P319.jpg" alt="art"/></p>

<p class="nl1-list-para">What is the morphism <epub:switch id="mathmlSwitch1865"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns='http://www.w3.org/1998/Math/MathML'><mtext mathvariant="italic">char</mtext><mo>(</mo><mi>W</mi><mo>)</mo><mo>:</mo><mi>X</mi><mo>&#x2192;</mo><mrow><msub><mo>&#x03A9;</mo><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> that corresponds to this subobject?</p>
<a id="p335"></a>
<p class="noindent1-top-exe" id="Exe_7-2-1-28"><em>Exercise</em> 7.2.1.28.</p>
<p>Let <img src="images/Art_P320.jpg" alt="art"/> be the indexing category for graphs.</p>

<p class="nl1-list">a. Write the subobject classifier &#x03A9;<strong><sub>GrIn</sub></strong> &#x2208; Ob(<strong>GrIn</strong>&#x2013;<strong>Set</strong>) in tabular form, i.e., as two tables.</p>
<p class="nl1-list">b. Draw &#x03A9;<strong><sub>GrIn</sub></strong> as a graph.</p>
<p class="nl1-list">c. Let <em>G</em> be the following graph and <em>G</em>&#x2032; &#x2286; <em>G</em> the blue part.</p>
<p class="fig-img"><img src="images/Art_P321.jpg" alt="art"/></p>
<p class="nl1-list-para">Write <em>G</em> &#x2208; Ob(<strong>GrIn</strong>&#x2013;<strong>Set</strong>) in tabular form.</p>
<p class="nl1-list">d. Write the components of the natural transformation <em>char</em>(<em>G</em>&#x2032;): <em>G</em> &#x2192; &#x03A9;<strong><sub>GrIn</sub></strong>.</p>


</section>
</section>
<section title="Database instances in other categories">
<h2 class="level2" id="lev_7-2-2"><strong>7.2.2&#160;&#160;&#160;Database instances in other categories</strong></h2>
<p class="noindent">So far we have focused on the category <epub:switch id="mathmlSwitch1866"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mtext mathvariant='bold'>Set</mtext><mo>=</mo><mtext>Fun</mtext><mo stretchy="false">(</mo><mi mathvariant='script'>C</mi><mo>,</mo><mtext mathvariant='bold'>Set</mtext><mo stetchy="false">)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> of set-valued functors <epub:switch id="mathmlSwitch1867"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> for arbitrary categories, or database schemas, <epub:switch id="mathmlSwitch1868"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>. What if we allow the target category <strong>Set</strong> to change?</p>
<section title="Representations of groups">
<h3 class="level3" id="lev_7-2-2-1"><strong>7.2.2.1&#160;&#160;&#160;Representations of groups</strong></h3>
<p class="noindent">The classical mathematical subject of <em>representation theory</em> is the study of Fun(<em>G</em>, <strong>Vect</strong>), where <em>G</em> is a group and <strong>Vect</strong> is the category of vector spaces (over, say, &#x211D;). Every such functor <em>F</em> : <em>G</em> &#x2192; <strong>Vect</strong> is called a <em>representation of G</em>. Since <em>G</em> is a category with one object &#x25B2;, the functor <em>F</em> provides a single vector space <em>V</em> = <em>F</em> (&#x25B2;) together with an action of <em>G</em> on it.</p>
<p>We can think of this in terms of databases if we have a presentation of <em>G</em> in terms of generators and relations. The schema corresponding to <em>G</em> has one table, and this table <a id="p336"></a>has a column for each generator (see Section <a href="chapter004.html#lev_4-1-3">4.1.3</a>). Giving a representation <em>F</em> is the same as giving an instance on the schema, with some properties that stem from the fact that the target category is <strong>Vect</strong> rather than <strong>Set</strong>. There are many possibilities for expressing such data.</p>
<p>One possibility is if we could draw <em>V</em> , say, if <em>V</em> were one-, two-, or three-dimensional. If so, let <em>P</em> be the chosen picture of <em>V</em> , e.g., <em>P</em> is the standard drawing of a Cartesian coordinate plane <em>V</em> = &#x211D;<sup>2</sup>. Then every column of the table would consist entirely of the picture <em>P</em> instead of a set of rows. Touching a point in the ID column &#x211D;<sup>2</sup> would result in a point being drawn in the &#x211D;<sup>2</sup> corresponding to the other column, in accordance with the <em>G</em> action. Each column would, of course, respect addition and scalar multiplication.</p>
<p>Another possibility is to use the fact that there is a functor <em>U</em> : <strong>Vect</strong> &#x2192; <strong>Set</strong>, so the instance <em>F</em> : <em>G</em> &#x2192; <strong>Vect</strong> could be converted to an ordinary instance <em>U</em> &#x25CB; <em>F</em> : <em>G</em> &#x2192; <strong>Set</strong>. We would have an ordinary set of rows. This set would generally be infinite, but it would be structured by addition and scalar multiplication. For example, assuming <em>V</em> is finite-dimensional, one could find a few rows that generated the rest.</p>
<p>A third possibility is to use monads, which would allow the table to have only as many rows as <em>V</em> has dimensions. This yields a considerable saving of space. See Section <a href="chapter007.html#lev_7-3">7.3</a>. In all these possibilities, the usual tabulated format of databases has been slightly altered to accommodate the extra information in a vector space.</p>
</section>
<section title="Representations of quivers">
<h3 class="level3" id="lev_7-2-2-2"><strong>7.2.2.2&#160;&#160;&#160;Representations of quivers</strong></h3>
<p class="noindent">Representation theory also studies representations of quivers. A <em>quiver</em> is just the free category (see Example <a href="chapter005.html#Exa_5-1-2-33">5.1.2.33</a>) on a graph. If <em>P</em> is a graph with free category <epub:switch id="mathmlSwitch1869"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>P</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, then a representation of the quiver <epub:switch id="mathmlSwitch1870"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>P</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a functor <epub:switch id="mathmlSwitch1871"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant="script">P</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Vect</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Such a representation consists of a vector space at each vertex of <em>P</em> and a linear transformation for each arrow. All the discussion in Section <a href="chapter007.html#lev_7-2-2-1">7.2.2.1</a> works in this setting, except that there is more than one table.</p>
</section>
<section title="Other target categories">
<h3 class="level3" id="lev_7-2-2-3"><strong>7.2.2.3&#160;&#160;&#160;Other target categories</strong></h3>
<p class="noindent">One can imagine the value of using target categories other than <strong>Set</strong> or <strong>Vect</strong> for databases.</p>
<p class="noindent1-top-app" id="App_7-2-2-4"><em>Application</em> 7.2.2.4. <span class="underline">Geographic data</span> consists of maps of the earth together with various functions on it. For example, for any point on the earth one may want to know the average of temperatures recorded in the past ten years or the precise temperature at this moment. Earth can be considered as a topological space, <em>E</em>. Similarly, temperatures on earth reside on a continuum, say, the space <em>T</em> of real numbers [&#x2212;100, 200]. Thus the temperature record is a continuous function <em>E</em> &#x2192; <em>T</em> .</p>
<a id="p337"></a>
<p>Other records such as precipitation, population density, elevation, and so on, can all be considered as continuous functions from <em>E</em> to some space. Agencies like the U.S. Geological Survey hold databases of such information. By modeling them on functors <epub:switch id="mathmlSwitch1872"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Top</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, they may be able to employ mathematical tools such as persistent homology (see Weinberger [44]) to find interesting invariants of the data.</p>
<p class="noindent1-top-app" id="App_7-2-2-5"><em>Application</em> 7.2.2.5. Application <a href="chapter007.html#App_7-2-2-4">7.2.2.4</a> discussed using topological database instances to model geographical data. Other scientific disciplines could use the same kind of tool. For example, in studying the <span class="underline">mechanics of materials</span>, one may want to consider the material as a topological space <em>M</em> and measure values such as energy as a continuous map <em>M</em> &#x2192; <em>E</em>. Such observations could be modeled by databases with target category <strong>Top</strong> or <strong>Vect</strong> rather than <strong>Set</strong>.</p>

</section>
</section>
<section title="Sheaves">
<h2 class="level2" id="lev_7-2-3"><strong>7.2.3&#160;&#160;&#160;Sheaves</strong></h2>
<p class="noindent">Let <em>X</em> be a topological space (see Example <a href="chapter005.html#Exa_5-2-3-1">5.2.3.1</a>), such as a sphere. Section <a href="chapter007.html#lev_7-2-2-3">7.2.2.3</a> discussed continuous functions out of <em>X</em> and their use in science (e.g., recording temperatures on the earth as a continuous map <em>X</em> &#x2192; [&#x2212;100, 200]). Sheaves allow us to consider the local-global nature of such maps, taking into account reparable discrepancies in data-gathering tools.</p>
<p class="noindent1-top-app" id="App_7-2-3-1"><em>Application</em> 7.2.3.1. Suppose that <em>X</em> is the topological space corresponding to the earth, and let <em>region</em> mean an open subset <em>U</em> &#x2286; <em>X</em>. Suppose that we cover <em>X</em> with 10,000 regions <em>U</em><sub>1</sub>, <em>U</em><sub>2</sub>, &#x2026;, <em>U</em><sub>10000</sub>, such that some of the regions overlap in a nonempty subregion (e.g., <em>U</em><sub>5</sub> &#x2229; <em>U</em><sub>9</sub> &#x2260; &#x2205;). For each <em>i</em>, <em>j</em>, let <em>U</em><sub><em>i</em>,<em>j</em></sub> = <em>U<sub>i</sub></em> &#x2229; <em>U<sub>j</sub></em>.</p>
<p>For each region <em>U<sub>i</sub></em> &#x2286; <em>X</em>, we have a temperature-recording device, which gives a function <em>T<sub>i</sub></em> : <em>U<sub>i</sub></em> &#x2192; [&#x2212;100, 200]. If <em>U<sub>i</sub></em> &#x2229; <em>U<sub>j</sub></em> &#x2260; &#x2205;, then two different recording devices give us temperature data for the intersection <em>U</em><sub><em>i</em>,<em>j</em></sub>. Suppose we find that they do not give precisely the same data but that there is a translation formula between their results. For example, <em>T<sub>i</sub></em> might register 3<sup>&#x25CB;</sup> warmer than <em>T<sub>j</sub></em> registers, throughout the region <em>U<sub>i</sub></em> &#x2229; <em>U<sub>j</sub></em>.</p>
<p>Roughly speaking, a consistent system of translation formulas is called a <em>sheaf</em>. It does not demand a universal true temperature function but only a consistent translation system between them.</p>
<p class="space-break">Definitions <a href="chapter007.html#Def_7-2-3-2">7.2.3.2</a> and <a href="chapter007.html#Def_7-2-3-5">7.2.3.5</a> make the notion of sheaf precise, but it is developed slowly at first.</p>
<p>For every region <em>U</em>, we can record the value of some function (say, temperature) throughout <em>U</em>. Although this record might consist of a mountain of data (a temperature for each point in <em>U</em>), it can be thought of as one thing. That is, it is one element in the <a id="p338"></a>set of &#x201C;value assignments throughout <em>U</em>&#x201D;. A sheaf holds the set of &#x201C;value assignments throughout <em>U</em>&#x201D; for each region <em>U</em> as well as how a &#x201C;value assignment throughout <em>U</em>&#x201D; restricts to a &#x201C;value assignment throughout <em>V</em> &#x201D; for any subset <em>V</em> &#x2286; <em>U</em>.</p>
<p class="noindent1-top-def" id="Def_7-2-3-2"><strong>Definition 7.2.3.2</strong>. Let <em>X</em> be a topological space, let Open(<em>X</em>) denote its partial order of open sets, and let Open(<em>X</em>)<sup>op</sup> be the opposite category. A <em>presheaf on X</em> is a functor <epub:switch id="mathmlSwitch1873"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo>:</mo><mtext>Open</mtext><msup><mrow><mo stretchy='false'>(</mo><mi>X</mi><mo stretchy='false'>)</mo></mrow><mrow><mtext>op</mtext></mrow></msup><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>. For every open set <em>U</em> &#x2286; <em>X</em>, we refer to the set <epub:switch id="mathmlSwitch1874"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>U</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> as the <em>set of value assignments throughout U of</em> <epub:switch id="mathmlSwitch1875"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">O</mi></math></epub:case><epub:default></epub:default></epub:switch>. If <em>V</em> &#x2286; <em>U</em> is an open subset, it corresponds to an arrow in Open(<em>X</em>), and applying the functor <epub:switch id="mathmlSwitch1876"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">O</mi></math></epub:case><epub:default></epub:default></epub:switch> yields a function called the <em>restriction map from U to V</em> and denoted <epub:switch id="mathmlSwitch1877"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>&#x03C1;</mi><mrow><mi>V</mi><mo>,</mo><mi>U</mi></mrow></msub><mo>:</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>U</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>V</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Given <epub:switch id="mathmlSwitch1878"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>a</mi><mo>&#x2208;</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>U</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we may denote <em>&#x03C1;</em><sub><em>V</em>,<em>U</em></sub>(<em>a</em>) by <em>a</em>&#x007C;<em><sub>V</sub></em>; it is called <em>the restriction of a to V</em>.</p>
<p>The <em>category of presheaves on X</em> is simply Open(<em>X</em>)<sup>op</sup>&#x2013;<strong>Set</strong> (see Definition <a href="chapter005.html#Def_5-3-3-1">5.3.3.1</a>).</p>

<p class="noindent1-top-exe" id="Exe_7-2-3-3"><em>Exercise</em> 7.2.3.3.</p>
<p class="nl1-list">a. Find four overlapping open subsets that cover the square <em>X</em> &#x2254; [0, 3] &#x00D7; [0, 3] &#x2286; &#x211D;<sup>2</sup>. Write a label for each open set as well as a label for each overlap (two-fold, three-fold, etc.). You now have labeled <em>n</em> open sets. What is your <em>n</em>?</p>
<p class="nl1-list">b. Draw the preorder Open(<em>X</em>). For each of the <em>n</em> open sets, draw a dot with the appropriate label. Then draw an arrow from one dot to another when the first refers to an open subset of the second. This is Open(<em>X</em>).</p>
<p class="nl1-list">c. Make up and write formulas <em>R</em><sub>1</sub> : <em>X</em> &#x2192; &#x211D; and <em>R</em><sub>2</sub> : <em>X</em> &#x2192; &#x211D; with <em>R</em><sub>1</sub>(<em>x</em>) &#x2A7D; <em>R</em><sub>2</sub>(<em>x</em>) for all <em>x</em> &#x2208; <em>X</em>, expressing a range of temperatures <em>R</em><sub>1</sub>(<em>p</em>) &#x2A7D; <em>Temp</em>(<em>p</em>) &#x2A7D; <em>R</em><sub>2</sub>(<em>p</em>) that an imaginary experiment shows can exist at each point <em>p</em> in the square. What is the temperature range at <em>p</em> &#x003D; (2, 1) &#x2208; <em>X</em>?</p>
<p class="nl1-list">d. Make a presheaf <epub:switch id="mathmlSwitch1879"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo>:</mo><mtext>Open</mtext><msup><mrow><mo stretchy='false'>(</mo><mi>X</mi><mo stretchy='false'>)</mo></mrow><mrow><mtext>op</mtext></mrow></msup><mo>&#x2192;</mo><mi mathvariant="bold">Set</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> as follows. For each of your open sets, say, <em>A</em> &#x2208; Open(<em>X</em>), put</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1880"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>A</mi><mo stretchy='false'>)</mo><mo>&#x2254;</mo><mo>{</mo><mi mathvariant="italic">Temp</mi><mo>:</mo><mi>A</mi><mo>&#x2192;</mo><mi>&#x211D;</mi><mo>&#x007C;</mo><mo>&#x2200;</mo><mi>a</mi><mo>&#x2208;</mo><mi>A</mi><mo>,</mo><mo>&#x00A0;</mo><msub><mi>R</mi><mn>1</mn></msub><mo stretchy='false'>(</mo><mi>a</mi><mo stretchy='false'>)</mo><mo>&#x2A7D;</mo><mi mathvariant="italic">Temp</mi><mo stretchy='false'>(</mo><mi>a</mi><mo stretchy='false'>)</mo><mo>&#x2A7D;</mo><msub><mi>R</mi><mn>2</mn></msub><mo stretchy='false'>(</mo><mi>a</mi><mo stretchy='false'>)</mo><mo>}</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="nl1-list-para">Call one of your <em>n</em> open sets <em>A</em>. What is <epub:switch id="mathmlSwitch1881"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>A</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>? Then choose some <em>A</em>&#x2032; &#x2286; <em>A</em>; what is <epub:switch id="mathmlSwitch1882"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>A</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and what is the restriction map <epub:switch id="mathmlSwitch1883"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>&#x03C1;</mi><mrow><mi>A</mi><mo>&#x2032;</mo><mo>,</mo><mi>A</mi></mrow></msub><mo>:</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>A</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>A</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> in this case? Do you like the name &#x201C;value assignment throughout <em>A</em>&#x201D; for an element of <epub:switch id="mathmlSwitch1884"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>A</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>?</p>

<p class="space-break-top">Before moving to a definition of sheaves, we need to clarify the notion of covering. Suppose that <em>U</em> is a region and <em>V</em><sub>1</sub>, &#x2026;, <em>V<sub>n</sub></em> are subregions (i.e., for each 1 &#x2A7D; <em>i</em> &#x2A7D; <em>n</em>, we have <em>V<sub>i</sub></em> &#x2286; <em>U</em>). Then we say that the <em>V<sub>i</sub> collectively cover U</em> if every point in <em>U</em> is in <em>V<sub>i</sub></em> for some <em>i</em>. Another way to say this is that the natural function &#x2294;<sub><em>i</em></sub><em>V<sub>i</sub></em> &#x2192; <em>U</em> is surjective.</p>
<a id="p339"></a>
<p class="noindent1-top-exe" id="Exa_7-2-3-4"><em>Example</em> 7.2.3.4. Let <em>X</em> &#x003D; &#x211D; be the space of real numbers, and define the following open subsets: <em>U</em> &#x003D; (5, 10), <em>V</em><sub>1</sub> &#x003D; (5, 7), <em>V</em><sub>2</sub> &#x003D; (6, 9), <em>V</em><sub>3</sub> &#x003D; (8, 10).<sup><a id="endnote_ref_10" href="chapter007.html#endnote_10">10</a></sup> Then <em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>, <em>V</em><sub>3</sub> collectively cover of <em>U</em>. It has overlaps <em>V</em><sub>12</sub> &#x003D; <em>V</em><sub>1</sub> &#x2229; <em>V</em><sub>2</sub> &#x003D; (6, 7), <em>V</em><sub>13</sub> &#x003D; <em>V</em><sub>1</sub> &#x2229; <em>V</em><sub>3</sub> &#x003D; &#x00D8;, <em>V</em><sub>23</sub> &#x003D; <em>V</em><sub>2</sub> &#x2229; <em>V</em><sub>3</sub> = (8, 9).</p>
<p>Given a presheaf <epub:switch id="mathmlSwitch1885"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo>:</mo><mtext>Open</mtext><msup><mrow><mo stretchy='false'>(</mo><mi>X</mi><mo stretchy='false'>)</mo></mrow><mrow><mtext>op</mtext></mrow></msup><mo>&#x2192;</mo><mi mathvariant="bold">Set</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we have sets and functions as in the following diagram</p>

<p class="fig-img"><img src="images/Art_P322.jpg" alt="art"/></p>
<p>A presheaf <epub:switch id="mathmlSwitch1886"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">O</mi></math></epub:case><epub:default></epub:default></epub:switch> on <em>X</em> tells us what value assignments throughout <em>U</em> can exist for each <em>U</em>. Suppose we have a value assignment <epub:switch id="mathmlSwitch1887"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&#x2208;</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><msub><mi>V</mi><mn>1</mn></msub><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> throughout <em>V</em><sub>1</sub> and another value assignment <epub:switch id="mathmlSwitch1888"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>a</mi><mn>2</mn></msub><mo>&#x2208;</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><msub><mi>V</mi><mn>2</mn></msub><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> throughout <em>V</em><sub>2</sub>, and suppose they agree as value assignments throughout <em>V</em><sub>1</sub> &#x2229; <em>V</em><sub>2</sub>, i.e., <epub:switch id="mathmlSwitch1889"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mo>&#x007C;</mo><mrow><msub><mi>V</mi><mn>1</mn></msub><mo>&#x2229;</mo><msub><mi>V</mi><mn>2</mn></msub></mrow></msub><mo>=</mo><msub><mi>a</mi><mn>2</mn></msub><msub><mo>&#x007C;</mo><mrow><msub><mi>V</mi><mn>1</mn></msub><mo>&#x2229;</mo><msub><mi>V</mi><mn>2</mn></msub></mrow></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>. In this case we should have a unique value assignment <epub:switch id="mathmlSwitch1890"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>b</mi><mo>&#x2208;</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><msub><mi>V</mi><mn>1</mn></msub><mo>&#x222A;</mo><msub><mi>V</mi><mn>2</mn></msub><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> throughout <em>V</em><sub>1</sub> &#x222A; <em>V</em><sub>2</sub> that agrees on the <em>V</em><sub>1</sub> part with <em>a</em><sub>1</sub> and agrees on the <em>V</em><sub>2</sub> part with <em>a</em><sub>2</sub>; i.e., <epub:switch id="mathmlSwitch1891"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>b</mi><msub><mo>&#x007C;</mo><mrow><msub><mi>V</mi><mn>1</mn></msub></mrow></msub><mo>=</mo><msub><mi>a</mi><mn>1</mn></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch1892"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>b</mi><msub><mo>&#x007C;</mo><mrow><msub><mi>U</mi><mn>2</mn></msub></mrow></msub><mo>=</mo><msub><mi>a</mi><mn>2</mn></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>. The condition that such equations hold for every covering is the sheaf condition.</p>
<p>For example, the elements of <epub:switch id="mathmlSwitch1893"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>U</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> might be functions <em>h</em> : <em>U</em> &#x2192; &#x211D;, each of which we imagine as a curve defined on the interval <em>U</em> &#x003D; (5, 10). The sheaf condition says that if one is given a curve-snippet over (5, 7), a curve-snippet over (6, 9), and a curve snippet over (8, 10), and these all agree on overlap intervals (6, 7) and (8, 9), then they can be put together to form a curve over all of <em>U</em>.</p>
<p class="noindent1-top-def" id="Def_7-2-3-5"><strong>Definition 7.2.3.5</strong>. Let <em>X</em> be a topological space, let Open(<em>X</em>) be its partial order of open sets, and let <epub:switch id="mathmlSwitch1894"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo>:</mo><mtext>Open</mtext><msup><mrow><mo stretchy='false'>(</mo><mi>X</mi><mo stretchy='false'>)</mo></mrow><mrow><mtext>op</mtext></mrow></msup><mo>&#x2192;</mo><mi mathvariant="bold">Set</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> be a presheaf. Given an open set <em>U</em> &#x2286; <em>X</em> and a cover <em>V</em><sub>1</sub>, &#x2026;, <em>V<sub>n</sub></em> of <em>U</em>, the following condition is called the <em>sheaf condition</em> for that cover.</p>
<p class="para-hang"><strong>Sheaf condition</strong> Given a sequence <em>a</em><sub>1</sub>, &#x2026;, <em>a<sub>n</sub></em>, where each <epub:switch id="mathmlSwitch1895"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>&#x2208;</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><msub><mi>V</mi><mi>i</mi></msub><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a value assignment throughout <em>V<sub>i</sub></em>, suppose that for all <em>i</em>, <em>j</em>, we have <epub:switch id="mathmlSwitch1896"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>a</mi><mi>i</mi></msub><msub><mo>&#x007C;</mo><mrow><msub><mi>V</mi><mi>i</mi></msub><mo>&#x2229;</mo><msub><mi>V</mi><mi>j</mi></msub></mrow></msub><mo>=</mo><msub><mi>a</mi><mi>j</mi></msub><msub><mo>&#x007C;</mo><mrow><msub><mi>V</mi><mi>i</mi></msub><mo>&#x2229;</mo><msub><mi>V</mi><mi>j</mi></msub></mrow></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>; then there is a unique value assignment <epub:switch id="mathmlSwitch1897"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>b</mi><mo>&#x2208;</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>U</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> such that <epub:switch id="mathmlSwitch1898"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>b</mi><msub><mo>&#x007C;</mo><mrow><msub><mi>V</mi><mi>i</mi></msub></mrow></msub><mo>=</mo><msub><mi>a</mi><mi>i</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<a id="p340"></a>
<p class="noindent1-top1">The presheaf <epub:switch id="mathmlSwitch1899"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">O</mi></math></epub:case><epub:default></epub:default></epub:switch> is called a <em>sheaf</em> if it satisfies the sheaf condition for every cover.</p>
<p class="noindent1-top-rem" id="Rem_7-2-3-6"><em>Remark</em> 7.2.3.6. Application <a href="chapter007.html#App_7-2-3-1">7.2.3.1</a> said that sheaves help us patch together information from different sources. Even if different temperature-recording devices <em>T<sub>i</sub></em> and <em>T<sub>j</sub></em> registered different temperatures on an overlapping region <em>U<sub>i</sub></em> &#x2229; <em>U<sub>j</sub></em>, they could be patched together if given a consistent translation system between their results. What is actually needed is a set of isomorphisms</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1900"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>p</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>:</mo><msub><mi>T</mi><mi>i</mi></msub><msub><mo>&#x007C;</mo><mrow><msub><mi>U</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow></msub><mover><mo>&#x2192;</mo><mo>&#x2245;</mo></mover><msub><mi>T</mi><mi>j</mi></msub><msub><mo>&#x007C;</mo><mrow><msub><mi>U</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>

<p class="noindent">that translate between them, and that these <em>p</em><sub><em>i</em>,<em>j</em></sub>&#x2019;s act in concert with one another. This (when precisely defined) is called <em><span class="underline">descent data</span></em>. The way it interacts with the definition of sheaf given in Definitions <a href="chapter007.html#Def_7-2-3-2">7.2.3.2</a> and <a href="chapter007.html#Def_7-2-3-5">7.2.3.5</a> is buried in the restriction maps <em>&#x03C1;</em> for the overlaps as subsets <em>U</em><sub><em>i</em>,<em>j</em></sub> &#x2286; <em>U<sub>i</sub></em> and <em>U</em><sub><em>i</em>,<em>j</em></sub> &#x2286; <em>U<sub>j</sub></em> (see Grothendieck and Raynaud [18] for details).</p>
<p class="noindent1-top-app" id="App_7-2-3-7"><em>Application</em> 7.2.3.7. Consider outer space as a topological space <em>X</em>. Different amateur astronomers record observations of what they see in <em>X</em> on a given night. Let <em>C</em> &#x003D; [390, 700] denote the set of wavelengths in the visible light spectrum (written in nanometers). Given an open subset <em>U</em> &#x2286; <em>X</em>, let <epub:switch id="mathmlSwitch1901"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>U</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> denote the set of functions <em>U</em> &#x2192; <em>C</em>. The presheaf <epub:switch id="mathmlSwitch1902"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">O</mi></math></epub:case><epub:default></epub:default></epub:switch> satisfies the sheaf condition; this is the taken-for-granted fact that we can patch together different <span class="underline">observations of space</span>.</p>
<p><a href="chapter007.html#Fig_7-1">Figure 7.1</a> (see page 377) shows three views of the night sky. Given a telescope position to obtain the first view, one moves the telescope right and a little down to obtain the second, and one moves it down and left to obtain the third. These are value assignments <epub:switch id="mathmlSwitch1903"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&#x2208;</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><msub><mi>V</mi><mn>1</mn></msub><mo stretchy='false'>)</mo><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>&#x2208;</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><msub><mi>V</mi><mn>2</mn></msub><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and <epub:switch id="mathmlSwitch1904"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>a</mi><mn>3</mn></msub><mo>&#x2208;</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><msub><mi>V</mi><mn>3</mn></msub><mo stretchy='false'>)</mo><mo>,</mo></math></epub:case><epub:default></epub:default></epub:switch> throughout subsets <em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>, <em>V</em><sub>3</sub> &#x2286; <em>X</em> (respectively). These subsets <em>V</em><sub>1</sub>, <em>V</em><sub>2</sub>, <em>V</em><sub>3</sub> cover some (strangely shaped) subset <em>U</em> &#x2286; <em>X</em>. Because the restriction of <em>a</em><sub>1</sub> to <em>V</em><sub>1</sub> &#x2229; <em>V</em><sub>2</sub> is equal to the restriction of <em>a</em><sub>2</sub> to <em>V</em><sub>1</sub> &#x2229; <em>V</em><sub>2</sub>, and so on, the sheaf condition says that these three value assignments glue together to form a single value assignment throughout <em>U</em>, as shown in <a href="chapter007.html#Fig_7-2">Figure 7.2</a> (see page 378).</p>
<p class="noindent1-top-exe" id="Exe_7-2-3-8"><em>Exercise</em> 7.2.3.8.</p>
<p>Find an application of sheaves in your own domain of expertise.</p>
<p class="noindent1-top-app" id="App_7-2-3-9"><em>Application</em> 7.2.3.9. Suppose we have a sheaf for temperatures on earth. For every region <em>U</em>, we have a set of theoretically possible temperature assignments throughout <em>U</em>. For example, we may know that if it is warm in Texas, warm in Arkansas, and warm in Kansas, then it cannot be cold in Oklahoma. With such a sheaf <epub:switch id="mathmlSwitch1905"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">O</mi></math></epub:case><epub:default></epub:default></epub:switch> in hand, one can use facts about the temperature in one region <em>U</em> to predict the temperature in another region <em>V</em>.</p>
<a id="p341"></a>
<p>The mathematics is as follows. Suppose given regions <em>U</em>, <em>V</em> &#x2286; <em>X</em> and a subset <epub:switch id="mathmlSwitch1906"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo>&#x2286;</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>U</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> corresponding to what we know about the temperature assignment throughout <em>U</em>. We take the following fiber product:</p>
<p class="fig-img"><img src="images/Art_P323.jpg" alt="art"/></p>
<p class="noindent">The image of the top composite <epub:switch id="mathmlSwitch1907"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>im</mtext><mo stretchy='false'>(</mo><msup><mrow><mo stretchy='false'>(</mo><msub><mi>&#x03C1;</mi><mrow><mi>U</mi><mo>,</mo><mi>X</mi></mrow></msub><mo stretchy='false'>)</mo></mrow><mrow><mo>&#x2212;</mo><mn>1</mn></mrow></msup><mo stretchy='false'>(</mo><mi>A</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>V</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a subset of <epub:switch id="mathmlSwitch1908"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>V</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> telling us which temperature assignments are possible throughout <em>V</em>, given our knowledge <em>A</em> about the temperature throughout <em>U</em>.</p>
<p class="space-break">We can imagine the same type of prediction systems for other domains as well, such as the energy of various parts of a material.</p>
<p class="noindent1-top-exe" id="Exa_7-2-3-10"><em>Example</em> 7.2.3.10. Exercises <a href="chapter005.html#Exe_5-2-4-3">5.2.4.3</a> and <a href="chapter005.html#Exe_5-2-4-4">5.2.4.4</a> discussed the idea of laws being dictated or respected throughout a jurisdiction. If <em>X</em> is earth, to every jurisdiction <em>U</em> &#x2286; <em>X</em> we assign the set <epub:switch id="mathmlSwitch1909"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>U</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> of laws that are dictated to hold throughout <em>U</em>. Given a law on <em>U</em> and a law on <em>V</em>, we can see if they amount to the same law on <em>U</em> &#x2229; <em>V</em>. For example, on <em>U</em> a law might say, &#x201C;no hunting near rivers&#x201D; and on <em>V</em> a law might say, &#x201C;no hunting in public areas.&#x201D; It happens that on <em>U</em> &#x2229; <em>V</em> all public areas are near rivers, and vice versa, so the laws agree there. These laws patch together to form a single rule about hunting that is enforced throughout the union <em>U</em> &#x222A; <em>V</em>, respected by all jurisdictions within it.</p>
<section title="Sheaf of ologged concepts">
<h3 class="level3" id="lev_7-2-3-11"><strong>7.2.3.11&#160;&#160;&#160;Sheaf of ologged concepts</strong></h3>
<p class="noindent">Definition <a href="chapter007.html#Def_7-2-3-5">7.2.3.5</a> defines what should be called a sheaf of sets. We can discuss sheaves of groups or even sheaves of categories. Here is an application of the latter.</p>
<a id="p342"></a>
<p class="space-break">Recall the notion of simplicial complexes (see Section <a href="chapter003.html#lev_3-4-4-3">3.4.4.3</a>). They look like this:</p>
<p class="fig-img" id="eq_7-10"><img src="images/Art_P324.jpg" alt="art"/></p>
<p class="noindent">Given such a simplicial complex <em>X</em>, we can imagine each vertex <em>v</em> &#x2208; <em>X</em><sub>0</sub> as an entity with a worldview (e.g., a person) and each simplex as the common worldview shared by its vertices. To model this, we assign to each vertex <em>v</em> &#x2208; <em>X</em> an olog <epub:switch id="mathmlSwitch1910"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>v</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, corresponding to the worldview held by that entity, and to each simplex <em>u</em> &#x2208; <em>X<sub>n</sub></em>, we assign an olog <epub:switch id="mathmlSwitch1911"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>u</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> corresponding to a <em>common ground</em> worldview. Recall that <em>X</em> is a subset of &#x2119;(<em>X</em><sub>0</sub>); it is a preorder and its elements (the simplices) are ordered by inclusion. If <em>u</em>, <em>v</em> are simplices with <em>u</em> &#x2286; <em>v</em>, then we want a map of ologs (i.e., a schema morphism) <epub:switch id="mathmlSwitch1912"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>v</mi><mo stretchy='false'>)</mo></mrow><mo>&#x2192;</mo><mrow><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>u</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. In this way the model says that any idea shared among the people in <em>v</em> is shared among the people in <em>u</em>. Thus we have a functor <epub:switch id="mathmlSwitch1913"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo>:</mo><mi>X</mi><mo>&#x2192;</mo><mtext mathvariant="bold">Sch</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> (where we forget the distinction between ologs and databases for notational convenience).</p>
<p>To every simplicial complex (indeed every ordered set) one can associate a topological space; in fact, we have a functor <em>Alx</em> : <strong>PrO</strong> &#x2192; <strong>Top</strong>, called the <span class="underline">Alexandrov</span> functor. Applying <em>Alx</em>(<em>X</em><sup>op</sup>), we have a space denoted <epub:switch id="mathmlSwitch1914"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>X</mi></math></epub:case><epub:default></epub:default></epub:switch>. One can visualize <epub:switch id="mathmlSwitch1915"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>X</mi></math></epub:case><epub:default></epub:default></epub:switch> as <em>X</em>, but the open sets include unions of simplices. There is a unique sheaf of categories on <epub:switch id="mathmlSwitch1916"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>X</mi></math></epub:case><epub:default></epub:default></epub:switch> that behaves like <epub:switch id="mathmlSwitch1917"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">O</mi></math></epub:case><epub:default></epub:default></epub:switch> on simplices of <em>X</em>.</p>
<p class="noindent1-top-exe" id="Exa_7-2-3-12"><em>Example</em> 7.2.3.12. Imagine two groups of people <em>G</em><sub>1</sub> and <em>G</em><sub>2</sub> each making observations about the world. Suppose there is some overlap <em>H</em> &#x003D; <em>G</em><sub>1</sub> &#x2229; <em>G</em><sub>2</sub>. Then it may happen that there is a conversation including <em>G</em><sub>1</sub> and <em>G</em><sub>2</sub>, and both groups are talking about something (though using different words). <em>H</em> says, &#x201C;You guys are talking about the same things, <a id="p343"></a>you just use different words.&#x201D; In this case there is an observation being made throughout <em>G</em><sub>1</sub> &#x222A; <em>G</em><sub>2</sub> that agrees with both those on <em>G</em><sub>1</sub> and those on <em>G</em><sub>2</sub>.</p>
</section>
<section title="Time">
<h3 class="level3" id="lev_7-2-3-13"><strong>7.2.3.13&#160;&#160;&#160;Time</strong></h3>
<p class="noindent">One can use sheaves to model objects in time; Goguen [17] gave an approach to this. For an approach that more closely fits the flow of this book, let <epub:switch id="mathmlSwitch1918"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> be a database schema. The lifespan of information about the world is generally finite; that is, what was true yesterday is not always the case today. Thus we can associate to each interval <em>U</em> of time the information that we deem to hold throughout <em>U</em>. This is sometimes called the <em>valid time</em> of the data.</p>
<p>If data is valid throughout <em>U</em> and we have a subset <em>V</em> &#x2286; <em>U</em>, then of course it is valid throughout <em>V</em>. And the sheaf condition holds too. If some information is valid throughout <em>U</em>, and some other information is valid throughout <em>U</em>&#x2032;, and if these two things restrict to the same information on the overlap <em>U</em> &#x2229; <em>V</em>, then they can be glued together to form information that is valid throughout the union <em>U</em> &#x222A; <em>V</em>.</p>
<p>So we can model information change over time by using a sheaf of <epub:switch id="mathmlSwitch1919"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>-sets on the topological space &#x211D;. In other words, for every time interval, we give an <epub:switch id="mathmlSwitch1920"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>-instance whose information is valid throughout that time interval. Definition <a href="chapter007.html#Def_7-2-3-5">7.2.3.5</a> only defined sheaves with values in <strong>Set</strong>; we are now generalizing to sheaves in <epub:switch id="mathmlSwitch1921"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mi mathvariant="bold">Set</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Namely we consider functors Open(&#x211D;) &#x2192; <epub:switch id="mathmlSwitch1922"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mi mathvariant="bold">Set</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> satisfying the same sheaf condition.</p>
<p class="noindent1-top-exe" id="Exa_7-2-3-14"><em>Example</em> 7.2.3.14. Consider a hospital in which babies are born. In our scenario, mothers enter the hospital, babies are born, mothers and babies leave the hospital. Let <epub:switch id="mathmlSwitch1923"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> be the schema</p>
<p class="fig-img"><img src="images/Art_P325.jpg" alt="art"/></p>
<p class="noindent">Consider the eight-hour intervals</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1924"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mtable columnalign='left'><mtr><mtd><msub><mtext>Shift</mtext><mn>1</mn></msub><mo>&#x2254;</mo><mo stretchy='false'>(</mo><mtext>Jan</mtext><mo>&#x00A0;</mo><mn>1</mn><mo>,</mo><mo>&#x00A0;</mo><mn>00</mn><mo>:</mo><mn>00</mn><mo>&#x2212;</mo><mn>08</mn><mo>:</mo><mn>00</mn><mo stretchy='false'>)</mo><mo>,</mo></mtd></mtr><mtr><mtd><msub><mtext>Shift</mtext><mn>2</mn></msub><mo>&#x2254;</mo><mo stretchy='false'>(</mo><mtext>Jan</mtext><mo>&#x00A0;</mo><mn>1</mn><mo>,</mo><mo>&#x00A0;</mo><mn>04</mn><mo>:</mo><mn>00</mn><mo>&#x2212;</mo><mn>12</mn><mo>:</mo><mn>00</mn><mo stretchy='false'>)</mo><mo>,</mo></mtd></mtr><mtr><mtd><msub><mtext>Shift</mtext><mn>3</mn></msub><mo>&#x2254;</mo><mo stretchy='false'>(</mo><mtext>Jan</mtext><mo>&#x00A0;</mo><mn>1</mn><mo>,</mo><mo>&#x00A0;</mo><mn>08</mn><mo>:</mo><mn>00</mn><mo>&#x2212;</mo><mn>16</mn><mo>:</mo><mn>00</mn><mo stretchy='false'>)</mo><mo>.</mo></mtd></mtr></mtable></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">The nurses take shifts of eight hours, overlapping with their predecessors by four hours, and they record in the database only patients that were there <em>throughout</em> their shift or <a id="p344"></a>throughout any overlapping shift. Here is the schema:</p>
<p class="fig-img"><img src="images/Art_P326.jpg" alt="art"/></p>
<p>Whether or not this implementation of the sheaf semantics is most useful in practice is certainly debatable. But something like this could easily be useful as a semantics, i.e., a way of thinking about, the temporal nature of data.</p>
</section>
</section>
</section>
<section title="Monads">
<h1 class="level1" id="lev_7-3"><a href="toc.html#Rlev_7-3"><strong>7.3&#160;&#160;&#160;Monads</strong></a></h1>
<p class="noindent">Monads would probably not have been invented without category theory, but they have been useful in understanding algebraic theories, calculating invariants of topological spaces, and embedding nonfunctional operations into functional programming languages. We mainly discuss monads in terms of how they can help one make explicit a given modeling context and in so doing allow one to simplify the language used in such models. We use databases to give concrete examples.</p>
<p>Much of the following material on monads is taken from Spivak [40].</p>
<section title="Monads formalize context">
<h2 class="level2" id="lev_7-3-1"><strong>7.3.1&#160;&#160;&#160;Monads formalize context</strong></h2>
<p class="noindent">Monads can formalize assumptions about the way one does business throughout a domain. For example, suppose we want to consider functions that are not required to return a <a id="p345"></a>value for all inputs. These are not valid functions as defined in Section <a href="chapter002.html#lev_2-1-2">2.1.2</a> (because they are not <em>total</em>), but in math classes one wants to speak of <epub:switch id="mathmlSwitch1925"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy='false'>(</mo><mi>x</mi><mo stretchy='false'>)</mo><mo>=</mo><mfrac><mn>1</mn><mi>x</mi></mfrac></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <em>g</em>(<em>x</em>) &#x003D; tan(<em>x</em>) <em>as though</em> they were functions &#x211D; &#x2192; &#x211D;, so that they can be composed without constantly paying attention to domains.</p>
<p>Functions that are not required to be defined throughout their domain are called <em>partial functions</em>. We all know how they should work, so we need a way to make it mathematically legal. Monads, and the <em>Kleisli</em> categories to which they give rise, provide us with a way to do so. In particular, we will be able to formally discuss the composition <epub:switch id="mathmlSwitch1926"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x211D;</mi><mover><mo>&#x2192;</mo><mrow><mfrac><mn>1</mn><mi>x</mi></mfrac></mrow></mover><mi>&#x211D;</mi><mover><mo>&#x2192;</mo><mrow><mi>tan</mi><mo>&#x2061;</mo><mo stretchy='false'>(</mo><mi>x</mi><mo stretchy='false'>)</mo></mrow></mover><mi>&#x211D;</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p>Here we are drawing arrows between sets as though we were talking about total functions, but there is an implicit context in which we are actually talking about partial functions. Monads allow us to write maps between sets in the functional way while holding the underlying context. What makes them useful is that the notion of <em>context</em> we are using here is made formal.</p>
<p class="noindent1-top-exe" id="Exa_7-3-1-1"><em>Example</em> 7.3.1.1 (Partial functions). Partial functions can be modeled by ordinary functions if we add a special &#x201C;no answer&#x201D; element to the codomain. That is, the set of partial functions <em>A</em> &#x2192; <em>B</em> is in one-to-one correspondence with the set of ordinary functions <em>A</em> &#x2192; <em>B</em> &#x2294; {&#x263A;}. For example, suppose we want to model the partial function <epub:switch id="mathmlSwitch1927"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>f</mi><mi>p</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo stretchy='false'>)</mo><mo>&#x2254;</mo><mfrac><mn>1</mn><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>&#x2212;</mo><mn>1</mn></mrow></mfrac><mo>:</mo><mi>&#x211D;</mi><mo>&#x2192;</mo><mi>&#x211D;</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> in this way; we would use the total function <em>f<sub>t</sub></em> : &#x211D; &#x2192; &#x211D; &#x2294; {&#x263A;} defined as:</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1928"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy='false'>(</mo><mi>x</mi><mo stretchy='false'>)</mo><mo>&#x2254;</mo><mrow><mo>{</mo><mrow><mtable columnalign='left'><mtr columnalign='left'><mtd columnalign='left'><mrow><mfrac><mn>1</mn><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>&#x2212;</mo><mn>1</mn></mrow></mfrac></mrow></mtd><mtd columnalign='left'><mrow><mtext>if</mtext><mo>&#x00A0;</mo><mi>x</mi><mo>&#x2260;</mo><mo>&#x2212;</mo><mn>1</mn><mo>&#x00A0;</mo><mtext>and</mtext><mo>&#x00A0;</mo><mi>x</mi><mo>&#x2260;</mo><mn>1</mn><mo>,</mo></mrow></mtd></mtr><mtr columnalign='left'><mtd columnalign='left'><mrow><mo>&#x263A;</mo></mrow></mtd><mtd columnalign='left'><mrow><mtext>if</mtext><mo>&#x00A0;</mo><mi>x</mi><mo>=</mo><mo>&#x2212;</mo><mn>1</mn><mo>,</mo></mrow></mtd></mtr><mtr columnalign='left'><mtd columnalign='left'><mrow><mo>&#x263A;</mo></mrow></mtd><mtd columnalign='left'><mrow><mtext>if</mtext><mo>&#x00A0;</mo><mi>x</mi><mo>=</mo><mn>1.</mn></mrow></mtd></mtr></mtable></mrow></mrow></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">An ordinary function <em>g</em> : <em>A</em> &#x2192; <em>B</em> can be considered a partial function because we can compose it with the inclusion</p>
<p class="disp-equ" id="eq_7-11"><epub:switch id="mathmlSwitch1929"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mtable><mtr><mtd><mrow><mi>B</mi><mo>&#x2192;</mo><mi>B</mi><mo>&#x2294;</mo><mo>{</mo><mo>&#x263A;</mo><mo>}</mo><mo>.</mo></mrow></mtd><mtd><mo>(</mo><mn>7.11</mn><mo>)</mo></mtd></mtr></mtable></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">to get <em>A</em> &#x2192; <em>B</em> &#x2294; {&#x263A;}.</p>
<p>But how do we compose two partial functions written in this way? Suppose <em>f</em> : <em>A</em> &#x2192; <em>B</em> &#x2294; {&#x263A;} and <em>g</em> : <em>B</em> &#x2192; <em>C</em> &#x2294; {&#x263A;} are functions. First form a new function</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1930"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msup><mi>g</mi><mo>&#x2032;</mo></msup><mo>&#x2254;</mo><mi>g</mi><mo>&#x2294;</mo><mo stretchy="false">{</mo><mo>&#x263A;</mo><mo stretchy="false">}</mo><mo>:</mo><mi>B</mi><mo>&#x2294;</mo><mo stretchy="false">{</mo><mo>&#x263A;</mo><mo stretchy="false">}</mo><mo>&#x2192;</mo><mi>C</mi><mo>&#x2294;</mo><mo stretchy="false">{</mo><mo>&#x263A;</mo><mo stretchy="false">}</mo><mo>&#x2294;</mo><mo stretchy="false">{</mo><mo>&#x263A;</mo><mo stretchy="false">}</mo><mo>,</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">then compose to get (<em>g</em>&#x2032; &#x25CB; <em>f</em>) : <em>A</em> &#x2192; <em>C</em> &#x2294; {&#x263A;} &#x2294; {&#x263A;}, and finally send both &#x263A;&#x2019;s to the same element by composing with</p>
<p class="disp-equ" id="eq_7-12"><epub:switch id="mathmlSwitch1931"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mtable><mtr><mtd><mi>C</mi><mo>&#x2294;</mo><mo stretchy="false">{</mo><mo>&#x263A;</mo><mo stretchy="false">}</mo><mo>&#x2294;</mo><mo stretchy="false">{</mo><mo>&#x263A;</mo><mo stretchy="false">}</mo><mo>&#x2192;</mo><mi>C</mi><mo>&#x2294;</mo><mo stretchy="false">{</mo><mo>&#x263A;</mo><mo stretchy="false">}</mo><mo>.</mo></mtd><mtd><mo>(</mo><mn>7.12</mn><mo>)</mo></mtd></mtr></mtable></math></epub:case><epub:default></epub:default></epub:switch></p>
<a id="p346"></a>
<p>How should one think about composing partial functions <em>g</em> &#x25CB; <em>f</em>? Every element <em>a</em> &#x2208; <em>A</em> is sent by <em>f</em> either to an element <em>b</em> &#x2208; <em>B</em> or to &#x201C;no answer.&#x201D; If it has an answer <em>f</em>(<em>a</em>) &#x2208; <em>B</em>, then this again is sent by <em>g</em> either to an element <em>g</em>(<em>f</em>(<em>a</em>)) &#x2208; <em>C</em> or to &#x201C;no answer.&#x201D; We get a partial function <em>A</em> &#x2192; <em>C</em> by sending <em>a</em> to <em>g</em>(<em>f</em>(<em>a</em>)) if possible or to &#x201C;no answer&#x201D; if it gets stopped along the way.</p>
<p>This monad is sometimes called the <em>maybe monad</em> in computer science, because a partial function <em>f</em> : <em>A</em> &#x2192; <em>B</em> takes every element of <em>A</em> and may output just an element of <em>B</em> or may output nothing; more succinctly, it outputs a &#x201C;maybe <em>B</em>.&#x201D;</p>
<p class="noindent1-top-exe" id="Exe_7-3-1-2"><em>Exercise</em> 7.3.1.2.</p>
<p class="nl1-list">a. Let <em>f</em> : &#x2124; &#x2192; &#x2124; &#x2294; {&#x263A;} be the partial function given by <epub:switch id="mathmlSwitch1932"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>f</mi><mo stretchy='false'>(</mo><mi>n</mi><mo stretchy='false'>)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>&#x2212;</mo><mi>n</mi></mrow></mfrac></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Calculate the following: <em>f</em>(&#x2212;3), <em>f</em>(&#x2212;2), <em>f</em>(&#x2212;1), <em>f</em>(0), <em>f</em>(1), and <em>f</em>(2).</p>
<p class="nl1-list">b. Let <em>g</em> : &#x2124; &#x2192; &#x2124; &#x2294; {&#x263A;} be the partial function given by</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1933"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>g</mi><mo stretchy='false'>(</mo><mi>n</mi><mo stretchy='false'>)</mo><mo>=</mo><mrow><mo>{</mo><mrow><mtable columnalign="left"><mtr><mtd><mrow><msup><mi>n</mi><mn>2</mn></msup><mo>&#x2212;</mo><mn>3</mn></mrow></mtd><mtd><mrow><mtext>if</mtext><mo>&#x00A0;</mo><mi>n</mi><mo>&#x2A7E;</mo><mo>&#x2212;</mo><mn>1</mn><mo>,</mo></mrow></mtd></mtr><mtr><mtd><mrow><mo>&#x263A;</mo></mrow></mtd><mtd><mrow><mtext>if</mtext><mo>&#x00A0;</mo><mi>n</mi><mo>&#x003C;</mo><mo>&#x2212;</mo><mn>1</mn></mrow></mtd></mtr></mtable></mrow></mrow></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="nl1-list-para">Write <em>f</em> &#x25CB; <em>g</em>(<em>n</em>) for &#x2212;3 &#x2A7D; <em>n</em> &#x2A7D; 2.</p>
<p class="noindent1-top-app" id="App_7-3-1-3"><em>Application</em> 7.3.1.3. <span class="underline">Experiments are supposed to be performed objectively</span>, but suppose we imagine that changing the person who performs the experiment, say, in psychology, may change the outcome. Let <em>A</em> be the set of experimenters, let <em>X</em> be the parameter space for the experimental variables (e.g., <em>X</em> &#x003D; Age &#x00D7; Income), and let <em>Y</em> be the observation space (e.g., <em>Y</em> &#x003D; propensity for violence). We want to think of such an experiment as telling us about a function <em>f</em> : <em>X</em> &#x2192; <em>Y</em> (how age and income affect propensity for violence). However, we may want to make some of the context explicit by including information about who performed the experiment. That is, we are really finding a function <em>f</em> : <em>X</em> &#x00D7; <em>A</em> &#x2192; <em>Y</em>.</p>
<p>Given a set <em>P</em> of persons, the experimenter wants to know the age and income of each, i.e., a function <em>P</em> &#x2192; <em>X</em>. However, it may be the case that even ascertaining this basic information, which is achieved merely by asking each person these questions, is subject to which experimenter in <em>A</em> is doing the asking. Then we again want to consider the experimenter as part of the equation, replacing the function <em>P</em> &#x2192; <em>X</em> with a function <em>P</em> &#x00D7; <em>A</em> &#x2192; <em>X</em>. In such a case, we can use a monad to hide the fact that everything in sight is assumed to be influenced by <em>A</em>. In other words, we want to announce, once and for all, the modeling context&#x2014;that every observable is possibly influenced by the observer&#x2014;so that it can recede into the background.</p>
<a id="p347"></a>
<p>We return to this in Examples <a href="chapter007.html#Exa_7-3-2-6">7.3.2.6</a> and <a href="chapter007.html#Exa_7-3-3-4">7.3.3.4</a>.</p>
</section>
<section title="Definition and examples">
<h2 class="level2" id="lev_7-3-2"><strong>7.3.2&#160;&#160;&#160;Definition and examples</strong></h2>
<p class="noindent">What aspects of Example <a href="chapter007.html#Exa_7-3-1-1">7.3.1.1</a> are about monads, and what aspects are about partial functions in particular? Monads are structures involving a functor and a couple of natural transformations. Roughly speaking, the functor for partial functors was <em>B</em> &#x21A6; <em>B</em> &#x2294; {&#x263A;}, and the natural transformations were given in (<a href="chapter007.html#eq_7-11">7.11</a>) and (<a href="chapter007.html#eq_7-12">7.12</a>). This section gives the definition of monads and a few examples. We return to consider about how monads formalize context in Section <a href="chapter007.html#lev_7-3-3">7.3.3</a>.</p>
<p class="noindent1-top-def" id="Def_7-3-2-1"><strong>Definition 7.3.2.1</strong> (Monad). A <em>monad on</em> <strong>Set</strong> is defined as follows: One announces some constituents (A. functor, B. unit map, C. multiplication map) and shows that they conform to some laws (1. unit laws, 2. associativity law). Specifically, one announces</p>
<p class="nl1-list">A. a functor <em>T</em> : <strong>Set</strong> &#x2192; <strong>Set</strong>,</p>
<p class="nl1-list">B. a natural transformation <em>&#x03B7;</em> : id<strong><sub>Set</sub></strong> &#x2192; <em>T</em>,</p>
<p class="nl1-list">C. a natural transformation <em>&#x03BC;</em> : <em>T</em> &#x25CB; <em>T</em> &#x2192; <em>T</em>.</p>
<p class="noindent1-top1">We sometimes refer to the functor <em>T</em> as though it were the whole monad; we call <em>&#x03B7;</em> the <em>unit map</em> and <em>&#x03BC;</em> the <em>multiplication map</em>. One must then show that the following <em>monad laws</em> hold:</p>

<ol class="olnoindent">
<li>The following diagrams of functors <strong>Set</strong> &#x2192; <strong>Set</strong> commute:
<p class="fig-img"><img src="images/Art_P327.jpg" alt="art"/></p></li>
<li class="litop">The following diagram of functors <strong>Set</strong> &#x2192; <strong>Set</strong> commutes:
<p class="fig-img"><img src="images/Art_P328.jpg" alt="art"/></p></li>
</ol>
<a id="p348"></a>
<p class="noindent1-top-exe" id="Exa_7-3-2-2"><em>Example</em> 7.3.2.2 (List monad). We now go through Definition <a href="chapter007.html#Def_7-3-2-1">7.3.2.1</a> using the List monad. The first step is to give a functor List: <strong>Set</strong> &#x2192; <strong>Set</strong>, which was done in Example <a href="chapter005.html#Exa_5-1-2-20">5.1.2.20</a>. Recall that if <em>X</em> &#x003D; {<em>p</em>, <em>q</em>, <em>r</em>}, then List(<em>X</em>) includes the empty list [ ], singleton lists such as [<em>p</em>], and any other list of elements in <em>X</em> such as [<em>p</em>, <em>p</em>, <em>r</em>, <em>q</em>, <em>p</em>]. Given a function <em>f</em> : <em>X</em> &#x2192; <em>Y</em>, one obtains a function List(<em>f</em>) : List(<em>X</em>) &#x2192; List(<em>Y</em>) by entrywise application of <em>f</em>, as in Exercise <a href="chapter005.html#Exe_5-1-2-22">5.1.2.22</a>.</p>
<p>As a monad, the functor List comes with two natural transformations, a unit map <em>&#x03B7;</em> and a multiplication map <em>&#x03BC;</em>. Given a set <em>X</em>, the unit map <em>&#x03B7;<sub>X</sub></em> : <em>X</em> &#x2192; List(<em>X</em>) returns singleton lists as follows:</p>
<p class="fig-img"><img src="images/Art_P328a.jpg" alt="art"/></p>
<p class="noindent">Given a set <em>X</em>, the multiplication map <em>&#x03BC;<sub>X</sub></em> : List(List(<em>X</em>)) &#x2192; List(<em>X</em>) concatenates lists of lists as follows:</p>
<p class="fig-img"><img src="images/Art_P328b.jpg" alt="art"/></p>
<p class="noindent">The naturality of <em>&#x03B7;</em> and <em>&#x03BC;</em> means that these maps work appropriately well under entrywise application of a function <em>f</em> : <em>X</em> &#x2192; <em>Y</em>. Finally, the three monad laws from Definition <a href="chapter007.html#Def_7-3-2-1">7.3.2.1</a> can be exemplified as follows:</p>
<p class="fig-img"><img src="images/Art_P329.jpg" alt="art"/></p>
<a id="p349"></a>
<p class="fig-img"><img src="images/Art_P329a.jpg" alt="art"/></p>
<p class="noindent1-top-exe" id="Exe_7-3-2-3"><em>Exercise</em> 7.3.2.3.</p>
<p>Let &#x2119; : <strong>Set</strong> &#x2192; <strong>Set</strong> be the power-set functor, so that given a function <em>f</em> : <em>X</em> &#x2192; <em>Y</em>, the function &#x2119;(<em>f</em>) : &#x2119;(<em>X</em>) &#x2192; &#x2119;(<em>Y</em>) is given by taking images.</p>
<p class="nl1-list">a. Make sense of the statement, &#x201C;With <em>&#x03B7;</em> defined by singleton subsets and with <em>&#x03BC;</em> defined by union, <epub:switch id="mathmlSwitch1934"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>T</mi><mo>&#x2254;</mo><mo stretchy='false'>(</mo><mi>&#x2119;</mi><mo>,</mo><mi>&#x03B7;</mi><mo>,</mo><mi>&#x03BC;</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a monad.&#x201D;</p>
<p class="nl1-list">b. With <em>X</em> &#x003D; {<em>a</em>, <em>b</em>}, write the function <em>&#x03B7;<sub>X</sub></em> as a two-row, two-column table.</p>
<p class="nl1-list">c. With <em>X</em> &#x003D; {<em>a</em>, <em>b</em>}, write the function <em>&#x03BC;<sub>X</sub></em> as a sixteen-row, two-column table (you can stop after five rows if you fully understand it).</p>
<p class="nl1-list">d. Check that you believe the monad laws from Definition <a href="chapter007.html#Def_7-3-2-1">7.3.2.1</a>.</p>

<p class="noindent1-top-sol"><em>Solution</em> 7.3.2.3.</p>
<p class="nl1-list">a. The statement suggests that the components of <em>&#x03B7;</em> : id<strong><sub>Set</sub></strong> &#x2192; &#x2119; can be defined using the concept of singleton subsets and that the components of <em>&#x03BC;</em> : &#x2119; &#x25CB; &#x2119; &#x2192; &#x2119; can be defined using the concept of union. Given a set <em>X</em> &#x2208; Ob(<strong>Set</strong>), we need a function <em>&#x03B7;<sub>X</sub></em> : <em>X</em> &#x2192; &#x2119;(<em>X</em>), meaning that for every element <em>x</em> &#x2208; <em>X</em>, we need a subset of <em>X</em>. The statement suggests we send <em>x</em> to the singleton subset {<em>x</em>} &#x2286; <em>X</em>. The statement also suggests that we obtain <em>&#x03BC;<sub>X</sub></em> : &#x2119;(&#x2119;(<em>X</em>)) &#x2192; &#x2119;(<em>X</em>) by sending a set of subsets to their union. For example, if <em>X</em> &#x003D; {1, 2, 3, 4, 5}, then an element <em>T</em> &#x2208; &#x2119;(&#x2119;(<em>X</em>)) might look like {{1, 2}, &#x00D8;, {1, 3, 5}}; the union of these subsets is <em>&#x03BC;<sub>X</sub></em>(<em>T</em>) &#x003D; {1, 2, 3, 5}, a subset of <em>X</em>. It is not hard to check that the given <em>&#x03B7;</em> and <em>&#x03BC;</em> are natural transformations. The statement now asserts that the power-set functor &#x2119;, together with these natural transformations, forms a monad.</p>
<a id="p350"></a>
<p class="nl1-list">b.)</p>
<table>
<tbody>
<tr>
<td class="td1all" colspan="3"><p class="center"><em>&#x03B7;</em><sub><em>X</em></sub></p></td>
</tr>
<tr>
<td class="td1all"><p class="center"><em>X</em></p></td>
<td class="td1all"></td>
<td class="td1all"><p class="center">&#x2119;(<em>X</em>)</p></td>
</tr>
<tr>
<td class="td1all"><p class="center"><em>a</em></p></td>
<td class="td1all"></td>
<td class="td1all"><p class="center">{<em>a</em>}</p></td>
</tr>
<tr>
<td class="td1all"><p class="center"><em>b</em></p></td>
<td class="td1all"></td>
<td class="td1all"><p class="center">{<em>b</em>}</p></td>
</tr>
</tbody>
</table>
<p class="nl1-list">c.)</p>
<table>
<tbody>
<tr>
<td class="td1all" colspan="3"><p class="center"><em>&#x03BC;<sub>X</sub></em></p></td>
</tr>
<tr>
<td class="td1all">&#x2119;(&#x2119;(<em>X</em>))</td>
<td class="td1all"></td>
<td class="td1all"><p class="center">&#x2119;(<em>X</em>)</p></td>
</tr>
<tr>
<td class="td1all">&#x00D8;</td>
<td class="td1all"></td>
<td class="td1all"><p class="center">&#x00D8;</p></td>
</tr>
<tr>
<td class="td1all">{&#x00D8;}</td>
<td class="td1all"></td>
<td class="td1all"><p class="center">&#x00D8;</p></td>
</tr>
<tr>
<td class="td1all">{{<em>a</em>}}</td>
<td class="td1all"></td>
<td class="td1all"><p class="center">{<em>a</em>}</p></td>
</tr>
<tr>
<td class="td1all">{{<em>b</em>}}</td>
<td class="td1all"></td>
<td class="td1all"><p class="center">{<em>b</em>}</p></td>
</tr>
<tr>
<td class="td1all">{{<em>a</em>, <em>b</em>}}</td>
<td class="td1all"></td>
<td class="td1all"><p class="center">{<em>a</em>, <em>b</em>}</p></td>
</tr>
<tr>
<td class="td1all">{&#x00D8;, {<em>a</em>}}</td>
<td class="td1all"></td>
<td class="td1all"><p class="center">{<em>a</em>}</p></td>
</tr>
<tr>
<td class="td1all">{&#x00D8;, {<em>b</em>}}</td>
<td class="td1all"></td>
<td class="td1all"><p class="center">{<em>b</em>}</p></td>
</tr>
<tr>
<td class="td1all">{&#x00D8;, {<em>a</em>, <em>b</em>}}</td>
<td class="td1all"></td>
<td class="td1all"><p class="center">{<em>a</em>, <em>b</em>}</p></td>
</tr>
<tr>
<td class="td1all">{{<em>a</em>}, {<em>b</em>}}</td>
<td class="td1all"></td>
<td class="td1all"><p class="center">{<em>a</em>, <em>b</em>}</p></td>
</tr>
<tr>
<td class="td1all">{{<em>a,</em> {<em>a</em>, <em>b</em>}}}</td>
<td class="td1all"></td>
<td class="td1all"><p class="center">{<em>a</em>, <em>b</em>}</p></td>
</tr>
<tr>
<td class="td1all">{{<em>b</em>}, {<em>a</em>, <em>b</em>}}</td>
<td class="td1all"></td>
<td class="td1all"><p class="center">{<em>a</em>, <em>b</em>}</p></td>
</tr>
<tr>
<td class="td1all">{&#x00D8;, {<em>a</em>}, {<em>b</em>}}</td>
<td class="td1all"></td>
<td class="td1all"><p class="center">{<em>a</em>, <em>b</em>}</p></td>
</tr>
<tr>
<td class="td1all">{&#x00D8;, {<em>a</em>}, {<em>a</em>, <em>b</em>}}</td>
<td class="td1all"></td>
<td class="td1all"><p class="center">{<em>a</em>, <em>b</em>}</p></td>
</tr>
<tr>
<td class="td1all">{&#x00D8;, {<em>b</em>}, {<em>a</em>, <em>b</em>}}</td>
<td class="td1all"></td>
<td class="td1all"><p class="center">{<em>a</em>, <em>b</em>}</p></td>
</tr>
<tr>
<td class="td1all">{{<em>a</em>}, {<em>b</em>}, {<em>a</em>, <em>b</em>}}</td>
<td class="td1all"></td>
<td class="td1all"><p class="center">{<em>a</em>, <em>b</em>}</p></td>
</tr>
<tr>
<td class="td1all">{&#x00D8;, {<em>a</em>}, {<em>b</em>}, {<em>a</em>, <em>b</em>}}</td>
<td class="td1all"></td>
<td class="td1all"><p class="center">{<em>a</em>, <em>b</em>}</p></td>
</tr>
</tbody>
</table>
<p class="nl1-list">d. The monad laws hold. One says that if we take all the singleton subsets of <em>X</em> and union them, we get <em>X</em>. Another says that if we take the singleton set consisting of the whole set <em>X</em> and union it, we get <em>X</em>. The last says that the union of unions is a union.</p>
<p class="noindent1-top-exe" id="Exa_7-3-2-4"><em>Example</em> 7.3.2.4 (Partial functions as a monad). Here is the monad for partial functions, as discussed in Example <a href="chapter007.html#Exa_7-3-1-1">7.3.1.1</a>. The functor <em>T</em> : <strong>Set</strong> &#x2192; <strong>Set</strong> sends a set <em>X</em> to the set <em>X</em> &#x2294; {&#x263A;}. Clearly, given a function <em>f</em> : <em>X</em> &#x2192; <em>Y</em>, there is an induced function (<em>f</em> &#x2294; {&#x263A;}) : (<em>X</em> &#x2294; {&#x263A;}) &#x2192; (<em>Y</em> &#x2294; {&#x263A;}), so this is a functor. The natural transformation <em>&#x03B7;</em> : id &#x2192; <em>T</em> is given on a set <em>X</em> by the component function</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1935"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>&#x03B7;</mi><mi>X</mi></msub><mo>:</mo><mi>X</mi><mo>&#x2192;</mo><mi>X</mi><mo>&#x2294;</mo><mo stretchy="false">{</mo><mo>&#x263A;</mo><mo stretchy="false">}</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">that includes <em>X</em> &#x21AA; <em>X</em> &#x2294; {&#x263A;}. Finally, the natural transformation <em>&#x03BC;</em> : <em>T</em> &#x25CB; <em>T</em> &#x2192; <em>T</em> is given on a set <em>X</em> by the component function</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1936"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>&#x03BC;</mi><mi>X</mi></msub><mo>:</mo><mi>X</mi><mo>&#x2294;</mo><mo stretchy="false">{</mo><mo>&#x263A;</mo><mo stretchy="false">}</mo><mo>&#x2294;</mo><mo stretchy="false">{</mo><mo>&#x263A;</mo><mo stretchy="false">}</mo><mo>&#x2192;</mo><mi>X</mi><mo>&#x2294;</mo><mo stretchy="false">{</mo><mo>&#x263A;</mo><mo stretchy="false">}</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">that collapses both copies of &#x263A;.</p>
<p class="noindent1-top-exe" id="Exe_7-3-2-5"><em>Exercise</em> 7.3.2.5.</p>
<p>Let <em>E</em> be a set with elements refered to as <em>exceptions</em>. We imagine exceptions as warnings like &#x201C;overflow!&#x201D; or &#x201C;division by zero!&#x201D; and we imagine that a function <em>f</em> : <em>X</em> &#x2192; <em>Y</em> outputs either a value or one of these exceptions. Let <em>T</em> : <strong>Set</strong> &#x2192; <strong>Set</strong> be the functor <em>X</em> &#x21A6; <em>X</em> &#x2294; <em>E</em>. Follow Example <a href="chapter007.html#Exa_7-3-2-4">7.3.2.4</a> and find a unit map <em>&#x03B7;</em> and a multiplication map <em>&#x03BC;</em> for which (<em>T</em>, <em>&#x03B7;</em>, <em>&#x03BC;</em>) is a monad.</p>
<a id="p351"></a>
<p class="noindent1-top-exe" id="Exa_7-3-2-6"><em>Example</em> 7.3.2.6. Fix a set <em>A</em>. Let <em>T</em> : <strong>Set</strong> &#x2192; <strong>Set</strong> be the functor given by <em>T</em>(<em>X</em>) &#x003D; <em>X<sup>A</sup></em> &#x003D; Hom<strong><sub>Set</sub></strong>(<em>A</em>, <em>X</em>); this is a functor. For a set <em>X</em> and an element <em>x</em> &#x2208; <em>X</em>, let <em>c<sub>x</sub></em> : <em>A</em> &#x2192; <em>X</em> be the constant-<em>x</em> function, <em>c<sub>x</sub></em>(<em>a</em>) &#x003D; <em>x</em> for all <em>a</em> &#x2208; <em>A</em>. Define <em>&#x03B7;<sub>X</sub></em> : <em>X</em> &#x2192; <em>T</em>(<em>X</em>) to be given by the constant-<em>x</em> function, <em>x</em> &#x21A6; <em>c<sub>x</sub></em>.</p>
<p>Now we have to specify a natural transformation <em>&#x03BC;</em> : <em>T</em> &#x25CB; <em>T</em> &#x2192; <em>T</em>, i.e., for each <em>X</em> &#x2208; Ob(<strong>Set</strong>), we need to provide an <em>X</em>-component function</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1937"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>&#x03BC;</mi><mi>X</mi></msub><mo>:</mo><mrow><mo stretchy='false'>(</mo><msup><mi>X</mi><mi>A</mi></msup><msup><mo stretchy='false'>)</mo><mi>A</mi></msup></mrow><mo>&#x2192;</mo><msup><mi>X</mi><mi>A</mi></msup><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">By currying (see Example <a href="chapter007.html#Exa_7-1-1-8">7.1.1.8</a>), this is equivalent to providing a function (<em>X<sup>A</sup></em>)<em><sup>A</sup></em> &#x00D7; <em>A</em> &#x2192; <em>X</em>. For any <em>Y</em> &#x2208; Ob(<strong>Set</strong>), we have an evaluation function (see Exercise <a href="chapter003.html#Exe_3-4-2-5">3.4.2.5</a>) <em>ev</em> : <em>Y<sup>A</sup></em> &#x00D7; <em>A</em> &#x2192; <em>Y</em>. We use it twice and find the desired function:</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1938"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mrow><mo stretchy='false'>(</mo><msup><mi>X</mi><mi>A</mi></msup><msup><mo stretchy='false'>)</mo><mi>A</mi></msup></mrow><mo>&#x00D7;</mo><mi>A</mi><mover><mo>&#x2192;</mo><mrow><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mi>e</mi><mi>v</mi><mo>&#x00D7;</mo><msub><mrow><mtext>id</mtext></mrow><mi>A</mi></msub><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo></mrow></mover><msup><mi>X</mi><mi>A</mi></msup><mo>&#x00D7;</mo><mi>A</mi><mover><mo>&#x2192;</mo><mrow><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mi>e</mi><mi>v</mi><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo></mrow></mover><mi>X</mi><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent1-top-rem" id="Rem_7-3-2-7"><em>Remark</em> 7.3.2.7. Monads can be defined on categories other than <strong>Set</strong>. In fact, for any category <epub:switch id="mathmlSwitch1939"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, one can take Definition <a href="chapter007.html#Def_7-3-2-1">7.3.2.1</a> and replace every occurrence of <strong>Set</strong> with <epub:switch id="mathmlSwitch1940"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> and obtain the definition for monads on <epub:switch id="mathmlSwitch1941"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>. We have actually seen a monad (Paths, <em>&#x03B7;</em>, <em>&#x03BC;</em>) on the category <strong>Grph</strong> of graphs before, namely, in Examples <a href="chapter005.html#Exa_5-3-1-15">5.3.1.15</a> and <a href="chapter005.html#Exa_5-3-1-16">5.3.1.16</a>. That is, Paths: <strong>Grph</strong> &#x2192; <strong>Grph</strong>, which sends a graph to its paths-graph is the functor part. The unit map <em>&#x03B7;</em> includes a graph into its paths-graph using the observation that every arrow is a path of length 1. And the multiplication map <em>&#x03BC;</em> concatenates paths of paths. The Kleisli category of this monad (see Definition <a href="chapter007.html#Def_7-3-3-1">7.3.3.1</a>) is used, e.g., in (5.17), to define morphisms of database schemas.</p>
</section>
<section title="Kleisli category of a monad">
<h2 class="level2" id="lev_7-3-3"><strong>7.3.3&#160;&#160;&#160;Kleisli category of a monad</strong></h2>
<p class="noindent">We are on our way to understanding how monads are used in computer science and how they may be useful for formalizing methodological context. There is only one more stop along the way, called the Kleisli category of a monad. For example, when we apply this Kleisli construction to the partial functions monad (Example <a href="chapter007.html#Exa_7-3-2-4">7.3.2.4</a>), we obtain the category of partial functions (see Example <a href="chapter007.html#Exa_7-3-3-2">7.3.3.2</a>). When we apply the Kleisli construction to the monad <em>X</em> &#x21A6; <em>X<sup>A</sup></em> of Example <a href="chapter007.html#Exa_7-3-2-6">7.3.2.6</a> we get the psychological experiment example (Application <a href="chapter007.html#App_7-3-1-3">7.3.1.3</a>) completed in Example <a href="chapter007.html#Exa_7-3-3-4">7.3.3.4</a>.</p>
<p class="noindent1-top-def" id="Def_7-3-3-1"><strong>Definition 7.3.3.1</strong>. Let <epub:switch id="mathmlSwitch1942"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>T</mi><mo>=</mo><mo stretchy='false'>(</mo><mi>T</mi><mo>,</mo><mi>&#x03B7;</mi><mo>,</mo><mi>&#x03BC;</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be a monad on <strong>Set</strong>. Form a new category, called the <em>Kleisli category for</em> <epub:switch id="mathmlSwitch1943"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>T</mi></math></epub:case><epub:default></epub:default></epub:switch>, denoted <epub:switch id="mathmlSwitch1944"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, with sets as objects, <epub:switch id="mathmlSwitch1945"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mrow><mo>(</mo><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow><mo>)</mo></mrow><mo>&#x2254;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="bold">Set</mi><mo stretchy='false'>)</mo></math></epub:case><epub:default></epub:default></epub:switch>, and with</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1946"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Kls</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>T</mi><mo stretchy='false'>)</mo></mrow></msub><mo stretchy='false'>(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy='false'>)</mo><mo>&#x2254;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Set</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>X</mi><mo>,</mo><mi>T</mi><mo stretchy='false'>(</mo><mi>Y</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">for sets <em>X</em>, <em>Y</em>. The identity morphism id<em><sub>X</sub></em> : <em>X</em> &#x2192; <em>X</em> in <epub:switch id="mathmlSwitch1947"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is given by <em>&#x03B7;</em> : <em>X</em> &#x2192; <em>T</em>(<em>X</em>) in <strong>Set</strong>. The composition of morphisms <em>f</em> : <em>X</em> &#x2192; <em>Y</em> and <em>g</em> : <em>Y</em> &#x2192; <em>Z</em> in <epub:switch id="mathmlSwitch1948"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is given as <a id="p352"></a>follows. Writing them as functions, we have <em>f</em> : <em>X</em> &#x2192; <em>T</em>(<em>Y</em>) and <em>g</em> : <em>Y</em> &#x2192; <em>T</em>(<em>Z</em>). The first step is to apply the functor <em>T</em> to <em>g</em>, giving <em>T</em>(<em>g</em>) : <em>T</em>(<em>Y</em>) &#x2192; <em>T</em>(<em>T</em>(<em>Z</em>)). Then compose with <em>f</em> to get <em>T</em>(<em>g</em>) &#x25CB; <em>f</em> : <em>X</em> &#x2192; <em>T</em>(<em>T</em>(<em>Z</em>)). Finally, compose with <em>&#x03BC;<sub>Z</sub></em> : <em>T</em>(<em>T</em>(<em>Z</em>)) &#x2192; <em>T</em>(<em>Z</em>) to get the required function <em>X</em> &#x2192; <em>T</em>(<em>Z</em>):</p>
<p class="fig-img" id="eq_7-13"><img src="images/Art_P329b.jpg" alt="art"/></p>
<p class="noindent">The associativity of this composition formula follows from the associativity law for monads.</p>
<p class="noindent1-top-exe" id="Exa_7-3-3-2"><em>Example</em> 7.3.3.2. Recall the monad <epub:switch id="mathmlSwitch1949"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>T</mi></math></epub:case><epub:default></epub:default></epub:switch> for partial functions, <em>T</em>(<em>X</em>) &#x003D; <em>X</em> &#x2294; {&#x263A;}, from Example <a href="chapter007.html#Exa_7-3-2-4">7.3.2.4</a>. The Kleisli category <epub:switch id="mathmlSwitch1950"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> has sets as objects, but a morphism <em>f</em> : <em>X</em> &#x2192; <em>Y</em> means a function <em>X</em> &#x2192; <em>Y</em> &#x2294; {&#x263A;}, i.e., a partial function. Given another morphism  <em>g</em> : <em>Y</em> &#x2192; <em>Z</em>, the composition formula in <epub:switch id="mathmlSwitch1951"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> ensures that <em>g</em> &#x25CB; <em>f</em> : <em>X</em> &#x2192; <em>Z</em> has the appropriate behavior.</p>
<p>Note how this monad allows us to make explicit a context in which all functions are assumed partial and then hide this context from our notation.</p>
<p class="noindent1-top-rem" id="Rem_7-3-3-3"><em>Remark</em> 7.3.3.3. For any monad <epub:switch id="mathmlSwitch1952"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>T</mi><mo>=</mo><mo stretchy='false'>(</mo><mi>T</mi><mo>,</mo><mi>&#x03B7;</mi><mo>,</mo><mi>&#x03BC;</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> on <strong>Set</strong>, there is a functor <epub:switch id="mathmlSwitch1953"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>i</mi><mo>:</mo><mi mathvariant="bold">Set</mi><mo>&#x2192;</mo><mi mathvariant="bold">Kls</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>T</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, given as follows. On objects we have <epub:switch id="mathmlSwitch1954"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="bold">Kls</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>T</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>=</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="bold">Set</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, so take <em>i</em> &#x003D; id<sub>Ob(<strong>Set</strong>)</sub>. Given a morphism <em>f</em> : <em>X</em> &#x2192; <em>Y</em> in <strong>Set</strong>, we need a morphism <em>i</em>(<em>f</em>) : <em>X</em> &#x2192; <em>Y</em> in <epub:switch id="mathmlSwitch1955"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, i.e., a function <em>i</em>(<em>f</em>) : <em>X</em> &#x2192; <em>T</em>(<em>Y</em>). We assign <em>i</em>(<em>f</em>) to be the composite <epub:switch id="mathmlSwitch1956"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi><mover><mo>&#x2192;</mo><mi>f</mi></mover><mi>Y</mi><mover><mo>&#x2192;</mo><mi>&#x03B7;</mi></mover><mi>T</mi><mo stretchy='false'>(</mo><mi>Y</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. The functoriality of this mapping follows from the unit law for monads.</p>
<p class="noindent1-top-exe" id="Exa_7-3-3-4"><em>Example</em> 7.3.3.4. In this example we return to the setting laid out in Application <a href="chapter007.html#App_7-3-1-3">7.3.1.3</a>, where we had a set <em>A</em> of experimenters and assumed that the person doing the experiment might affect the outcome. We use the monad <epub:switch id="mathmlSwitch1957"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>T</mi><mo>=</mo><mo stretchy='false'>(</mo><mi>T</mi><mo>,</mo><mi>&#x03B7;</mi><mo>,</mo><mi>&#x03BC;</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> from Example <a href="chapter007.html#Exa_7-3-2-6">7.3.2.6</a> and hope that <epub:switch id="mathmlSwitch1958"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> will conform to the understanding of how to manage the effect of the experimenter on data.</p>
<p>The objects of <epub:switch id="mathmlSwitch1959"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> are ordinary sets, but a map <em>f</em> : <em>X</em> &#x2192; <em>Y</em> in <epub:switch id="mathmlSwitch1960"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a function <em>X</em> &#x2192; <em>Y<sup>A</sup></em>. By currying, this is the same as a function <em>X</em> &#x00D7; <em>A</em> &#x2192; <em>Y</em>, as desired. To compose <em>f</em> with <em>g</em> : <em>Y</em> &#x2192; <em>Z</em> in <epub:switch id="mathmlSwitch1961"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we follow the formula from (<a href="chapter007.html#eq_7-13">7.13</a>). It turns out to be equivalent to the following. We have a function <em>X</em> &#x00D7; <em>A</em> &#x2192; <em>Y</em> and a function <em>Y</em> &#x00D7; <em>A</em> &#x2192; <em>Z</em>. Multiplying by id<em><sub>A</sub></em>, we have a function <em>X</em> &#x00D7; <em>A</em> &#x2192; <em>Y</em> &#x00D7; <em>A</em>, and we can now compose to get <em>X</em> &#x00D7; <em>A</em> &#x2192; <em>Z</em>.</p>
<p>What does this say in terms of experimenters affecting data gathering? It says that if we work within <epub:switch id="mathmlSwitch1962"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, then we may assume that the experimenter is being taken into <a id="p353"></a>account; all proposed functions <em>X</em> &#x2192; <em>Y</em> are actually functions <em>A</em> &#x00D7; <em>X</em> &#x2192; <em>Y</em>. The natural way to compose these experiments is that we only consider the data from one experiment to feed into another if the experimenter is the same in both experiments.<sup><a id="endnote_ref_11" href="chapter007.html#endnote_11">11</a></sup></p>
<p class="noindent1-top-exe" id="Exe_7-3-3-5"><em>Exercise</em> 7.3.3.5.</p>
<p>Exercise <a href="chapter007.html#Exe_7-3-2-3">7.3.2.3</a> discussed the power-set monad <epub:switch id="mathmlSwitch1963"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>T</mi><mo>=</mo><mo stretchy='false'>(</mo><mi>&#x2119;</mi><mo>,</mo><mi>&#x03B7;</mi><mo>,</mo><mi>&#x03BC;</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="nl1-list">a. Can you find a way to relate the morphisms in <epub:switch id="mathmlSwitch1964"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> to relations? That is, given a morphism <em>f</em> : <em>A</em> &#x2192; <em>B</em> in <epub:switch id="mathmlSwitch1965"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, is there a natural way to associate to it a relation <em>R</em> &#x2286; <em>A</em> &#x00D7; <em>B</em>?</p>
<p class="nl1-list">b. How does the composition formula in <epub:switch id="mathmlSwitch1966"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> relate to the composition of relations given in Definition <a href="chapter003.html#Def_3-2-2-3">3.2.2.3</a>?<sup><a id="endnote_ref_12" href="chapter007.html#endnote_12">12</a></sup></p>

<p class="noindent1-top-sol"><em>Solution</em> 7.3.3.5.</p>
<p class="nl1-list">a. A morphism <em>A</em> &#x2192; <em>B</em> in <epub:switch id="mathmlSwitch1967"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a function <em>f</em> : <em>A</em> &#x2192; &#x2119;(<em>B</em>) in <strong>Set</strong>. From such a function we need to obtain a binary relation, i.e., a subset <em>R</em> &#x2286; <em>A</em> &#x00D7; <em>B</em>. Recall that for any set <em>X</em> (e.g., <em>X</em> &#x003D; <em>B</em> or <em>X</em> &#x003D; <em>A</em> &#x00D7; <em>B</em>), we can identify the subsets of <em>X</em> with the functions <em>X</em> &#x2192; &#x03A9; &#x003D; {<em>True</em>, <em>False</em>}, using the characteristic function as in Definition <a href="chapter003.html#Def_3-4-4-12">3.4.4.12</a>. In other words, we have a bijection</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1968"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x2119;</mi><mo stretchy='false'>(</mo><mi>X</mi><mo stretchy='false'>)</mo><mo>&#x2245;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Set</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>X</mi><mo>,</mo><mo>&#x03A9;</mo><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="nl1-list-para">By currying, we get an isomorphism</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1969"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtable><mtr><mtd columnalign="right"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Set</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>A</mi><mo>,</mo><mi>&#x2119;</mi><mo stretchy='false'>(</mo><mi>B</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo></mrow></mtd><mtd columnalign="left"><mrow><mo>&#x2245;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Set</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>A</mi><mo>,</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Set</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>B</mi><mo>,</mo><mo>&#x03A9;</mo><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo></mrow></mtd></mtr><mtr><mtd><mrow></mrow></mtd><mtd columnalign="left"><mrow><mo>&#x2245;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Set</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>A</mi><mo>&#x00D7;</mo><mi>B</mi><mo>,</mo><mo>&#x03A9;</mo><mo stretchy='false'>)</mo><mo>&#x2245;</mo><mi>&#x2119;</mi><mo stretchy='false'>(</mo><mi>A</mi><mo>&#x00D7;</mo><mi>B</mi><mo stretchy='false'>)</mo><mo>.</mo></mrow></mtd></mtr></mtable></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="nl1-list-para">In other words, we can identify the function <em>f</em> : <em>A</em> &#x2192; &#x2119;(<em>B</em>) with an element of &#x2119;(<em>A</em> &#x00D7; <em>B</em>), i.e., with a subset <em>R</em> &#x2286; <em>A</em> &#x00D7; <em>B</em>, i.e., with a relation.</p>
<p class="nl1-list-para">A more down-to-earth way to specify how <em>f</em> : <em>A</em> &#x2192; &#x2119;(<em>B</em>) gives rise to a binary relation <em>R</em> &#x2286; <em>A</em> &#x00D7; <em>B</em> is as follows. We ask, given (<em>a</em>, <em>b</em>) &#x2208; <em>A</em> &#x00D7; <em>B</em>, when is it in <em>R</em>? We see that <em>f</em>(<em>a</em>) &#x2208; &#x2119;(<em>B</em>) is a subset, so the answer is that we put (<em>a</em>, <em>b</em>) &#x2208; <em>R</em> if <em>b</em> &#x2208; <em>f</em>(<em>a</em>). This gives the desired relation.</p>
<a id="p354"></a>
<p class="nl1-list">b. It is the same.</p>
<p class="noindent1-top-exe" id="Exe_7-3-3-6"><em>Exercise</em> 7.3.3.6.</p>
<p>(Challenge) Let <epub:switch id="mathmlSwitch1970"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>T</mi><mo>=</mo><mo stretchy='false'>(</mo><mi>&#x2119;</mi><mo>,</mo><mi>&#x03B7;</mi><mo>,</mo><mi>&#x03BC;</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be the power-set monad. The category <epub:switch id="mathmlSwitch1971"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is closed under binary products, i.e., every pair of objects <epub:switch id="mathmlSwitch1972"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="bold">Kls</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>T</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> has a product in <epub:switch id="mathmlSwitch1973"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. What is the product of <em>A</em> &#x003D; {1, 2, 3} and <em>B</em> &#x003D; {<em>a</em>, <em>b</em>}, and what are the projections?</p>
<p class="noindent1-top-sol"><em>Solution</em> 7.3.3.6.</p>
<p>The product of <em>A</em> and <em>B</em> in <epub:switch id="mathmlSwitch1974"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is <em>A</em> &#x00D7; <em>B</em> &#x003D; {1, 2, 3, <em>a</em>, <em>b</em>}, which coincidentally would be their coproduct in <strong>Set</strong>. The projection maps are functions <epub:switch id="mathmlSwitch1975"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x2119;</mi><mo stretchy='false'>(</mo><mi>A</mi><mo stretchy='false'>)</mo><mover><mo>&#x2190;</mo><mrow><msub><mi>&#x03C0;</mi><mn>1</mn></msub></mrow></mover><mo stretchy="false">{</mo><mn>1</mn><mo>,</mo><mn>2</mn><mo>,</mo><mn>3</mn><mo>,</mo><mi>a</mi><mo>,</mo><mi>b</mi><mo stretchy="false">}</mo><mover><mo>&#x2192;</mo><mrow><msub><mi>&#x03C0;</mi><mn>2</mn></msub></mrow></mover><mi>&#x2119;</mi><mo stretchy='false'>(</mo><mi>B</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>; we use the obvious maps, e.g., <em>&#x03C0;</em><sub>1</sub>(3) &#x003D; {3} and <em>&#x03C0;</em><sub>1</sub>(<em>a</em>) &#x003D; &#x00D8;. The question did not ask for the universal property, but we specify it anyway. Given <em>f</em> : <em>X</em> &#x2192; &#x2119;(<em>A</em>) and <em>g</em> : <em>X</em> &#x2192; &#x2119;(<em>B</em>), we take &#x2329;<em>f</em>, <em>g</em>&#x232A;: <em>X</em> &#x2192; &#x2119;(<em>A</em> &#x2294; <em>B</em>} to be given by union.</p>

<p class="noindent1-top-exe" id="Exe_7-3-3-7"><em>Exercise</em> 7.3.3.7.</p>
<p>(Challenge.) Let <epub:switch id="mathmlSwitch1976"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>T</mi><mo>=</mo><mo stretchy='false'>(</mo><mi>&#x2119;</mi><mo>,</mo><mi>&#x03B7;</mi><mo>,</mo><mi>&#x03BC;</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be the power-set monad. The category <epub:switch id="mathmlSwitch1977"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is closed under binary coproducts, i.e., every pair of objects <epub:switch id="mathmlSwitch1978"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="bold">Kls</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>T</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> has a coproduct in <epub:switch id="mathmlSwitch1979"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. What is the coproduct of <em>A</em> &#x003D; {1, 2, 3} and <em>B</em> &#x003D; {<em>a</em>, <em>b</em>}?</p>
<p class="noindent1-top-exe" id="Exa_7-3-3-8"><em>Example</em> 7.3.3.8. Let <em>A</em> be any preorder. We speak of <em>A</em> throughout this example as though it were the linear order given by time; however, the mathematics works for any <em>A</em> &#x2208; Ob(<strong>PrO</strong>).</p>
<p>There is a monad <epub:switch id="mathmlSwitch1980"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>T</mi><mo>=</mo><mo stretchy='false'>(</mo><mi>T</mi><mo>,</mo><mi>&#x03B7;</mi><mo>,</mo><mi>&#x03BC;</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> that captures the idea that a function <em>f</em> : <em>X</em> &#x2192; <em>Y</em> occurs in the context of time in the following sense: The output of <em>f</em> is determined not only by the element <em>x</em> &#x2208; <em>X</em> on which it is applied but also by the time at which it was applied to <em>x</em>; and the output of <em>f</em> occurs at another time, which is not before the time of input.</p>
<p>The functor part of the monad is given on <em>Y</em> &#x2208; Ob(<strong>Set</strong>) by</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1981"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>T</mi><mo stretchy='false'>(</mo><mi>Y</mi><mo stretchy='false'>)</mo><mo>=</mo><mo>{</mo><mi>p</mi><mo>:</mo><mi>A</mi><mo>&#x2192;</mo><mi>A</mi><mo>&#x00D7;</mo><mi>Y</mi><mo>&#x007C;</mo><mo>&#x00A0;</mo><mtext>if</mtext><mo>&#x00A0;</mo><mi>p</mi><mo stretchy='false'>(</mo><mi>a</mi><mo stretchy='false'>)</mo><mo>=</mo><mo stretchy='false'>(</mo><mi>a</mi><mo>&#x2032;</mo><mo>,</mo><mi>y</mi><mo stretchy='false'>)</mo><mo>&#x00A0;</mo><mtext>then</mtext><mo>&#x00A0;</mo><mi>a</mi><mo>&#x2A7D;</mo><mi>a</mi><mo>&#x2032;</mo><mo>}</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">The unit <em>&#x03B7;<sub>Y</sub></em> : <em>Y</em> &#x2192; <em>T</em>(<em>Y</em>) sends <em>y</em> to the function <em>a</em> &#x21A6; (<em>a</em>, <em>y</em>). The multiplication map <em>&#x03BC;<sub>Y</sub></em> : <em>T</em>(<em>T</em>(<em>Y</em>)) &#x2192; <em>T</em>(<em>Y</em>) is as follows. Suppose given <em>p</em> : <em>A</em> &#x2192; <em>A</em> &#x00D7; <em>T</em>(<em>Y</em>) in <em>T</em>(<em>T</em>(<em>Y</em>)). Then <em>&#x03BC;<sub>Y</sub></em> (<em>p</em>) : <em>A</em> &#x2192; <em>A</em> &#x00D7; <em>Y</em> is given on <em>a</em> &#x2208; <em>A</em> as follows. Suppose <em>p</em>(<em>a</em>) &#x003D; (<em>a</em>&#x2032;, <em>p</em>&#x2032;), where <em>p</em>&#x2032; : <em>A</em> &#x2192; <em>A</em> &#x00D7; <em>Y</em>. Then we assign <em>&#x03BC;<sub>Y</sub></em> (<em>p</em>)(<em>a</em>) &#x003D; <em>p</em>&#x2032;(<em>a</em>&#x2032;) &#x2208; <em>A</em> &#x00D7; <em>Y</em>.</p>
<p>Given two sets <em>X</em>, <em>Y</em>, what is the meaning of a morphism <em>X</em> &#x2192; <em>Y</em> in the Kleisli category <epub:switch id="mathmlSwitch1982"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, i.e., a function <em>f</em> : <em>X</em> &#x2192; <em>T</em>(<em>Y</em>)? Note that <em>T</em>(<em>Y</em>) &#x2286; Hom<strong><sub>Set</sub></strong>(<em>A</em>, <em>A</em> &#x00D7; <em>Y</em>), <a id="p355"></a>and composing with <em>f</em>, we have a function <em>X</em> &#x2192; Hom<strong><sub>Set</sub></strong>(<em>A</em>, <em>A</em> &#x00D7; <em>Y</em>), which can be curried to a function <em>f</em> : <em>A</em> &#x00D7; <em>X</em> &#x2192; <em>A</em> &#x00D7; <em>Y</em>. So we have an isomorphism</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1983"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Kls</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>T</mi><mo stretchy='false'>)</mo></mrow></msub><mo stretchy='false'>(</mo><mi>X</mi><mo>,</mo><mi>Y</mi><mo stretchy='false'>)</mo><mo>&#x2245;</mo><mo stretchy="false">{</mo><mi>f</mi><mo>&#x2208;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Set</mtext></mrow></msub><mo stretchy='false'>(</mo><mi>A</mi><mo>&#x00D7;</mo><mi>X</mi><mo>,</mo><mi>A</mi><mo>&#x00D7;</mo><mi>Y</mi><mo stretchy='false'>)</mo><mo stretchy="false">&#x007C;</mo><mo>&#x00A0;</mo><mtext>if</mtext><mo>&#x00A0;</mo><mi>f</mi><mo stretchy='false'>(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy='false'>)</mo><mo>=</mo><mo stretchy='false'>(</mo><mi>a</mi><mo>&#x2032;</mo><mo>,</mo><mi>y</mi><mo stretchy='false'>)</mo><mo>&#x00A0;</mo><mtext>then</mtext><mo>&#x00A0;</mo><mi>a</mi><mo>&#x2A7D;</mo><mi>a</mi><mo>&#x2032;</mo><mo stretchy="false">}</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">The right-hand set could be characterized as time-sensitive functions <em>f</em> : <em>X</em> &#x2192; <em>Y</em> for which the output arrives after the input.</p>
<p class="noindent1-top-rem" id="Rem_7-3-3-9"><em>Remark</em> 7.3.3.9. One of the most important monads in computer science is the <em>state monad</em>. It is used when one wants to allow a program to mutate state variables (e.g., in the program</p>

<div class="pull-quote">
<p class="pq-noindent">if <em>x</em> &#x2A7D; 4, then <em>x</em> &#x2254; <em>x</em> &#x002B; 1 else Print &#x201C;done&#x201D;</p>
</div>
<p class="noindent"><em>x</em> is a state variable). The state monad is a special case of the monad discussed in Example <a href="chapter007.html#Exa_7-3-3-8">7.3.3.8</a>. Given any set <em>A</em>, the usual <em>state monad of type A</em> is obtained by giving <em>A</em> the indiscrete preorder (see Example <a href="chapter004.html#Exa_4-4-4-5">4.4.4.5</a>). More explicitly, it is a monad with functor part</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch1984"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi><mo>&#x21A6;</mo><msup><mrow><mo stretchy='false'>(</mo><mi>A</mi><mo>&#x00D7;</mo><mi>X</mi><mo stretchy='false'>)</mo></mrow><mi>A</mi></msup></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">(see Example <a href="chapter007.html#Exa_7-3-5-3">7.3.5.3</a>).</p>
<p class="noindent1-top-exe" id="Exa_7-3-3-10"><em>Example</em> 7.3.3.10. We reconsider <a href="chapter001.html#Fig_1-1">Figure 1.1</a> reproduced as <a href="chapter007.html#Fig_7-3">Figure 7.3</a>.</p>
<figure>
<img src="images/Art_P330.jpg" alt="art"/>
<figcaption id="Fig_7-3"><strong>Figure 7.3</strong> An olog whose arrows do not denote functions. It should be interpreted using a monad.</figcaption>
</figure>
<a id="p356"></a>
<p>It looks like an olog, and all ologs are database schemas (see Section <a href="chapter004.html#lev_4-5-2-15">4.5.2.15</a>). But how is &#x201C;analyzed by a person yields&#x201D; a function? For it to be a function, there must be only one hypothesis corresponding to a given observation. The very name of this arrow belies the fact that it is an invalid aspect in the sense of Section <a href="chapter002.html#lev_2-3-2-1">2.3.2.1</a>, because given an observation, there may be more than one hypothesis yielded, corresponding to which person is doing the observing. In fact, all the arrows in this figure correspond to some hidden context involving people: the prediction is dependent on who analyzes the hypothesis, the specification of an experiment is dependent on who is motivated to specify it, and experiments may result in different observations by different observers.</p>

<p>Without monads, the model of science proposed by this olog would be difficult to believe in. But by choosing a monad we can make explicit (and then hide from discourse) the implicit assumption that &#x201C;this is all dependent on which human is doing the science.&#x201D; The choice of monad is an additional modeling choice. Do we want to incorporate the partial order of time? Do we want the scientist to be modified by each function (i.e., the person is changed when analyzing an observation to yield a hypothesis)? These are all interesting possibilities.</p>
<p>One reasonable choice would be to use the state monad of type <em>A</em>, where <em>A</em> is the set of scientific models. This implies the following context. Every morphism <em>f</em> : <em>X</em> &#x2192; <em>Y</em> in the Kleisli category of this monad is really a morphism <em>f</em> : <em>X</em> &#x00D7; <em>A</em> &#x2192; <em>Y</em> &#x00D7; <em>A</em>; while ostensibly giving a map from <em>X</em> to <em>Y</em>, it is influenced by the scientific model under which it is performed, and its outcome yields a new scientific model.</p>
<p>Reading the olog in this context might look like this:</p>
<div class="pull-quote">
<p class="pq-noindent">A hypothesis (in the presence of a scientific model) analyzed by a person produces a prediction (in the presence of a scientific model), which motivates the specification of an experiment (in the presence of a scientific model), which when executed results in an observation (in the presence of a scientific model), which analyzed by a person yields a hypothesis (in the presence of a scientific model).</p>
</div>
<p>The parenthetical statements can be removed if we assume them to be always there, which can be done using the preceding monad.</p>
<section title="Relaxing functionality constraint for ologs">
<h3 class="level3" id="lev_7-3-3-11"><strong>7.3.3.11&#160;&#160;&#160;Relaxing functionality constraint for ologs</strong></h3>
<p class="noindent">Section <a href="chapter002.html#lev_2-3-2">2.3.2</a> said that every arrow in an olog has to be English-readable as a sentence, and it has to correspond to a function. For example, the arrow</p>
<p class="fig-img" id="eq_7-14"><img src="images/Art_P331.jpg" alt="art"/></p>
<a id="p357"></a>
<p class="noindent">makes for a readable sentence, but it does not correspond to a function because a person may have no children or more than one child. We call an olog in which every arrow corresponds to a function (the only option proposed so far in this book) a <em>functional olog</em>. Requiring that ologs be functional comes with advantages and disadvantages. The main advantage is that creating a functional olog requires more conceptual clarity, and this has benefits for the olog creator as well as for anyone to whom he tries to explain the situation. The main disadvantage is that creating a functional olog takes more time, and the olog takes up more space on the page.</p>
<p>In the context of the power-set monad (see Exercise <a href="chapter007.html#Exe_7-3-2-3">7.3.2.3</a>), a morphism <em>f</em> : <em>X</em> &#x2192; <em>Y</em> between sets <em>X</em> and <em>Y</em>, as objects in <strong>Kls</strong>(&#x2119;), becomes a binary relation on <em>X</em> and <em>Y</em> rather than a function (see Exercise <a href="chapter007.html#Exe_7-3-3-5">7.3.3.5</a>). So in that context, the arrow in (<a href="chapter007.html#eq_7-14">7.14</a>) becomes valid. An olog in which arrows correspond to mere binary relations rather than functions might be called a <em>relational olog</em>.</p>
</section>
</section>
<section title="Monads in databases">
<h2 class="level2" id="lev_7-3-4"><strong>7.3.4&#160;&#160;&#160;Monads in databases</strong></h2>
<p class="noindent">This section discusses how to record data in the presence of a monad. The idea is quite simple. Given a schema (category) <epub:switch id="mathmlSwitch1985"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, an ordinary instance is a functor <epub:switch id="mathmlSwitch1986"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant="bold">Set</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>. But if <epub:switch id="mathmlSwitch1987"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>T</mi><mo>=</mo><mo stretchy='false'>(</mo><mi>T</mi><mo>,</mo><mi>&#x03B7;</mi><mo>,</mo><mi>&#x03BC;</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is a monad, then a <em>Kleisli</em> <epub:switch id="mathmlSwitch1988"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>T</mi></math></epub:case><epub:default></epub:default></epub:switch>-<em>instance on</em> <epub:switch id="mathmlSwitch1989"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> is a functor <epub:switch id="mathmlSwitch1990"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>J</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant="bold">Kls</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>T</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Such a functor associates to every object <epub:switch id="mathmlSwitch1991"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> a set <em>J</em>(<em>c</em>), and to every arrow <em>f</em> : <em>c</em> &#x2192; <em>c</em>&#x2032; in <epub:switch id="mathmlSwitch1992"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> a morphism <em>J</em>(<em>f</em>) : <em>J</em>(<em>c</em>) &#x2192; <em>J</em>(<em>c</em>&#x2032;) in <epub:switch id="mathmlSwitch1993"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. How does this look in terms of tables?</p>
<p class="space-break">Recall that to represent an ordinary database instance <epub:switch id="mathmlSwitch1994"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant="bold">Set</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we use a tabular format in which every object <epub:switch id="mathmlSwitch1995"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is displayed as a table including one ID column and one additional column for each arrow <em>f</em> : <em>c</em> &#x2192; <em>c</em>&#x2032; emanating from <em>c</em>. The cells in the ID column of table <em>c</em> contain the elements of the set <em>I</em>(<em>c</em>), and the cells in the <em>f</em> column contain elements of the set <em>I</em>(<em>c</em>&#x2032;).</p>
<p class="space-break">To represent a <em>Kleisli</em> database instance <epub:switch id="mathmlSwitch1996"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>J</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant="bold">Kls</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>T</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is similar; we again use a tabular format in which every object <epub:switch id="mathmlSwitch1997"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is displayed as a table including one ID column and one additional column for each arrow <em>f</em> : <em>c</em> &#x2192; <em>c</em>&#x2032; emanating from <em>c</em>. The cells in the ID column of table <em>c</em> again contain the elements of the set <em>J</em>(<em>c</em>); however the cells in the <em>f</em> column do not contain elements of <em>J</em>(<em>c</em>&#x2032;), but <em>T</em>-values in <em>J</em>(<em>c</em>&#x2032;), i.e., elements of <em>T</em>(<em>J</em>(<em>c</em>&#x2032;)).</p>
<p class="noindent1-top-exe" id="Exa_7-3-4-1"><em>Example</em> 7.3.4.1. Let <epub:switch id="mathmlSwitch1998"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>T</mi><mo>=</mo><mo stretchy='false'>(</mo><mi>T</mi><mo>,</mo><mi>&#x03B7;</mi><mo>,</mo><mi>&#x03BC;</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be the monad for partial functions (see Example <a href="chapter007.html#Exa_7-3-1-1">7.3.1.1</a>). Given any schema <epub:switch id="mathmlSwitch1999"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, we can represent a Kleisli <epub:switch id="mathmlSwitch2000"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>T</mi></math></epub:case><epub:default></epub:default></epub:switch>-instance <epub:switch id="mathmlSwitch2001"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant="bold">Kls</mi><mo stretchy='false'>(</mo><mi mathvariant='script'>T</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> in tabular format. For every object <epub:switch id="mathmlSwitch2002"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> we have a set <em>I</em>(<em>c</em>) of rows, and given a column <em>f</em> : <em>c</em> &#x2192; <em>c</em>&#x2032;, applying <em>f</em> to a row either produces a value in <em>I</em>(<em>c</em>&#x2032;) or fails to produce a value; this is the essence of partial functions. We might denote the absence of a value using &#x263A;.</p>
<a id="p358"></a>
<p class="space-break">Consider the schema indexing graphs</p>
<p class="fig-img"><img src="images/Art_P332.jpg" alt="art"/></p>

<p class="noindent">As discussed in Section <a href="chapter005.html#lev_5-2-1-21">5.2.1.21</a>, an ordinary instance on <epub:switch id="mathmlSwitch2003"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> represents a graph:</p>
<p class="fig-img"><img src="images/Art_P333.jpg" alt="art"/></p>
<p class="noindent">A Kleisli <epub:switch id="mathmlSwitch2004"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>T</mi></math></epub:case><epub:default></epub:default></epub:switch>-instance on <epub:switch id="mathmlSwitch2005"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> represents graphs in which edges can fail to have a source vertex, fail to have a target vertex, or both:</p>
<p class="fig-img"><img src="images/Art_P334.jpg" alt="art"/></p>
<p class="noindent">The context of these tables is that of partial functions, so we do not need a reference for &#x263A; in the vertex table. Mathematically, the morphism <em>J</em>(<em>src</em>) : <em>J</em>(<span class="fontA">Arrow</span>) &#x2192; <em>J</em>(<span class="fontA">Vertex</span>) in <epub:switch id="mathmlSwitch2006"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Kls</mtext><mo>(</mo><mi mathvariant='script'>T</mi><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> needs to be a function <em>J</em>(<span class="fontA">Arrow</span>) &#x2192; <em>J</em>(<span class="fontA">Vertex</span>) &#x2294; {&#x263A;}, and it is.</p>
<section title="Probability distributions">
<h3 class="level3" id="lev_7-3-4-2"><strong>7.3.4.2&#160;&#160;&#160;Probability distributions</strong></h3>
<p class="noindent">Let [0, 1] &#x2286; &#x211D; denote the set of real numbers between 0 and 1. Let <em>X</em> be a set and <em>p</em> : <em>X</em> &#x2192; [0, 1] a function. We say that <em>p</em> is a <em>finitary probability distribution on X</em> if there exists a finite subset <em>W</em> &#x2286; <em>X</em> such that</p>
<p class="disp-equ-no" id="eq_7-15"><epub:switch id="mathmlSwitch2007"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mtable><mtr><mtd><mrow><mstyle displaystyle='true'><munder><mo>&#x2211;</mo><mrow><mi>w</mi><mo>&#x2208;</mo><mi>W</mi></mrow></munder><mrow><mi>p</mi><mo stretchy='false'>(</mo><mi>w</mi><mo stretchy='false'>)</mo><mo>=</mo><mn>1</mn></mrow></mstyle><mo>,</mo></mrow></mtd><mtd><mo>(</mo><mn>7.15</mn><mo>)</mo></mtd></mtr></mtable></math></epub:case><epub:default></epub:default></epub:switch></p>
<a id="p359"></a>
<p class="noindent">and such that <em>p</em>(<em>x</em>) &#x003E; 0 if and only if <em>x</em> &#x2208; <em>W</em>. Note that the subset <em>W</em> is unique if it exists; we call it <em>the support of p</em> and denote it <strong>Supp</strong>(<em>p</em>).</p>
<p>For any set <em>X</em>, let <strong>Dist</strong>(<em>X</em>) denote the set of finitary probability distributions on <em>X</em>. It is easy to check that given a function <em>f</em> : <em>X</em> &#x2192; <em>Y</em>, one obtains a function <strong>Dist</strong>(<em>f</em>) : <strong>Dist</strong>(<em>X</em>) &#x2192; <strong>Dist</strong>(<em>Y</em>) by <strong>Dist</strong>(<em>f</em>)(<em>y</em>) &#x003D; &#x03A3;<sub><em>f</em>(<em>x</em>)&#x003D;<em>y</em></sub><em>p</em>(<em>x</em>). Thus we can consider <strong>Dist</strong> : <strong>Set</strong> &#x2192; <strong>Set</strong> as a functor, and in fact the functor part of a monad. Its unit <em>&#x03B7;</em> : <em>X</em> &#x2192; <strong>Dist</strong>(<em>X</em>) is given by the Kronecker delta function <em>x</em> &#x21A6; <em>&#x03B4;<sub>x</sub></em>, where <em>&#x03B4;<sub>x</sub></em>(<em>x</em>) &#x003D; 1 and <em>&#x03B4;<sub>x</sub></em>(<em>x</em>&#x2032;) &#x003D; 0 for <em>x</em>&#x2032; &#x2260; <em>x</em>. Its multiplication <em>&#x03BC;</em> : <strong>Dist</strong>(<strong>Dist</strong>(<em>X</em>)) &#x2192; <strong>Dist</strong>(<em>X</em>) is given by weighted sum: given a finitary probability distribution <em>w</em> : <strong>Dist</strong>(<em>X</em>) &#x2192; [0, 1] and <em>x</em> &#x2208; <em>X</em>, put <em>&#x03BC;</em>(<em>w</em>)(<em>x</em>) &#x003D; &#x03A3;<sub><em>p</em>&#x2208;<strong>Supp</strong>(<em>w</em>)</sub> <em>w</em>(<em>p</em>)<em>p</em>(<em>x</em>).</p>
<p class="noindent1-top-exe" id="Exa_7-3-4-3"><em>Example</em> 7.3.4.3 (Markov chains). Let <epub:switch id="mathmlSwitch2008"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> be the loop schema</p>
<p class="fig-img"><img src="images/Art_P335.jpg" alt="art"/></p>
<p class="noindent">as in Example <a href="chapter004.html#Exa_4-5-2-10">4.5.2.10</a>. A <strong>Dist</strong>-instance on <epub:switch id="mathmlSwitch2009"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> is equivalent to a time-homogeneous Markov chain. To be explicit, a functor <em>&#x03B4;</em> : <epub:switch id="mathmlSwitch2010"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> &#x2192; <strong>Kls</strong>(<strong>Dist</strong>) assigns to the unique object <em>s</em> &#x2208; Ob(<epub:switch id="mathmlSwitch2011"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">L</mi><mtext mathvariant="italic">oop</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>) a set <em>S</em> &#x003D; <em>&#x03B4;</em>(<em>s</em>), called the state space, and to <em>f</em> : <em>s</em> &#x2192; <em>s</em> a function <em>&#x03B4;</em>(<em>f</em>) : <em>S</em> &#x2192; <strong>Dist</strong>(<em>S</em>), which sends each element <em>x</em> &#x2208; <em>S</em> to some probability distribution on elements of <em>S</em>. For example, the left-hand table <em>&#x03B4;</em> (having states <em>&#x03B4;</em>(<em>s</em>) &#x003D; {<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>}) corresponds to the right-hand Markov matrix <em>M</em>:</p>
<p class="fig-img" id="eq_7-16"><img src="images/Art_P336.jpg" alt="art"/></p>
<p>As one might hope, for any natural number <em>n</em> &#x2208; &#x2115;, the map <em>f<sup>n</sup></em> : <em>S</em> &#x2192; <em>S</em> in <strong>Kls</strong>(<strong>Dist</strong>) corresponds to the matrix <em>M<sup>n</sup></em>, which sends an element <em>s</em> &#x2208; <em>S</em> to its probable location after <em>n</em> iterations of the transition map, <em>f<sup>n</sup></em>(<em>s</em>) &#x2208; <strong>Dist</strong>(<em>S</em>).</p>
<p class="noindent1-top-app" id="App_7-3-4-4"><em>Application</em> 7.3.4.4. Every star <span class="underline">emits a spectrum of light</span>, which can be understood as a distribution on the electromagnetic spectrum. Given an object <em>B</em> on earth, different parts of <em>B</em> will <span class="underline">absorb radiation</span> at different rates. Thus <em>B</em> produces a function from the electromagnetic spectrum to distributions of energy absorption. In the context of the probability distributions monad, we can record data on the schema</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch2012"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mover><mo>&#x2022;</mo><mrow><mtext mathvariant="bold">star</mtext></mrow></mover><mover><mo>&#x2192;</mo><mrow><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mtext>emits</mtext><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo></mrow></mover><mover><mo>&#x2022;</mo><mrow><mtext mathvariant="bold">wavelengths</mtext></mrow></mover><mover><mo>&#x2192;</mo><mrow><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mtext>absorbed</mtext><mo>&#x00A0;</mo><mtext>by</mtext><mo>&#x00A0;</mo><mi>B</mi><mo>&#x00A0;</mo><mo>&#x00A0;</mo></mrow></mover><mover><mo>&#x2022;</mo><mrow><mtext mathvariant="bold">energies</mtext></mrow></mover></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<a id="p360"></a>
<p class="noindent">The composition formula for Kleisli categories is the desired one: to each star we associate the weighted sum of energy absorption rates over the set of wavelengths emitted by the star.</p>

</section>
</section>
<section title="Monads and adjunctions">
<h2 class="level2" id="lev_7-3-5"><strong>7.3.5&#160;&#160;&#160;Monads and adjunctions</strong></h2>
<p class="noindent">There is a strong connection between monads and adjunctions: every adjunction creates a monad, and every monad comes from an adjunction. For example, the List monad (Example <a href="chapter007.html#Exa_7-3-2-2">7.3.2.2</a>) comes from the free forgetful adjunction between sets and monoids</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch2013"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Set</mtext><munderover><mo>&#x21C4;</mo><mi>U</mi><mi>F</mi></munderover><mtext mathvariant="bold">Mon</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">(see Proposition <a href="chapter007.html#Pro_7-1-1-2">7.1.1.2</a>). That is, for any set <em>X</em>, the free monoid on <em>X</em> is</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch2014"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo stretchy='false'>(</mo><mi>X</mi><mo stretchy='false'>)</mo><mo>=</mo><mo stretchy='false'>(</mo><mtext>List</mtext><mo stretchy='false'>(</mo><mi>X</mi><mo stretchy='false'>)</mo><mo>,</mo><mo stretchy='false'>[</mo><mo stretchy='false'>]</mo><mo>,</mo><mo>++</mo><mo stretchy='false'>)</mo><mo>,</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">and the underlying set of that monoid is <em>U</em>(<em>F</em>(<em>X</em>)) &#x003D; List(<em>X</em>). So the List functor is given by <em>U</em> &#x25CB; <em>F</em> : <strong>Set</strong> &#x2192; <strong>Set</strong>. But a monad is more than a functor; it includes a unit map <em>&#x03B7;</em> and a multiplication map <em>&#x03BC;</em> (see Definition <a href="chapter007.html#Def_7-3-2-1">7.3.2.1</a>). Luckily, the unit <em>&#x03B7;</em> and multiplication <em>&#x03BC;</em> drop out of the adjunction too. First, we discuss the unit and counit of an adjunction.</p>
<p class="noindent1-top-def" id="Def_7-3-5-1"><strong>Definition 7.3.5.1</strong>. Let <epub:switch id="mathmlSwitch2015"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch2016"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>D</mi></math></epub:case><epub:default></epub:default></epub:switch> be categories, and let <epub:switch id="mathmlSwitch2017"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>L</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch2018"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>R</mi><mo>:</mo><mi mathvariant='script'>D</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> be functors with adjunction isomorphism</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch2019"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>&#x03B1;</mi><mrow><mi>c</mi><mo>,</mo><mi>d</mi></mrow></msub><mo>:</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>D</mi></msub><mo stretchy='false'>(</mo><mi>L</mi><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo><mo>,</mo><mi>d</mi><mo stretchy='false'>)</mo><mover><mo>&#x2192;</mo><mrow><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mo>&#x2245;</mo><mo>&#x00A0;</mo><mo>&#x00A0;</mo></mrow></mover><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><mi>c</mi><mo>,</mo><mi>R</mi><mo stretchy='false'>(</mo><mi>d</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">for any objects <epub:switch id="mathmlSwitch2020"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch2021"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>d</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> (see Definition <a href="chapter007.html#Def_7-1-1-1">7.1.1.1</a>). The <em>unit</em> <epub:switch id="mathmlSwitch2022"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x03B7;</mi><mo>:</mo><msub><mrow><mtext>id</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo>&#x2192;</mo><mi>R</mi><mo>&#x25CB;</mo><mi>L</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> (resp. the <em>counit</em> <epub:switch id="mathmlSwitch2023"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo mathvariant="italic">&#x03F5;</mo><mo>:</mo><mi>L</mi><mo>&#x25CB;</mo><mi>R</mi><mo>&#x2192;</mo><msub><mrow><mtext>id</mtext></mrow><mi mathvariant='script'>D</mi></msub></math></epub:case><epub:default></epub:default></epub:switch>) of the adjunction is a natural transformation defined as follows.</p>
<p>Given an object <epub:switch id="mathmlSwitch2024"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>c</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we apply <em>&#x03B1;</em> to id<sub><em>L</em>(<em>c</em>)</sub> : <em>L</em>(<em>c</em>) &#x2192; <em>L</em>(<em>c</em>) to get the <em>c</em> component</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch2025"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>&#x03B7;</mi><mi>c</mi></msub><mo>:</mo><mi>c</mi><mo>&#x2192;</mo><mi>R</mi><mo>&#x25CB;</mo><mi>L</mi><mo stretchy='false'>(</mo><mi>c</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">of <em>&#x03B7;</em>. Similarly given an object <epub:switch id="mathmlSwitch2026"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>d</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>D</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> we apply <em>&#x03B1;</em><sup>&#x2212;1</sup> to id<sub><em>R</em>(<em>d</em>)</sub> : <em>R</em>(<em>d</em>) &#x2192; <em>R</em>(<em>d</em>) to get the <em>d</em> component</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch2027"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo mathvariant="italic">&#x03F5;</mo><mi>d</mi></msub><mo>:</mo><mi>L</mi><mo>&#x25CB;</mo><mi>R</mi><mo stretchy='false'>(</mo><mi>d</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mi>d</mi><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">One checks that these components are natural.</p>
<p class="space-break">Later we see how to use the unit and counit of any adjunction to make a monad. We first walk through the process in Example <a href="chapter007.html#Exa_7-3-5-2">7.3.5.2</a>.</p>
<a id="p361"></a>
<p class="noindent1-top-exe" id="Exa_7-3-5-2"><em>Example</em> 7.3.5.2. Consider the adjunction <epub:switch id="mathmlSwitch2028"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Set</mtext><munderover><mo>&#x21C4;</mo><mi>U</mi><mi>F</mi></munderover><mtext mathvariant="bold">Mon</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> between sets and monoids. Let <em>T</em> &#x003D; <em>U</em> &#x25CB; <em>F</em> : <strong>Set</strong> &#x2192; <strong>Set</strong>; this will be the functor part of the monad, and we have seen that <em>T</em> &#x003D; List. The unit of the adjunction, <em>&#x03B7;</em> : id<strong><sub>Set</sub></strong> &#x2192; <em>U</em> &#x25CB; <em>F</em> is precisely the unit of the monad: for any set <em>X</em> &#x2208; Ob(<strong>Set</strong>) the component <em>&#x03B7;<sub>X</sub></em> : <em>X</em> &#x2192; List(<em>X</em>) is the function that takes <em>x</em> &#x2208; <em>X</em> to the singleton list [<em>x</em>] &#x2208; List(<em>X</em>). The monad also has a multiplication map <em>&#x03BC;<sub>X</sub></em> : <em>T</em>(<em>T</em>(<em>X</em>)) &#x2192; <em>T</em>(<em>X</em>), which amounts to concatenating a list of lists. This function comes about using the counit <em>&#x03F5;</em>, as follows</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch2029"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>T</mi><mo>&#x25CB;</mo><mi>T</mi><mo>=</mo><mi>U</mi><mo>&#x25CB;</mo><mi>F</mi><mo>&#x25CB;</mo><mi>U</mi><mo>&#x25CB;</mo><mi>F</mi><mover><mo>&#x2192;</mo><mrow><mo>&#x00A0;</mo><mo>&#x00A0;</mo><msub><mrow><mtext>id</mtext></mrow><mi>U</mi></msub><mo>&#x22C4;</mo><mo mathvariant="italic">&#x03F5;</mo><mo>&#x22C4;</mo><msub><mrow><mtext>id</mtext></mrow><mi>F</mi></msub><mo>&#x00A0;</mo><mo>&#x00A0;</mo></mrow></mover><mi>U</mi><mo>&#x25CB;</mo><mi>F</mi><mo>=</mo><mi>T</mi><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p>The general procedure for extracting a monad from an adjunction is analogous to the process shown in Example <a href="chapter007.html#Exa_7-3-5-2">7.3.5.2</a>. Given any adjunction</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch2030"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant="script">C</mi><munderover><mo>&#x21C4;</mo><mi>R</mi><mi>L</mi></munderover><mi mathvariant="script">D</mi><mo>,</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">we define <epub:switch id="mathmlSwitch2031"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>T</mi><mo>=</mo><mi>R</mi><mo>&#x25CB;</mo><mi>L</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>C</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we define <epub:switch id="mathmlSwitch2032"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x03B7;</mi><mo>:</mo><msub><mrow><mtext>id</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo>&#x2192;</mo><mi mathvariant='script'>T</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> to be the unit of the adjunction (as in Definition <a href="chapter007.html#Def_7-3-5-1">7.3.5.1</a>), and we define <epub:switch id="mathmlSwitch2033"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x03BC;</mi><mo>:</mo><mi mathvariant='script'>T</mi><mo>&#x25CB;</mo><mi mathvariant='script'>T</mi><mo>&#x2192;</mo><mi mathvariant='script'>T</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> to be the natural transformation id<em><sub>R</sub></em> &#x22C4; <em>&#x03F5;</em> &#x22C4; id<em><sub>L</sub></em> : <em>RLRL</em> &#x2192; <em>RL</em>, obtained by applying the counit <epub:switch id="mathmlSwitch2034"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo mathvariant="italic">&#x03F5;</mo><mo>:</mo><mi>L</mi><mi>R</mi><mo>&#x2192;</mo><msub><mrow><mtext>id</mtext></mrow><mi mathvariant='script'>D</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p>This procedure produces monads on arbitrary categories <epub:switch id="mathmlSwitch2035"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, whereas the definition of monad (Definition <a href="chapter007.html#Def_7-3-2-1">7.3.2.1</a>) considers only the case <epub:switch id="mathmlSwitch2036"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>=</mo><mi mathvariant="bold">Set</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>. However, Definition <a href="chapter007.html#Def_7-3-2-1">7.3.2.1</a> can be generalized to arbitrary categories <epub:switch id="mathmlSwitch2037"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> by simply replacing every occurrence of the string <strong>Set</strong> with the string <epub:switch id="mathmlSwitch2038"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>. Similarly, the definition of Kleisli categories (Definition <a href="chapter007.html#Def_7-3-3-1">7.3.3.1</a>) considers only the case <epub:switch id="mathmlSwitch2039"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>=</mo><mi mathvariant="bold">Set</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, but again the generalization to arbitrary categories <epub:switch id="mathmlSwitch2040"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> is straightforward.</p>
<p class="noindent1-top-exe" id="Exa_7-3-5-3"><em>Example</em> 7.3.5.3. Let <em>A</em> &#x2208; Ob(<strong>Set</strong>) be a set, and recall the currying adjunction</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch2041"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="bold">Set</mtext><munderover><mo>&#x21C4;</mo><mrow><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mi>Y</mi><mo>&#x21A6;</mo><msup><mi>Y</mi><mi>A</mi></msup><mo>&#x00A0;</mo><mo>&#x00A0;</mo></mrow><mrow><mo>&#x00A0;</mo><mo>&#x00A0;</mo><mi>X</mi><mo>&#x21A6;</mo><mi>X</mi><mo>&#x00D7;</mo><mi>A</mi><mo>&#x00A0;</mo><mo>&#x00A0;</mo></mrow></munderover><mtext mathvariant="bold">Set</mtext><mo>,</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">discussed briefly in Example <a href="chapter007.html#Exa_7-1-1-8">7.1.1.8</a>. The corresponding monad <em>St<sub>A</sub></em> is typically called the <em>state monad of type A</em> in programming language theory. Given a set <em>X</em>, we have</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch2042"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>S</mi><msub><mi>t</mi><mi>A</mi></msub><mo stretchy='false'>(</mo><mi>X</mi><mo stretchy='false'>)</mo><mo>=</mo><msup><mrow><mo stretchy='false'>(</mo><mi>A</mi><mo>&#x00D7;</mo><mi>X</mi><mo stretchy='false'>)</mo></mrow><mi>A</mi></msup><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">In the Kleisli category <strong>Kls</strong>(<em>St<sub>A</sub></em>) a morphism from <em>X</em> to <em>Y</em> is a function of the form <em>X</em> &#x2192; (<em>A</em> &#x00D7; <em>Y</em>)<em><sup>A</sup></em>, but this can be curried to a function <em>A</em> &#x00D7; <em>X</em> &#x2192; <em>A</em> &#x00D7; <em>Y</em>.</p>
<p>As discussed in Remark <a href="chapter007.html#Rem_7-3-3-9">7.3.3.9</a>, this monad is related to holding onto an internal state variable of type <em>A</em>. Under the state monad <em>St<sub>A</sub></em>, every morphism written <em>X</em> &#x2192; <em>Y</em>, when viewed as a function, takes as input not only an element of <em>X</em>, but also the current state <em>a</em> &#x2208; <em>A</em>, and it produces as output not only an element of <em>Y</em>, but also an updated state.</p>
<a id="p362"></a>
<p class="space-break">Computer scientists in programming language theory have found monads very useful (Moggi [33]). In much the same way, monads on <strong>Set</strong> might be useful in databases (see Section <a href="chapter007.html#lev_7-3-4">7.3.4</a>). Another, totally different way to use monads in databases is by using a mapping between schemas to produce in each one an internal model of the other. That is, for any functor <epub:switch id="mathmlSwitch2043"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant='script'>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, i.e., mapping of database schemas, the adjunction (&#x03A3;<em><sub>F</sub></em>, &#x0394;<em><sub>F</sub></em>) produces a monad on <epub:switch id="mathmlSwitch2044"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mi mathvariant="bold">Set</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and the adjunction (&#x0394;<em><sub>F</sub></em>, &#x03A0;<em><sub>F</sub></em>) produces a monad on <epub:switch id="mathmlSwitch2045"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>D</mi><mo>&#x2212;</mo><mi mathvariant="bold">Set</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>. If one interprets the List monad as producing in <strong>Set</strong> an internal model of the category <strong>Mon</strong> of monoids, one can similarly interpret these monads on <epub:switch id="mathmlSwitch2046"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2212;</mo><mi mathvariant="bold">Set</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch2047"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>D</mi><mo>&#x2212;</mo><mi mathvariant="bold">Set</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> as producing internal models of each within the other.</p>
</section>
</section>
<section title="Operads">
<h1 class="level1" id="lev_7-4"><a href="toc.html#Rlev_7-4"><strong>7.4&#160;&#160;&#160;Operads</strong></a></h1>
<p class="noindent">This section briefly introduces operads, which are generalizations of categories. They often are useful for speaking about self-similarity of structure. For example, we use operads to model agents made up of smaller agents, or materials made up of smaller materials. This association with self-similarity is not really inherent in the definition, but it tends to emerge in thinking about many operads used in practice.</p>
<p>Let me begin with a warning.</p>
<p class="noindent1-top-War"><em>Warning</em> 7.4.0.4. My use of the term <em>operad</em> is not entirely standard and conflicts with widespread usage. The more common term for what I am calling an operad is <em>colored operad</em> or <em>symmetric multicategory</em>. An operad classically is a multicategory with one object, and a colored operad is a multicategory with possibly many objects (one for each &#x201C;color&#x201D;). The term <em>multicategory</em> stems from the fact that the morphisms in a multicategory have many, rather than one, domain object. One reason I prefer not to use the term <em>multicategory</em> is that there is nothing really &#x201C;multi&#x201D; about the multicategory itself, only its morphisms. Further, I do not see enough reason to differentiate, given that the term <em>multicategory</em> seems rather clunky and the term <em>operad</em> seems rather sleek. I hope my break with standard terminology does not cause confusion.</p>
<p class="space-break">This introduction to operads is quite short; see Leinster [25] for an excellent treatment. Operads are also related to monoidal categories, a subject that is not elaborated in this book to discuss, but which was briefly mentioned when discussing topological enrichment in Example <a href="chapter005.html#Exa_5-2-3-3">5.2.3.3</a>. Many of the following operads are actually monoidal categories in disguise.</p>
<section title="Definition and classical examples">
<h2 class="level2" id="lev_7-4-1"><strong>7.4.1&#160;&#160;&#160;Definition and classical examples</strong></h2>
<p class="noindent">An operad is like a category in that it has objects, morphisms, and a composition formula, and it obeys an identity law and an associativity law. The difference is that each morphism <em>f</em> in an operad can have many inputs (and one output):</p>
<a id="p363"></a>
<p class="fig-img"><img src="images/Art_P337.jpg" alt="art"/></p>
<p class="noindent">The description of composition in an operad is a bit more complicated than for a category, because it involves much more variable indexing; however, the idea is straightforward. Figure <strong>??</strong> shows morphisms being composed. Note that <em>S</em> and <em>T</em> disappear from the composition, but this is analogous to the way the middle object disappears from the composition of morphisms in a category</p>
<p class="fig-img"><img src="images/Art_P338.jpg" alt="art"/></p>
<p class="noindent">Here is the definition, taken from Spivak [41]. Skip to Example <a href="chapter007.html#Exa_7-4-1-3">7.4.1.3</a> if the definition gets too difficult.</p>
<p class="noindent1-top-def" id="Def_7-4-1-1"><strong>Definition 7.4.1.1</strong>. An <em>operad</em> <epub:switch id="mathmlSwitch2048"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>O</mi></math></epub:case><epub:default></epub:default></epub:switch> is defined as follows: One announces some constituents (A. objects, B. morphisms, C. identities, D. compositions) and shows that they conform to some laws (1. identity law, 2. associativity law). Specifically, one announces</p>
<p class="nl-2list">A. a collection <epub:switch id="mathmlSwitch2049"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, each element of which is called an <em>object</em> of <epub:switch id="mathmlSwitch2050"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>O</mi></math></epub:case><epub:default></epub:default></epub:switch>;</p>
<p class="nl-2list">B. for each object <epub:switch id="mathmlSwitch2051"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, finite set <em>n</em> &#x2208; Ob(<strong>Fin</strong>), and <em>n</em>-indexed set of objects <epub:switch id="mathmlSwitch2052"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>:</mo><mi>n</mi><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, a set <epub:switch id="mathmlSwitch2053"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant='script'>O</mi><mi>n</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>;</mo><mi>y</mi><mo stretchy='false'>)</mo><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mtext mathvariant="bold">Set</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>; its elements are called <em>morphisms from x to y</em> in <epub:switch id="mathmlSwitch2054"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>O</mi></math></epub:case><epub:default></epub:default></epub:switch>;</p>
<p class="nl-2list">C. for every object <epub:switch id="mathmlSwitch2055"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, a specified morphism, denoted <epub:switch id="mathmlSwitch2056"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>id</mtext></mrow><mi>x</mi></msub><mo>&#x2208;</mo><msub><mi mathvariant='script'>O</mi><mn>1</mn></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>;</mo><mi>x</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and called <em>the identity morphism on x</em>.</p>
<p class="nl-2list">D. Let <em>s</em> : <em>m</em> &#x2192; <em>n</em> be a morphism in <strong>Fin</strong>. Let <epub:switch id="mathmlSwitch2057"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>z</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be an object, let <epub:switch id="mathmlSwitch2058"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi><mo>:</mo><mi>n</mi><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be an <em>n</em>-indexed set of objects, and let <epub:switch id="mathmlSwitch2059"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>:</mo><mi>m</mi><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be an <em>m</em>-indexed set of objects. For each element <em>i</em> &#x2208; <em>n</em>, write <em>m<sub>i</sub></em> &#x2254; <em>s</em><sup>&#x2212;1</sup>(<em>i</em>) for the pre-image of <em>s</em> under <em>i</em>, and write <epub:switch id="mathmlSwitch2060"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mi>x</mi><msub><mo>&#x007C;</mo><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow></msub><mo>:</mo><msub><mi>m</mi><mi>i</mi></msub><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> for the restriction of <em>x</em> to <em>m<sub>i</sub></em>. Then one announces a function</p>
<p class="disp-equ" id="eq_7-17"><epub:switch id="mathmlSwitch2061"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mtable><mtr><mtd><mrow><mo>&#x25CB;</mo><mo>:</mo><msub><mi mathvariant='script'>O</mi><mi>n</mi></msub><mo stretchy='false'>(</mo><mi>y</mi><mo>;</mo><mi>z</mi><mo stretchy='false'>)</mo><mo>&#x00D7;</mo><mstyle displaystyle='true'><munder><mo>&#x220F;</mo><mrow><mi>i</mi><mo>&#x2208;</mo><mi>n</mi></mrow></munder><mrow><msub><mi mathvariant='script'>O</mi><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow></msub><mo stretchy='false'>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>;</mo><mi>y</mi><mo stretchy='false'>(</mo><mi>i</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>&#x2192;</mo><msub><mi mathvariant='script'>O</mi><mi>m</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>;</mo><mi>z</mi><mo stretchy='false'>)</mo></mrow></mstyle><mo>,</mo></mrow></mtd><mtd><mo>(</mo><mn>7.17</mn><mo>)</mo></mtd></mtr></mtable></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="nl-2list-para">called <em>the composition formula</em>.</p>
<a id="p364"></a>
<p class="noindent1-top">Given an <em>n</em>-indexed set of objects <epub:switch id="mathmlSwitch2062"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>:</mo><mi>n</mi><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and an object <epub:switch id="mathmlSwitch2063"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we sometimes abuse notation and denote the set of morphisms from <em>x</em> to <em>y</em> by <epub:switch id="mathmlSwitch2064"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo>;</mo><mi>y</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>.<sup><a id="endnote_ref_13" href="chapter007.html#endnote_13">13</a></sup> We may write <epub:switch id="mathmlSwitch2065"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>O</mi></msub><mo stretchy='false'>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo>;</mo><mi>y</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, in place of <epub:switch id="mathmlSwitch2066"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo>;</mo><mi>y</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, when convenient. We can denote a morphism <epub:switch id="mathmlSwitch2067"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x03D5;</mi><mo>&#x2208;</mo><msub><mi mathvariant='script'>O</mi><mi>n</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>;</mo><mi>y</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> by <em>&#x03D5;</em> : <em>x</em> &#x2192; <em>y</em> or by <em>&#x03D5;</em> : (<em>x</em><sub>1</sub>, &#x2026;, <em>x<sub>n</sub></em>) &#x2192; <em>y</em>; we say that each <em>x<sub>i</sub></em> is a <em>domain object</em> of <em>&#x03D5;</em> and that <em>y</em> is the <em>codomain object</em> of <em>&#x03D5;</em>. We use infix notation for the composition formula, e.g., <em>&#x03C8;</em> &#x25CB; (<em>&#x03D5;</em><sub>1</sub>, &#x2026;, <em>&#x03D5;<sub>n</sub></em>).</p>
<p>One must then show that the following <em>operad laws</em> hold:</p>
<ol class="olindent">
<li>For every <epub:switch id="mathmlSwitch2068"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo>,</mo><mi>y</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and every morphism <em>&#x03D5;</em> : (<em>x</em><sub>1</sub>, &#x2026;, <em>x<sub>n</sub></em>) &#x2192; <em>y</em>, we have
<p class="disp-equ-no"><epub:switch id="mathmlSwitch2069"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x03D5;</mi><mo>&#x25CB;</mo><mo stretchy='false'>(</mo><msub><mrow><mtext>id</mtext></mrow><mrow><msub><mi>x</mi><mn>1</mn></msub></mrow></msub><mo>,</mo><mn>...</mn><mo>,</mo><msub><mrow><mtext>id</mtext></mrow><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow></msub><mo stretchy='false'>)</mo><mo>=</mo><mi>&#x03D5;</mi><mo>&#x00A0;</mo><mtext>and</mtext><mo>&#x00A0;</mo><msub><mrow><mtext>id</mtext></mrow><mi>y</mi></msub><mo>&#x25CB;</mo><mi>&#x03D5;</mi><mo>=</mo><mi>&#x03D5;</mi><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p></li>
<li class="litop">Let <epub:switch id="mathmlSwitch2070"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi><mover><mo>&#x2192;</mo><mi>s</mi></mover><mi>n</mi><mover><mo>&#x2192;</mo><mi>t</mi></mover><mi>p</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> be composable morphisms in <strong>Fin</strong>. Let <epub:switch id="mathmlSwitch2071"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>z</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be an object, let <epub:switch id="mathmlSwitch2072"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi><mo>:</mo><mi>p</mi><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo><mo>,</mo><mo>&#x00A0;</mo><mi>x</mi><mo>:</mo><mi>n</mi><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo><mo>,</mo><mo>&#x00A0;</mo><mtext>and</mtext><mo>&#x00A0;</mo><mi>w</mi><mo>:</mo><mi>m</mi><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> respectively be a <em>p</em>-indexed, <em>n</em>-indexed, and <em>m</em>-indexed set of objects. For each <em>i</em> &#x2208; <em>p</em>, write <em>n<sub>i</sub></em> &#x003D; <em>t</em><sup>&#x2212;1</sup>(<em>i</em>) for the pre-image and <epub:switch id="mathmlSwitch2073"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>:</mo><msub><mi>n</mi><mi>i</mi></msub><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> for the restriction. Similarly, for each <em>k</em> &#x2208; <em>n</em>, write <em>m<sub>k</sub></em> &#x003D; <em>s</em><sup>&#x2212;1</sup>(<em>k</em>) and <epub:switch id="mathmlSwitch2074"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>w</mi><mi>k</mi></msub><mo>:</mo><msub><mi>m</mi><mi>k</mi></msub><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>; for each <em>i</em> &#x2208; <em>p</em>, write <em>m</em><sub><em>i</em>,&#x2212;</sub> &#x003D; (<em>t</em> &#x25CB; <em>s</em>)<sup>&#x2212;1</sup>(<em>i</em>) and <epub:switch id="mathmlSwitch2075"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>w</mi><mrow><mi>i</mi><mo>,</mo><mo>&#x2212;</mo></mrow></msub><mo>:</mo><msub><mi>m</mi><mrow><mi>i</mi><mo>,</mo><mo>&#x2212;</mo></mrow></msub><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>; for each <em>j</em> &#x2208; <em>n<sub>i</sub></em>, write <em>m</em><sub><em>i</em>,<em>j</em></sub> &#x2254; <em>s</em><sup>&#x2212;1</sup>(<em>j</em>) and <epub:switch id="mathmlSwitch2076"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>w</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>:</mo><msub><mi>m</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Then the following diagram commutes:
<p class="fig-img"><img src="images/Art_P339.jpg" alt="art"/></p></li>
</ol>
<p class="noindent" id="Rem_7-4-1-2"><em>Remark</em> 7.4.1.2. This remark considers the abuse of notation in Definition <a href="chapter007.html#Def_7-4-1-1">7.4.1.1</a> and how it relates to an action of a symmetric group on each morphism set in the definition of operad. We follow the notation of Definition <a href="chapter007.html#Def_7-4-1-1">7.4.1.1</a>, especially the use of subscripts in the composition formula.</p>
<p>Suppose that <epub:switch id="mathmlSwitch2077"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">O</mi></math></epub:case><epub:default></epub:default></epub:switch> is an operad, <epub:switch id="mathmlSwitch2078"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>z</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is an object, <epub:switch id="mathmlSwitch2079"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi><mo>:</mo><mi>n</mi><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> is an <em>n</em>-indexed set of objects, and <em>&#x03D5;</em> : <em>y</em> &#x2192; <em>z</em> is a morphism. If we linearly order <em>n</em>, enabling us to write <em>&#x03D5;</em> : (<em>y</em>(1), &#x2026;, <em>y</em>(&#x007C;<em>n</em>&#x007C;)) &#x2192; <em>z</em>, then changing the linear ordering amounts to finding an <a id="p365"></a>isomorphism of finite sets <epub:switch id="mathmlSwitch2080"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>&#x03C3;</mi><mo>:</mo><mi>m</mi><mover><mo>&#x2192;</mo><mo>&#x2245;</mo></mover><mi>n</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, where &#x007C;<em>m</em>&#x007C; &#x003D; &#x007C;<em>n</em>&#x007C;. Let <em>x</em> &#x003D; <em>y</em> &#x25CB; <em>&#x03C3;</em>, and for each <em>i</em> &#x2208; <em>n</em>, note that <em>m<sub>i</sub></em> &#x003D; <em>&#x03C3;</em><sup>&#x2212;1</sup>({<em>i</em>}) &#x003D; {<em>&#x03C3;</em><sup>&#x2212;1</sup>(<em>i</em>)}, so <epub:switch id="mathmlSwitch2081"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>=</mo><mi>x</mi><msub><mo>&#x007C;</mo><mrow><msup><mi>&#x03C3;</mi><mrow><mo>&#x2212;</mo><mn>1</mn></mrow></msup><mo stretchy='false'>(</mo><mi>i</mi><mo stretchy='false'>)</mo></mrow></msub><mo>=</mo><mi>y</mi><mo stretchy='false'>(</mo><mi>i</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Taking <epub:switch id="mathmlSwitch2082"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>id</mtext></mrow><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow></msub><mo>&#x2208;</mo><msub><mi mathvariant='script'>O</mi><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow></msub><mo stretchy='false'>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>;</mo><mi>y</mi><mo stretchy='false'>(</mo><mi>i</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> for each <em>i</em> &#x2208; <em>n</em>, and using the identity law, we find that the composition formula induces a bijection <epub:switch id="mathmlSwitch2083"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi mathvariant='script'>O</mi><mi>n</mi></msub><mo stretchy='false'>(</mo><mi>y</mi><mo>;</mo><mi>z</mi><mo stretchy='false'>)</mo><mover><mo>&#x2192;</mo><mo>&#x2245;</mo></mover><msub><mi mathvariant='script'>O</mi><mi>m</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>;</mo><mi>z</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, which we might denote</p>
<p class="disp-equ" id="eq_7-18"><epub:switch id="mathmlSwitch2084"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mtable><mtr><mtd><mrow><mi>&#x03C3;</mi><mo>:</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>y</mi><mo stretchy='false'>(</mo><mn>1</mn><mo stretchy='false'>)</mo><mo>,</mo><mi>y</mi><mo stretchy='false'>(</mo><mn>2</mn><mo stretchy='false'>)</mo><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><mi>y</mi><mo stretchy='false'>(</mo><mi>n</mi><mo stretchy='false'>)</mo><mo>;</mo><mi>z</mi><mo stretchy='false'>)</mo><mo>&#x2245;</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>y</mi><mo stretchy='false'>(</mo><mi>&#x03C3;</mi><mo stretchy='false'>(</mo><mn>1</mn><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>,</mo><mi>y</mi><mo stretchy='false'>(</mo><mi>&#x03C3;</mi><mo stretchy='false'>(</mo><mn>2</mn><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><mi>y</mi><mo stretchy='false'>(</mo><mi>&#x03C3;</mi><mo stretchy='false'>(</mo><mi>n</mi><mo stretchy='false'>)</mo><mo stretchy='false'>)</mo><mo>;</mo><mi>z</mi><mo stretchy='false'>)</mo><mo>.</mo></mrow></mtd><mtd><mo>(</mo><mn>7.18</mn><mo>)</mo></mtd></mtr></mtable></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">In other words, the permutation group Aut(<em>n</em>) acts on the set <epub:switch id="mathmlSwitch2085"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi mathvariant="script">O</mi><mi>n</mi></msub></math></epub:case><epub:default></epub:default></epub:switch> of <em>n</em>-ary morphisms by permuting the order of the domain objects <epub:switch id="mathmlSwitch2086"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><msup><mrow><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow><mi>n</mi></msup></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="space-break">Throughout this book, we allow this abuse of notation and speak of morphisms <em>&#x03D5;</em> : (<em>y</em><sub>1</sub>, <em>y</em><sub>2</sub>, &#x2026;, <em>y<sub>n</sub></em>) &#x2192; <em>z</em> for a natural number <em>n</em> &#x2208; &#x2115;, without mentioning the abuse inherent in choosing an order, as long as it is clear that permuting the order of indices would not change anything up to the canonical isomorphism of (<a href="chapter007.html#eq_7-18">7.18</a>).</p>
<p class="noindent1-top-exe" id="Exa_7-4-1-3"><em>Example</em> 7.4.1.3 (Little squares operad). An operad commonly used in mathematics is called the <em>little n-cubes operad</em>. We will focus on <em>n</em> &#x003D; 2 and talk about the little squares operad <epub:switch id="mathmlSwitch2087"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>O</mi></math></epub:case><epub:default></epub:default></epub:switch>. Here the set of objects has only one element, denoted by a square, <epub:switch id="mathmlSwitch2088"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo><mo>=</mo><mo stretchy="false">{</mo><mo>&#x25AB;</mo><mo stretchy="false">}</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. For a natural number <em>n</em> &#x2208; &#x2115;, a morphism <em>f</em> : (&#x25AB;, &#x25AB;, &#x2026;, &#x25AB;) &#x2192; &#x25AB; is a positioning of <em>n</em> nonoverlapping squares inside of a square. <a href="chapter007.html#Fig_7-5">Figure 7.5</a> shows a morphism (<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, <em>X</em><sub>3</sub>) &#x2192; <em>Y</em>, where <em>X</em><sub>1</sub> &#x003D; <em>X</em><sub>2</sub> &#x003D; <em>X</em><sub>3</sub> &#x003D; <em>Y</em> &#x003D; &#x25AB;.</p>
<p class="space-break">The composition formula says that given a positioning of small squares inside a large square, and given a positioning of tiny squares inside each of those small squares, we get a positioning of tiny squares inside a large square. See <a href="chapter007.html#Fig_7-6">Figure 7.6</a>.</p>
<p class="space-break">Example <a href="chapter007.html#Exa_7-4-1-3">7.4.1.3</a> exemplifies the kind of self-similarity mentioned on page 362.</p>
<p class="noindent1-top-exe" id="Exe_7-4-1-4"><em>Exercise</em> 7.4.1.4.</p>
<p>Consider an operad <epub:switch id="mathmlSwitch2089"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">O</mi></math></epub:case><epub:default></epub:default></epub:switch> like the little squares operad from Example <a href="chapter007.html#Exa_7-4-1-3">7.4.1.3</a>, except with three objects: square, circle, equilateral triangle. A morphism is again a nonoverlapping positioning of shapes inside a shape.</p>
<p class="nl1-list">a. Draw an example of a morphism <em>f</em> from two circles and a square to a triangle.</p>
<p class="nl1-list">b. Find three other morphisms that compose into <em>f</em>, and draw the composite.</p>

<p class="noindent1-top-sol"><em>Solution</em> 7.4.1.4.</p>
<p class="nl1-list">a.</p>
<a id="p366"></a>
<p class="fig-img"><img src="images/Art_P340.jpg" alt="art"/></p>
<p class="nl1-list">b.</p>
<p class="fig-img"><img src="images/Art_P341.jpg" alt="art"/></p>
<p class="noindent1-top-exe" id="Exa_7-4-1-5"><em>Example</em> 7.4.1.5. Let <strong>Sets</strong> denote the operad defined as follows. As objects we put Ob(<strong>Sets</strong>) &#x003D; Ob(<strong>Set</strong>). For a natural number <em>n</em> &#x2208; &#x2115; and sets <em>X</em><sub>1</sub>, &#x2026;, <em>X<sub>n</sub></em>, <em>Y</em>, put</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch2090"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Sets</mtext></mrow></msub><mo stretchy='false'>(</mo><msub><mi>X</mi><mn>1</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><msub><mi>X</mi><mi>n</mi></msub><mo>;</mo><mi>Y</mi><mo stretchy='false'>)</mo><mo>&#x2254;</mo><msub><mrow><mtext>Hom</mtext></mrow><mrow><mtext mathvariant="bold">Set</mtext></mrow></msub><mo stretchy='false'>(</mo><msub><mi>X</mi><mn>1</mn></msub><mo>&#x00D7;</mo><mo>&#x22EF;</mo><mo>&#x00D7;</mo><msub><mi>X</mi><mi>n</mi></msub><mo>,</mo><mi>Y</mi><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>

<p class="noindent">Given functions <epub:switch id="mathmlSwitch2091"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>f</mi><mn>1</mn></msub><mo>:</mo><mo stretchy='false'>(</mo><msub><mi>X</mi><mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>&#x00D7;</mo><mo>&#x22EF;</mo><mo>&#x00D7;</mo><msub><mi>X</mi><mrow><mn>1</mn><mo>,</mo><msub><mi>m</mi><mn>1</mn></msub></mrow></msub><mo stretchy='false'>)</mo><mo>&#x2192;</mo><msub><mi>Y</mi><mn>1</mn></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> through <epub:switch id="mathmlSwitch2092"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>f</mi><mi>n</mi></msub><mo>:</mo><mo stretchy='false'>(</mo><msub><mi>X</mi><mrow><mi>n</mi><mo>,</mo><mn>1</mn></mrow></msub><mo>&#x00D7;</mo><mo>&#x22EF;</mo><mo>&#x00D7;</mo><msub><mi>X</mi><mrow><mi>n</mi><mo>,</mo><msub><mi>m</mi><mi>n</mi></msub></mrow></msub><mo stretchy='false'>)</mo><mo>&#x2192;</mo><msub><mi>Y</mi><mi>n</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch> and a function <em>Y</em><sub>1</sub> &#x00D7; &#x22EF; &#x00D7; <em>Y<sub>n</sub></em> &#x2192; <em>Z</em>, the universal property provides a unique function of the form <epub:switch id="mathmlSwitch2093"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy='false'>(</mo><msub><mi>X</mi><mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub><mo>&#x00D7;</mo><mo>&#x22EF;</mo><mo>&#x00D7;</mo><msub><mi>X</mi><mrow><mi>n</mi><mo>,</mo><msub><mi>m</mi><mi>n</mi></msub></mrow></msub><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mi>Z</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, giving rise to the composition formula in <strong>Sets</strong>.</p>
<a id="p367"></a>
<section title="Operads: functors and algebras">
<h3 class="level3" id="lev_7-4-1-6"><strong>7.4.1.6&#160;&#160;&#160;Operads: functors and algebras</strong></h3>
<p class="noindent">If operads are like categories, then we can define things like functors and call them <em>operad functors</em>.</p>
<p class="noindent1-top-War"><em>Warning</em> 7.4.1.7. What is called an operad functor in Definition <a href="chapter007.html#Def_7-4-1-8">7.4.1.8</a> is usually called an <em>operad morphism</em>. I think the terminology clash between morphisms <em>of</em> operads and morphisms <em>in</em> an operad is confusing. It is similar to what would occur in regular category theory (see Chapter 5) if we replaced the term <em>functor</em> with the term <em>category morphism</em>.</p>
<p class="noindent1-top-def" id="Def_7-4-1-8"><strong>Definition 7.4.1.8</strong>. Let <epub:switch id="mathmlSwitch2094"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">O</mi></math></epub:case><epub:default></epub:default></epub:switch> and <epub:switch id="mathmlSwitch2095"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>O</mi><mo>&#x2032;</mo></math></epub:case><epub:default></epub:default></epub:switch> be operads. An <em>operad functor from</em> <epub:switch id="mathmlSwitch2096"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">O</mi></math></epub:case><epub:default></epub:default></epub:switch> <em>to</em> <epub:switch id="mathmlSwitch2097"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>O</mi><mo>&#x2032;</mo></math></epub:case><epub:default></epub:default></epub:switch>, denoted <epub:switch id="mathmlSwitch2098"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>O</mi><mo>&#x2192;</mo><mi mathvariant='script'>O</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, is defined as follows. One announces some constituents (A. on-objects part, B. on-morphisms part) and shows that they conform to some laws (1. preservation of identities, 2. preservation of composition). Specifically, one announces</p>
<p class="nl1-list-2">A. a function <epub:switch id="mathmlSwitch2099"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi>F</mi><mo stretchy='false'>)</mo><mo>:</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, sometimes denoted simply <epub:switch id="mathmlSwitch2100"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo>&#x2032;</mo><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>;</p>
<p class="nl1-list-2">B. for each object <epub:switch id="mathmlSwitch2101"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, finite set <em>n</em> &#x2208; Ob(<strong>Fin</strong>), and <em>n</em>-indexed set of objects <epub:switch id="mathmlSwitch2102"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>:</mo><mi>n</mi><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, a function</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch2103"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>F</mi><mi>n</mi></msub><mo>:</mo><msub><mi mathvariant='script'>O</mi><mi>n</mi></msub><mo stretchy='false'>(</mo><mi>x</mi><mo>;</mo><mi>y</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><msubsup><mi mathvariant='script'>O</mi><mi>n</mi><mo>&#x2032;</mo></msubsup><mo stretchy='false'>(</mo><mi>F</mi><mi>x</mi><mo>;</mo><mi>F</mi><mi>y</mi><mo stretchy='false'>)</mo><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">One must then show that the following <em>operad functor laws</em> hold:</p>
<ol class="olindent">
<li>For each object <epub:switch id="mathmlSwitch2104"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, the equation <em>F</em>(id<em><sub>x</sub></em>) &#x003D; id<sub><em>Fx</em></sub> holds.</li>
<li class="litop">Let <em>s</em> : <em>m</em> &#x2192; <em>n</em> be a morphism in <strong>Fin</strong>. Let <epub:switch id="mathmlSwitch2105"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>z</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be an object, let <epub:switch id="mathmlSwitch2106"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>y</mi><mo>:</mo><mi>n</mi><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be an <em>n</em>-indexed set of objects, and let <epub:switch id="mathmlSwitch2107"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>:</mo><mi>m</mi><mo>&#x2192;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> be an <em>m</em>-indexed set of objects. Then, with notation as in Definition <a href="chapter007.html#Def_7-4-1-1">7.4.1.1</a>, the following diagram of sets commutes:
<p class="fig-img" id="eq_7-19"><img src="images/Art_P342.jpg" alt="art"/></p></li>
</ol>

<p>We denote the category of operads and operad functors <strong>Oprd</strong>.</p>
<p class="noindent1-top-exe" id="Exe_7-4-1-9"><em>Exercise</em> 7.4.1.9.</p>
<p>Let <epub:switch id="mathmlSwitch2108"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">O</mi></math></epub:case><epub:default></epub:default></epub:switch> denote the little squares operad from Example <a href="chapter007.html#Exa_7-4-1-3">7.4.1.3</a>, and let <epub:switch id="mathmlSwitch2109"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>O</mi><mo>&#x2032;</mo></math></epub:case><epub:default></epub:default></epub:switch> denote the little shapes operad you constructed in Exercise <a href="chapter007.html#Exe_7-4-1-4">7.4.1.4</a>.</p>
<a id="p368"></a>
<p class="nl1-list">a. Can you find an operad functor <epub:switch id="mathmlSwitch2110"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mo>:</mo><mi mathvariant='script'>O</mi><mo>&#x2192;</mo><mi mathvariant='script'>O</mi><mo>&#x2032;</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>?</p>
<p class="nl1-list">b. Is it possible to find an operad functor <epub:switch id="mathmlSwitch2111"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>G</mi><mo>:</mo><mi mathvariant='script'>O</mi><mo>&#x2032;</mo><mo>&#x2192;</mo><mi mathvariant='script'>O</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>?</p>
<p class="noindent1-top-def" id="Def_7-4-1-10"><strong>Definition 7.4.1.10</strong> (Operad algebra). Let <epub:switch id="mathmlSwitch2112"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">O</mi></math></epub:case><epub:default></epub:default></epub:switch> be an operad, and let <strong>Sets</strong> be the operad from Example <a href="chapter007.html#Exa_7-4-1-5">7.4.1.5</a>. An <em>algebra on</em> <epub:switch id="mathmlSwitch2113"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">O</mi></math></epub:case><epub:default></epub:default></epub:switch> is an operad functor <epub:switch id="mathmlSwitch2114"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo>:</mo><mi mathvariant='script'>O</mi><mo>&#x2192;</mo><mtext mathvariant="bold">Sets</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="noindent1-top-rem" id="Rem_7-4-1-11"><em>Remark</em> 7.4.1.11. Every category can be construed as an operad (there is a functor <strong>Cat</strong> &#x2192; <strong>Oprd</strong>), one in which every morphism is unary. That is, given a category <epub:switch id="mathmlSwitch2115"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch>, one makes an operad <epub:switch id="mathmlSwitch2116"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">O</mi></math></epub:case><epub:default></epub:default></epub:switch> with <epub:switch id="mathmlSwitch2117"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo><mo>&#x2254;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>C</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and with</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch2118"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>O</mi></msub><mo stretchy='false'>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo>;</mo><mi>y</mi><mo stretchy='false'>)</mo><mo>=</mo><mrow><mo>{</mo><mrow><mtable columnalign="left"><mtr><mtd><mrow><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>C</mi></msub><mo stretchy='false'>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mi>y</mi><mo stretchy='false'>)</mo></mrow></mtd><mtd><mrow><mtext>if</mtext><mo>&#x00A0;</mo><mi>n</mi><mo>=</mo><mn>1</mn><mo>,</mo></mrow></mtd></mtr><mtr><mtd><mo>&#x2205;</mo></mtd><mtd><mrow><mtext>if</mtext><mo>&#x00A0;</mo><mi>n</mi><mo>&#x2260;</mo><mn>1.</mn></mrow></mtd></mtr></mtable></mrow></mrow></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">Throughout the book a connection is made between database schemas and categories (see Section <a href="chapter005.html#lev_5-2-2">5.2.2</a>), under which a schema <epub:switch id="mathmlSwitch2119"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> is construed as a category presentation, i.e., by generators and relations. Similarly, it is possible to discuss operad presentations <epub:switch id="mathmlSwitch2120"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>O</mi></math></epub:case><epub:default></epub:default></epub:switch>, again by generators and relations. Under this analogy, an instance <epub:switch id="mathmlSwitch2121"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mi mathvariant="bold">Set</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> of the database (see Section <a href="chapter005.html#lev_5-2-2-6">5.2.2.6</a>) corresponds to an algebra <epub:switch id="mathmlSwitch2122"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo>&#x2192;</mo><mtext mathvariant="bold">Sets</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> of the operad.</p>

</section>
</section>
<section title="Applications of operads and their algebras">
<h2 class="level2" id="lev_7-4-2"><strong>7.4.2&#160;&#160;&#160;Applications of operads and their algebras</strong></h2>
<p class="noindent">Hierarchical structures seem to be well modeled by operads. A hierarchical structure often has basic building blocks and instructions for how they can be put together into larger building blocks. Describing such structures using operads and their algebras allows one to make appropriate distinctions between different types of thinking, which may otherwise be blurred. For example, the abstract building instructions should be encoded in the operad, whereas the concrete building blocks should be encoded in the algebra. Morphisms of algebras are high-level understandings of how building blocks of very different types (such as materials versus numbers) can occupy the same place in the structure and be compared.</p>
<p>We get a general flavor of these ideas in the following examples.</p>
<p class="noindent1-top-app" id="App_7-4-2-1"><em>Application</em> 7.4.2.1. <span class="underline">Every material is composed of constituent materials</span>, arranged in certain patterns. (In case the material is pure, we consider the material to consist of itself as the sole constituent.) Each of these constituent materials is itself an arrangement of constituent materials. Thus a kind of self-similarity can be modeled with operads.</p>
<p>For example, a tendon is made of collagen fibers that are assembled in series and then in parallel, in a specific way. Each collagen fiber is made of collagen fibrils that are again assembled in series and then in parallel, with slightly different specifications. We can continue, perhaps indefinitely. Going a bit further, each collagen fibril is made up of <a id="p369"></a>tropocollagen collagen molecules, which are twisted ropes of collagen molecules, and so on.<sup><a id="endnote_ref_14" href="chapter007.html#endnote_14">14</a></sup></p>
<p>Here is how operads might be employed. We want the same operad to model all three of the following: actual materials, theoretical materials, and functional properties. That is, we want more than one algebra on the same operad.</p>
<p>The operad <epub:switch id="mathmlSwitch2123"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">O</mi></math></epub:case><epub:default></epub:default></epub:switch> should abstractly model the structure but not the substance being structured. Imagine that each of the shapes, say a triangle, in Figure (<a href="chapter007.html#eq_7-7">7.7</a>) is a placeholder that indicates &#x201C;your triangular material here.&#x201D; Each morphism represents a construction of a material out of parts.</p>
<p class="noindent1-top-app" id="App_7-4-2-2"><em>Application</em> 7.4.2.2. Suppose we have chosen an operad <epub:switch id="mathmlSwitch2124"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">O</mi></math></epub:case><epub:default></epub:default></epub:switch> to model the structure of materials. Say each object of <epub:switch id="mathmlSwitch2125"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">O</mi></math></epub:case><epub:default></epub:default></epub:switch> corresponds to a certain quality of material, and each morphism corresponds to an arrangement of various qualities to form a new quality. An algebra <epub:switch id="mathmlSwitch2126"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo>:</mo><mi mathvariant='script'>O</mi><mo>&#x2192;</mo><mtext mathvariant="bold">Sets</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> on <epub:switch id="mathmlSwitch2127"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>O</mi></math></epub:case><epub:default></epub:default></epub:switch> requires us to choose what substances will fill in for these qualities. For every object <epub:switch id="mathmlSwitch2128"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we want a set <em>A</em>(<em>x</em>) that will be the set of materials with that quality. For every arrangement, i.e., morphism, <em>f</em> : (<em>x</em><sub>1</sub>, &#x2026;, <em>x<sub>n</sub></em>) &#x2192; <em>y</em>, and every choice <em>a</em><sub>1</sub> &#x2208; <em>A</em>(<em>x</em><sub>1</sub>), &#x2026;, <em>a<sub>n</sub></em> &#x2208; <em>A</em>(<em>x<sub>n</sub></em>) of materials, we need to understand what material <em>a</em>&#x2032; &#x003D; <em>A</em>(<em>f</em>)(<em>a</em><sub>1</sub>, &#x2026;, <em>a<sub>n</sub></em>) &#x2208; <em>A</em>(<em>y</em>) will emerge when materials <em>a</em><sub>1</sub>, &#x2026;, <em>a<sub>n</sub></em> are arranged in accordance with <em>f</em>.</p>
<p>There may be more than one interesting algebra on <epub:switch id="mathmlSwitch2129"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>O</mi></math></epub:case><epub:default></epub:default></epub:switch>. Suppose that <epub:switch id="mathmlSwitch2130"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>B</mi><mo>:</mo><mi mathvariant='script'>O</mi><mo>&#x2192;</mo><mtext mathvariant="bold">Sets</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> is an algebra of strengths rather than of materials. For each object <epub:switch id="mathmlSwitch2131"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>x</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>O</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, which represents some quality, we let <em>B</em>(<em>x</em>) be the set of possible strengths that something of quality <em>x</em> can have. Then for each arrangement, i.e., morphism, <em>f</em> : (<em>x</em><sub>1</sub>, &#x2026;, <em>x<sub>n</sub></em>) &#x2192; <em>y</em>, and every choice <em>b</em><sub>1</sub> &#x2208; <em>B</em>(<em>x</em><sub>1</sub>), &#x2026;, <em>b<sub>n</sub></em> &#x2208; <em>B</em>(<em>x<sub>n</sub></em>) of strengths, we need to understand what strength <em>b</em>&#x2032; &#x003D; <em>B</em>(<em>f</em>)(<em>b</em><sub>1</sub>, &#x2026;, <em>b<sub>n</sub></em>) &#x2208; <em>B</em>(<em>y</em>) will emerge when strengths <em>b</em><sub>1</sub>, &#x2026;, <em>b<sub>n</sub></em> are arranged in accordance with <em>f</em>.</p>
<p>Finally, a morphism of algebras <em>S</em> : <em>A</em> &#x2192; <em>B</em> would consist of a coherent system for assigning to each material <em>a</em> &#x2208; <em>A</em>(<em>X</em>) of a given quality <em>x</em> a specific strength <em>S</em>(<em>a</em>) &#x2208; <em>B</em>(<em>X</em>), in such a way that morphisms behave appropriately. One can use the language of operads and algebras to state a very precise goal for the field of material mechanics.</p>
<p class="noindent1-top-exe" id="Exe_7-4-2-3"><em>Exercise</em> 7.4.2.3.</p>
<p>Consider again the little squares operad <epub:switch id="mathmlSwitch2132"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">O</mi></math></epub:case><epub:default></epub:default></epub:switch> from Example <a href="chapter007.html#Exa_7-4-1-3">7.4.1.3</a>. Suppose we want to use this operad to describe <span class="underline">photographic mosaics</span>.</p>
<a id="p370"></a>
<p class="nl1-list">a. Devise an algebra <epub:switch id="mathmlSwitch2133"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>P</mi><mo>:</mo><mi mathvariant='script'>O</mi><mo>&#x2192;</mo><mtext mathvariant="bold">Sets</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> that sends the square to the set <em>M</em> of all photos that can be pasted into that square. What does <em>P</em> do on morphisms in <epub:switch id="mathmlSwitch2134"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>O</mi></math></epub:case><epub:default></epub:default></epub:switch>?</p>
<p class="nl1-list">b. Devise an algebra <epub:switch id="mathmlSwitch2135"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi><mo>:</mo><mi mathvariant='script'>O</mi><mo>&#x2192;</mo><mtext mathvariant="bold">Sets</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> that sends each square to the set of all colors (visible frequencies of light). In other words, <em>C</em>(&#x25AB;) is the set of colors, not the set of ways to color the square. What does <em>C</em> do on morphisms in <epub:switch id="mathmlSwitch2136"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>O</mi></math></epub:case><epub:default></epub:default></epub:switch>. Hint: Use some kind of averaging scheme for the morphisms.</p>
<p class="nl1-list">c. Guess: If someone were to appropriately define morphisms of <epub:switch id="mathmlSwitch2137"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>O</mi></math></epub:case><epub:default></epub:default></epub:switch>-algebras (something akin to natural transformations between functors <epub:switch id="mathmlSwitch2138"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo>&#x2192;</mo><mtext mathvariant="bold">Sets</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>), do you think there would be some morphism of algebras <em>P</em> &#x2192; <em>C</em>?</p>

<section title="Relations and wiring diagrams">
<h3 class="level3" id="lev_7-4-2-4"><strong>7.4.2.4&#160;&#160;&#160;Relations and wiring diagrams</strong></h3>
<p class="noindent1-top-exe" id="Exa_7-4-2-5"><em>Example</em> 7.4.2.5. Here we describe an <em>operad of relations</em>, denoted <epub:switch id="mathmlSwitch2139"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">R</mi></math></epub:case><epub:default></epub:default></epub:switch>. The objects are sets, <epub:switch id="mathmlSwitch2140"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="script">R</mi><mo stretchy='false'>)</mo><mo>=</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="bold">Set</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. A morphism <em>f</em> : (<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, &#x2026;, <em>X<sub>n</sub></em>) &#x2192; <em>Y</em> in <epub:switch id="mathmlSwitch2141"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">R</mi></math></epub:case><epub:default></epub:default></epub:switch> is a relation</p>
<p class="disp-equ" id="eq_7-20"><epub:switch id="mathmlSwitch2142"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mtable><mtr><mtd><mrow><mi>R</mi><mo>&#x2286;</mo><msub><mi>X</mi><mn>1</mn></msub><mo>&#x00D7;</mo><msub><mi>X</mi><mn>2</mn></msub><mo>&#x00D7;</mo><mo>&#x22EF;</mo><mo>&#x00D7;</mo><msub><mi>X</mi><mi>n</mi></msub><mo>&#x00D7;</mo><mi>Y</mi><mo>.</mo></mrow></mtd><mtd><mo>(</mo><mn>7.20</mn><mo>)</mo></mtd></mtr></mtable></math></epub:case><epub:default></epub:default></epub:switch></p>
<p>We use a composition formula similar to that in Definition <a href="chapter003.html#Def_3-2-2-3">3.2.2.3</a>. Namely, to compose relations <em>R</em><sub>1</sub>, &#x2026;, <em>R<sub>n</sub></em> with <em>S</em>, we first form a fiber product, denoted <em>FP</em>:</p>
<p class="fig-img"><img src="images/Art_P343.jpg" alt="art"/></p>
<p class="noindent">We have an induced function <epub:switch id="mathmlSwitch2143"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>F</mi><mi>P</mi><mo>&#x2192;</mo><mrow><mo>(</mo><mrow><msub><mo>&#x220F;</mo><mrow><mi>i</mi><mo>&#x2208;</mo><munder accentunder='true'><mi>n</mi><mo stretchy='true'>&#x00AF;</mo></munder></mrow></msub><msub><mo>&#x220F;</mo><mrow><mi>j</mi><mo>&#x2208;</mo><munder accentunder='true'><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><mo stretchy='true'>&#x00AF;</mo></munder></mrow></msub><msub><mi>X</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow><mo>)</mo></mrow><mo>&#x00D7;</mo><mi>Z</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>, and its image is the subset we take to be the composite: <epub:switch id="mathmlSwitch2144"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>S</mi><mo>&#x25CB;</mo><mo stretchy='false'>(</mo><msub><mi>R</mi><mn>1</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><msub><mi>R</mi><mi>n</mi></msub><mo stretchy='false'>)</mo><mo>&#x2286;</mo><mrow><mo>(</mo><mrow><msub><mo>&#x220F;</mo><mrow><mi>i</mi><mo>&#x2208;</mo><munder accentunder='true'><mi>n</mi><mo stretchy='true'>&#x00AF;</mo></munder></mrow></msub><msub><mo>&#x220F;</mo><mrow><mi>j</mi><mo>&#x2208;</mo><munder accentunder='true'><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><mo stretchy='true'>&#x00AF;</mo></munder></mrow></msub><msub><mi>X</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub></mrow><mo>)</mo></mrow><mo>&#x00D7;</mo><mi>Z</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>. This gives a composition formula, for which the associativity and identity laws hold, so we indeed have an operad <epub:switch id="mathmlSwitch2145"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">R</mi></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="noindent1-top-app" id="App_7-4-2-6"><em>Application</em> 7.4.2.6. Suppose we are trying to model <span class="underline">life</span> in the following way. We define an entity as a set of <em>available experiences</em>. We also want to be able to put entities together to form a superentity, so we have a notion of morphism <em>f</em> : (<em>X</em><sub>1</sub>, &#x2026;, <em>X<sub>n</sub></em>) &#x2192; <em>Y</em> defined as a relation, as in (<a href="chapter007.html#eq_7-20">7.20</a>).</p>
<a id="p371"></a>
<p>The idea is that the morphism <em>f</em> is a way of translating between the experiences available to the subentities and the experiences available to the superentity. The superentity <em>Y</em> consists of some available experiences, like &#x201C;hunger&#x201D; &#x2208; <em>Y</em>. The subentities <em>X<sub>i</sub></em> each have their own set of available experiences, like &#x201C;U88fh&#x201D; &#x2208; <em>X</em><sub>2</sub>. The relation <em>R</em> &#x2286; <em>X</em><sub>1</sub> &#x00D7; &#x2026; &#x00D7; <em>X<sub>n</sub></em> &#x00D7; <em>Y</em> provides a way to translate between them. It says that when <em>X</em><sub>1</sub> is experiencing &#x201C;acidic&#x201D; and <em>X</em><sub>2</sub> is experiencing &#x201C;U88fh,&#x201D; and so on, this is the same as <em>Y</em> experiencing &#x201C;hunger.&#x201D;</p>
<p>The operad <epub:switch id="mathmlSwitch2146"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">R</mi></math></epub:case><epub:default></epub:default></epub:switch> from Example <a href="chapter007.html#Exa_7-4-2-5">7.4.2.5</a> becomes useful as a language for discussing issues in this domain.</p>
<p class="noindent1-top-exe" id="Exa_7-4-2-7"><em>Example</em> 7.4.2.7. Let <epub:switch id="mathmlSwitch2147"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">R</mi></math></epub:case><epub:default></epub:default></epub:switch> be the operad of relations from Example <a href="chapter007.html#Exa_7-4-2-5">7.4.2.5</a>, and recall that <epub:switch id="mathmlSwitch2148"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="script">R</mi><mo stretchy='false'>)</mo><mo>=</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="bold">Set</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Consider the algebra <epub:switch id="mathmlSwitch2149"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>S</mi><mo>:</mo><mi mathvariant="script">R</mi><mo>&#x2192;</mo><mtext mathvariant="bold">Sets</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> given by <em>S</em>(<em>X</em>) &#x003D; &#x2119;(<em>X</em>) for <epub:switch id="mathmlSwitch2150"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>X</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="script">R</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. Given a morphism <em>R</em> &#x2286; &#x220F;<sub><em>i</em></sub> <em>X<sub>i</sub></em> &#x00D7; <em>Y</em> and subsets <epub:switch id="mathmlSwitch2151"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mi>X</mi><mi>i</mi><mo>&#x2032;</mo></msubsup><mo>&#x2286;</mo><msub><mi>X</mi><mi>i</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>, we have a subset <epub:switch id="mathmlSwitch2152"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mo>&#x220F;</mo><mi>i</mi></msub><msubsup><mi>X</mi><mi>i</mi><mo>&#x2032;</mo></msubsup><mo>&#x2286;</mo><msub><mo>&#x220F;</mo><mi>i</mi></msub><msub><mi>X</mi><mi>i</mi></msub></mrow></math></epub:case><epub:default></epub:default></epub:switch>. We take the fiber product</p>
<p class="fig-img"><img src="images/Art_P344.jpg" alt="art"/></p>
<p class="noindent">and the image of <em>FP</em> &#x2192; <em>Y</em> is a subset of <em>Y</em>, as needed. We will continue with Application <a href="chapter007.html#App_7-4-2-8">7.4.2.8</a> using this algebra.</p>
<p class="noindent1-top-app" id="App_7-4-2-8"><em>Application</em> 7.4.2.8. Following Application <a href="chapter007.html#App_7-4-2-6">7.4.2.6</a> we can use Example <a href="chapter007.html#Exa_7-4-2-7">7.4.2.7</a> as a model of survival. Each entity <em>Y</em> survives only for a subset of the phenomena that it can experience. Under this interpretation, the algebra from Example <a href="chapter007.html#Exa_7-4-2-7">7.4.2.7</a> defines survival of an entity as the survival of all parts.</p>
<p>Suppose that we understand how the experiences of a superentity <em>Y</em> relate to those of subentities <em>X</em><sub>1</sub>, &#x2026;, <em>X<sub>n</sub></em> in the sense that we have a morphism <em>f</em> : (<em>X</em><sub>1</sub>, &#x2026;, <em>X<sub>n</sub></em>) &#x2192; <em>Y</em> in <epub:switch id="mathmlSwitch2153"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">R</mi></math></epub:case><epub:default></epub:default></epub:switch>. In the language of Application <a href="chapter007.html#App_7-4-2-6">7.4.2.6</a>, we have a translation between the set of experiences available across the sub-entities and the set of experiences available to the superentity. Our algebra postulates that the superentity will survive exactly those experiences for which each subentity survives.</p>
<p>Another way to phrase this, rather than in terms of survival, would be in terms of allowance. A bureaucracy consists of a set of smaller bureaucracies, each of which allows certain requests to pass; the whole bureaucracy allows a request to pass if and only if, when the request is translated into the perspective of each subbureaucracy, it is allowed to pass there.</p>

<p class="noindent1-top-exe" id="Exe_7-4-2-9"><em>Exercise</em> 7.4.2.9.</p>
<a id="p372"></a>
<p>Define the following six sets, <em>A</em> &#x003D; <em>B</em> &#x003D; <em>M</em> &#x003D; <em>C</em> &#x003D; <em>N</em> &#x003D; <em>Z</em> &#x003D; &#x2124;, and consider them as objects <epub:switch id="mathmlSwitch2154"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><mi>M</mi><mo>,</mo><mi>C</mi><mo>,</mo><mi>N</mi><mo>,</mo><mi>Z</mi><mo>&#x2208;</mo><mtext>Ob(</mtext><mi mathvariant="script">R</mi><mtext>)</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="nl1-list">a. How would you encode the relations</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch2155"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>a</mi><mi>b</mi><mo>=</mo><msup><mi>m</mi><mn>2</mn></msup><mo>,</mo><mo>&#x00A0;</mo><msup><mi>c</mi><mn>2</mn></msup><mo>=</mo><msup><mi>m</mi><mn>3</mn></msup><mo>,</mo><mo>&#x00A0;</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>=</mo><mi>z</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="nl1-list-para">as a 2-ary morphism <em>R</em><sub>1</sub> : (<em>A</em>, <em>B</em>) &#x2192; <em>M</em>, a 1-ary morphism <em>R</em><sub>2</sub> : (<em>C</em>) &#x2192; <em>N</em>, and a 2-ary morphism <em>S</em> : (<em>M</em>, <em>N</em>) &#x2192; <em>Z</em> in the operad <epub:switch id="mathmlSwitch2156"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">R</mi></math></epub:case><epub:default></epub:default></epub:switch>?</p>
<p class="nl1-list">b. What is the domain and codomain of the composite <em>S</em> &#x25CB; (<em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>)?</p>
<p class="nl1-list">c. Write the composite <em>S</em> &#x25CB; (<em>R</em><sub>1</sub>, <em>R</em><sub>2</sub>) as a relation.</p>
<p class="noindent1-top-exe" id="Exa_7-4-2-10"><em>Example</em> 7.4.2.10. This example discusses wiring diagrams. This operad is denoted <epub:switch id="mathmlSwitch2157"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>W</mi></math></epub:case><epub:default></epub:default></epub:switch> (see [41]). An object of <epub:switch id="mathmlSwitch2158"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>W</mi></math></epub:case><epub:default></epub:default></epub:switch> is just a finite set, <epub:switch id="mathmlSwitch2159"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>W</mi><mo stretchy='false'>)</mo><mo>=</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mtext mathvariant="bold">Fin</mtext><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, elements of which are called <em>wires</em>. A morphism in <epub:switch id="mathmlSwitch2160"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>W</mi></math></epub:case><epub:default></epub:default></epub:switch> is shown in <a href="chapter007.html#Fig_7-8">Figure 7.8</a> (see page 382) and is formalized as follows. Given objects <em>C</em><sub>1</sub>, &#x2026;, <em>C<sub>n</sub></em>, and <em>D</em>, a morphism (<em>C</em><sub>1</sub>, &#x2026;, <em>C<sub>n</sub></em>) &#x2192; <em>D</em> is a commutative diagram of sets</p>
<p class="fig-img" id="eq_7-21"><img src="images/Art_P345.jpg" alt="art"/></p>
<p class="noindent">such that <em>p</em> and <em>q</em> are jointly surjective.</p>
<p>Composition of morphisms is easily understood in graphic form: Given wiring diagrams inside of wiring diagrams, we can throw away the intermediary circles. In terms of sets, we first take the pushout <em>PO</em>:</p>
<p class="fig-img"><img src="images/Art_P346.jpg" alt="art"/></p>
<p class="noindent">and then take the composition to be the image of <epub:switch id="mathmlSwitch2161"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy='false'>(</mo><msub><mo>&#x2294;</mo><mrow><mi>i</mi><mo>&#x2208;</mo><munder accentunder='true'><mi>n</mi><mo stretchy='true'>&#x00AF;</mo></munder></mrow></msub><msub><mo>&#x2294;</mo><mrow><mi>j</mi><mo>&#x2208;</mo><munder accentunder='true'><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><mo stretchy='true'>&#x00AF;</mo></munder></mrow></msub><msub><mi>C</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy='false'>)</mo><mo>&#x2294;</mo><mi>E</mi><mo>&#x2192;</mo><mi>P</mi><mi>O</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<a id="p373"></a>
<p class="noindent1-top-exe" id="Exe_7-4-2-11"><em>Exercise</em> 7.4.2.11.</p>
<p>Let <em>C</em><sub>1</sub> &#x003D; {<em>a</em>, <em>b</em>, <em>m</em>}, <em>C</em><sub>2</sub> &#x003D; {<em>c</em>, <em>n</em>}, <em>C</em><sub>3</sub> &#x003D; {<em>m</em>, <em>n</em>, <em>z</em>}, let <em>C</em> &#x003D; <em>C</em><sub>1</sub> &#x2294; <em>C</em><sub>2</sub> &#x2294; <em>C</em><sub>3</sub>, and let <em>D</em> &#x003D; {<em>a</em>, <em>c</em>, <em>z</em>}.</p>
<p class="nl1-list">a. Suppose we draw <em>C</em><sub>1</sub>, <em>C</em><sub>2</sub>, and <em>C</em><sub>3</sub> as follows:</p>
<p class="fig-img"><img src="images/Art_P347.jpg" alt="art"/></p>
<p class="nl1-list-para">Follow those examples to draw <em>D</em>.</p>
<p class="nl1-list">b. What set <em>G</em> and functions <epub:switch id="mathmlSwitch2162"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi><mover><mo>&#x2192;</mo><mi>p</mi></mover><mi>G</mi><mover><mo>&#x2190;</mo><mi>q</mi></mover><mi>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> in (<a href="chapter007.html#eq_7-21">7.21</a>) correspond to this picture?</p>

<p class="fig-img"><img src="images/Art_P348.jpg" alt="art"/></p>
<p class="noindent1-top-sol"><em>Solution</em> 7.4.2.11.</p>
<p class="nl1-list">a. We can draw <em>D</em> &#x003D; {<em>a</em>, <em>c</em>, <em>z</em>} as follows:</p>
<p class="fig-img"><img src="images/Art_P349.jpg" alt="art"/></p>
<a id="p374"></a>
<p class="nl1-list">b. Here <em>G</em> &#x003D; {<em>a</em>, <em>b</em>, <em>m</em>, <em>c</em>, <em>n</em>, <em>z</em>}. The functions <epub:switch id="mathmlSwitch2163"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi><mover><mo>&#x2192;</mo><mi>p</mi></mover><mi>G</mi><mover><mo>&#x2190;</mo><mi>q</mi></mover><mi>D</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> are given in the following tables:</p>
<p class="fig-img"><img src="images/Art_P350.jpg" alt="art"/></p>

<p class="noindent1-top-exe" id="Exa_7-4-2-12"><em>Example</em> 7.4.2.12. Let&#x2019;s continue with the operad <epub:switch id="mathmlSwitch2164"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>W</mi></math></epub:case><epub:default></epub:default></epub:switch> of wiring diagrams, and try to form an algebra on it. Taking <epub:switch id="mathmlSwitch2165"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant="script">R</mi></math></epub:case><epub:default></epub:default></epub:switch> to be the operad of relations as described in Example <a href="chapter007.html#Exa_7-4-2-5">7.4.2.5</a>, there is an operad functor <epub:switch id="mathmlSwitch2166"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Q</mi><mo>:</mo><mi mathvariant='script'>W</mi><mo>&#x2192;</mo><mi mathvariant="script">R</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>. It assigns to each <epub:switch id="mathmlSwitch2167"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>C</mi><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant='script'>W</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> the set <epub:switch id="mathmlSwitch2168"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msup><mi>&#x2124;</mi><mi>C</mi></msup><mo>&#x2208;</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="script">R</mi><mo stretchy='false'>)</mo><mo>=</mo><mtext>Ob</mtext><mo stretchy='false'>(</mo><mi mathvariant="bold">Set</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. To a morphism <em>G</em> : (<em>C</em><sub>1</sub>, &#x2026;, <em>C<sub>n</sub></em>) &#x2192; <em>D</em> as in (<a href="chapter007.html#eq_7-21">7.21</a>) it assigns the relation</p>
<p class="disp-equ-no"><epub:switch id="mathmlSwitch2169"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msup><mo>&#x2124;</mo><mi>G</mi></msup><mo>&#x2286;</mo><mrow><mo>(</mo><mrow><mstyle displaystyle='true'><munder><mo>&#x220F;</mo><mrow><mi>i</mi><mo>&#x2208;</mo><munder accentunder='true'><mi>n</mi><mo stretchy='true'>&#x00AF;</mo></munder></mrow></munder><mrow><msup><mo>&#x2124;</mo><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow></msup></mrow></mstyle></mrow><mo>)</mo></mrow><mo>&#x00D7;</mo><msup><mo>&#x2124;</mo><mi>D</mi></msup><mo>.</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch></p>
<p class="noindent">The idea is that to an entity defined as having a bunch of cables carrying integers, a phenomenon is the same thing as a choice of integer on each cable. A wiring diagram translates between phenomena experienced locally and phenomena experienced globally.</p>
<p>Now recall the algebra <epub:switch id="mathmlSwitch2170"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>S</mi><mo>:</mo><mi mathvariant="script">R</mi><mo>&#x2192;</mo><mi mathvariant="bold">Set</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> from Example <a href="chapter007.html#Exa_7-4-2-7">7.4.2.7</a>. We can compose with <em>Q</em> to get <epub:switch id="mathmlSwitch2171"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Q</mi><mo>&#x2032;</mo><mo>&#x2254;</mo><mi>S</mi><mo>&#x25CB;</mo><mi>Q</mi><mo>:</mo><mi mathvariant='script'>W</mi><mo>&#x2192;</mo><mi mathvariant="bold">Set</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="noindent1-top-exe" id="Exe_7-4-2-13"><em>Exercise</em> 7.4.2.13.</p>
<p>Consider the wiring diagrams operad <epub:switch id="mathmlSwitch2172"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>W</mi></math></epub:case><epub:default></epub:default></epub:switch> from Example <a href="chapter007.html#Exa_7-4-2-10">7.4.2.10</a>. Let&#x2019;s continue with Exercise <a href="chapter007.html#Exe_7-4-2-11">7.4.2.11</a> so that &#x201C;everything,&#x201D; i.e., <em>C</em><sub>1</sub>, <em>C</em><sub>2</sub>, <em>C</em><sub>3</sub>, <em>D</em>, <em>G</em>, <em>i</em>, and <em>j</em>, are as in that exercise. By Example <a href="chapter007.html#Exa_7-4-2-12">7.4.2.12</a> we have an algebra <epub:switch id="mathmlSwitch2173"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>Q</mi><mo>&#x2032;</mo><mo>:</mo><mi mathvariant='script'>W</mi><mo>&#x2192;</mo><mi mathvariant="bold">Set</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="nl1-list">a. What might we mean by saying that the following picture represents an element <em>q</em><sub>1</sub> &#x2208; <em>Q</em>&#x2032;(<em>C</em><sub>1</sub>)?</p>
<a id="p375"></a>
<p class="fig-img"><img src="images/Art_P351.jpg" alt="art"/></p>
<p class="nl1-list">b. Suppose we have the following elements <em>q</em><sub>1</sub> &#x2208; <em>Q</em>&#x2032;(<em>C</em><sub>1</sub>), <em>q</em><sub>2</sub> &#x2208; <em>Q</em>&#x2032;(<em>C</em><sub>2</sub>), and <em>q</em><sub>3</sub> &#x2208; <em>Q</em>&#x2032;(<em>C</em><sub>3</sub>):</p>
<p class="fig-img"><img src="images/Art_P352.jpg" alt="art"/></p>
<p class="nl1-list-para">Given the wiring diagram <em>G</em> : (<em>C</em><sub>1</sub>, <em>C</em><sub>2</sub>, <em>C</em><sub>3</sub>) &#x2192; <em>D</em> pictured here,</p>

<p class="fig-img"><img src="images/Art_P353.jpg" alt="art"/></p>
<p class="nl1-list-para">what is <em>G</em>(<em>q</em><sub>1</sub>, <em>q</em><sub>2</sub>, <em>q</em><sub>3</sub>) &#x2208; <em>Q</em>&#x2032;(<em>D</em>)?</p>
<p class="noindent1-top-app" id="App_7-4-2-14"><em>Application</em> 7.4.2.14. In cognitive neuroscience or in industrial economics, it may be that we want to understand the behavior of an entity such as a mind, a society, or a business in terms of its structure. Knowing the connection pattern (<span class="underline">connectome</span>, <span class="underline">supply chain</span>) of subentities should help us understand how big changes are generated from small ones.</p>
<a id="p376"></a>
<p class="noindent1-top-app" id="App_7-4-2-15"><em>Application</em> 7.4.2.15. In [36], <span class="underline">Radul and Sussman</span> discuss propagator networks. Their implementation can presumably be understood in terms of wiring diagrams and their algebra of relations.</p>
<a id="p377"></a>
<figure>
<img src="images/Art_P354.jpg" alt="art"/>
<figcaption id="Fig_7-1"><strong>Figure 7.1</strong> Three overlapping views of the night sky. Source: NASA, ESA, Digitized Sky Survey Consortium.</figcaption>
</figure>
<a id="p378"></a>
<figure>
<img src="images/Art_P355.jpg" alt="art"/>
<figcaption id="Fig_7-2"><strong>Figure 7.2</strong> The three overlapping views have been glued together into one coherent view.</figcaption>
</figure>
<a id="p379"></a>
<figure>
<img src="images/Art_P356.jpg" alt="art"/>
<figcaption id="Fig_7-4"><strong>Figure 7.4</strong> The composition of morphisms <em>f</em><sub>1</sub> and <em>f</em><sub>2</sub> with <em>g</em>.</figcaption>
</figure>
<a id="p380"></a>
<figure>
<img src="images/Art_P357.jpg" alt="art"/>
<figcaption id="Fig_7-5"><strong>Figure 7.5</strong> A morphism (<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, <em>X</em><sub>3</sub>) &#x2192; <em>Y</em> in an operad with only one object, &#x25AB;.</figcaption>
</figure>
<figure>
<img src="images/Art_P358.jpg" alt="art"/>
<figcaption id="Fig_7-6"><strong>Figure 7.6</strong> A morphism (<em>X</em><sub>1</sub>, <em>X</em><sub>2</sub>, <em>X</em><sub>3</sub>) &#x2192; <em>Y</em> and morphisms (<em>W</em><sub>1,1</sub>, <em>W</em><sub>1,2</sub>) &#x2192; <em>X</em><sub>1</sub>, (<em>W</em><sub>2,1</sub>, <em>W</em><sub>2,2</sub>, <em>W</em><sub>2,3</sub>) &#x2192; <em>X</em><sub>2</sub>, and (<em>W</em><sub>3,1</sub>) &#x2192; <em>X</em><sub>3</sub>, each of which is a positioning of squares inside a square. The composition formula is given by scaling and positioning the squares to give (<em>W</em><sub>1,1</sub>, <em>W</em><sub>1,2</sub>, <em>W</em><sub>2,1</sub>, <em>W</em><sub>2,2</sub>, <em>W</em><sub>2,3</sub>, <em>W</em><sub>3,1</sub>) &#x2192; <em>Y</em>.</figcaption>
</figure>
<a id="p381"></a>
<figure>
<img src="images/Art_P359.jpg" alt="art"/>
<figcaption id="Fig_7-7"><strong>Figure 7.7</strong> A morphism expressing the construction of a material from smaller materials.</figcaption>
</figure>
<a id="p382"></a>
<figure>
<img src="images/Art_P360.jpg" alt="art"/>
<figcaption id="Fig_7-8"><strong>Figure 7.8</strong> Morphisms in a wiring diagram operad <epub:switch id="mathmlSwitch2174"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>W</mi></math></epub:case><epub:default></epub:default></epub:switch>. Composition of wiring diagrams is given by substitution.</figcaption>
</figure>
<p class="noindent1-top">__________________</p>
<p class="ntx" id="endnote_1"><a epub:type="noteref" href="chapter007.html#endnote_ref_1"><sup>1</sup></a>Throughout this definition, notice that <em>B</em>&#x2019;s come before <em>A</em>&#x2019;s, especially in (<a href="chapter007.html#eq_7-1">7.1</a>), which might be confusing. It was a stylistic choice to match with the <strong>B</strong>abies and <strong>A</strong>dults discussion.</p>
<p class="ntx" id="endnote_2"><a epub:type="noteref" href="chapter007.html#endnote_ref_2"><sup>2</sup></a>The natural isomorphism <em>&#x03B1;</em> (see Proposition <a href="chapter005.html#Pro_5-3-2-12">5.3.2.12</a>) is between two functors <epub:switch id="mathmlSwitch2175"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msup><mi mathvariant='script'>B</mi><mrow><mtext>op</mtext></mrow></msup><mo>&#x00D7;</mo><mi mathvariant='script'>A</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch>, namely, the functor <epub:switch id="mathmlSwitch2176"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy='false'>(</mo><mi>B</mi><mo>,</mo><mi>A</mi><mo stretchy='false'>)</mo><mo>&#x21A6;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>A</mi></msub><mo stretchy='false'>(</mo><mi>L</mi><mo stretchy='false'>(</mo><mi>B</mi><mo stretchy='false'>)</mo><mo>,</mo><mi>A</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> and the functor <epub:switch id="mathmlSwitch2177"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo stretchy='false'>(</mo><mi>B</mi><mo>,</mo><mi>A</mi><mo stretchy='false'>)</mo><mo>&#x21A6;</mo><msub><mrow><mtext>Hom</mtext></mrow><mi mathvariant='script'>B</mi></msub><mo stretchy='false'>(</mo><mi>B</mi><mo>,</mo><mi>R</mi><mo stretchy='false'>(</mo><mi>A</mi><mo stretchy='false'>)</mo><mo>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>.</p>
<p class="ntx" id="endnote_3"><a epub:type="noteref" href="chapter007.html#endnote_ref_3"><sup>3</sup></a>Conversely, for any <em>g</em> : <em>B</em> &#x2192; <em>R</em>(<em>A</em>) in <epub:switch id="mathmlSwitch2178"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>B</mi></math></epub:case><epub:default></epub:default></epub:switch>, we refer to <epub:switch id="mathmlSwitch2179"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msubsup><mi>&#x03B1;</mi><mrow><mi>B</mi><mo>,</mo><mi>A</mi></mrow><mrow><mo>&#x2212;</mo><mn>1</mn></mrow></msubsup><mo stretchy='false'>(</mo><mi>g</mi><mo stretchy='false'>)</mo><mo>:</mo><mi>L</mi><mo stretchy='false'>(</mo><mi>B</mi><mo stretchy='false'>)</mo><mo>&#x2192;</mo><mi>A</mi></mrow></math></epub:case><epub:default></epub:default></epub:switch> as <em>the adjunct</em> of <em>g</em>.</p>
<p class="ntx" id="endnote_4"><a epub:type="noteref" href="chapter007.html#endnote_ref_4"><sup>4</sup></a>The left adjoint does not have to be called <em>L</em>, nor does the right adjoint have to be called <em>R</em>, of course.</p>
<p class="ntx" id="endnote_5"><a epub:type="noteref" href="chapter007.html#endnote_ref_5"><sup>5</sup></a>FQL is available on the Internet. See <span class="underline">http://categoricaldata.net/fql.html</span>.</p>
<p class="ntx" id="endnote_6"><a epub:type="noteref" href="chapter007.html#endnote_ref_6"><sup>6</sup></a>This example was taken from Spivak [38].</p>
<p class="ntx" id="endnote_7"><a epub:type="noteref" href="chapter007.html#endnote_ref_7"><sup>7</sup></a>Repeated for convenience,</p>
<p class="fig-img"><img src="images/Art_P361.jpg" alt="art"/></p>
<p class="noindent"><epub:switch id="mathmlSwitch2180"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>I</mi><mo>:</mo><mi mathvariant='script'>C</mi><mo>&#x2192;</mo><mtext mathvariant='bold'>Set</mtext></mrow></math></epub:case><epub:default></epub:default></epub:switch> is</p>
<p class="fig-img"><img src="images/Art_P362.jpg" alt="art"/></p>
<p class="ntx" id="endnote_8"><a epub:type="noteref" href="chapter007.html#endnote_ref_8"><sup>8</sup></a>Technically <epub:switch id="mathmlSwitch2181"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi mathvariant='script'>C</mi></math></epub:case><epub:default></epub:default></epub:switch> has to be small but, as mentioned in Remark <a href="chapter005.html#Rem_5-1-1-2">5.1.1.2</a>), we do not worry about that distinction in this book.</p>
<p class="ntx" id="endnote_9"><a epub:type="noteref" href="chapter007.html#endnote_ref_9"><sup>9</sup></a>There is a lot of clutter here. Note that &#x201C;firstChild(mother(&#x263A;))&#x201D; is a row in the <span class="font1">Child</span> table of <em>Y</em><sub><span class="font1">Child</span></sub>. Assuming that the math follows the meaning, if &#x263A; points to Amy, where should firstChild(mother(&#x263A;)) point?</p>
<p class="ntx" id="endnote_10"><a epub:type="noteref" href="chapter007.html#endnote_ref_10"><sup>10</sup></a>Parentheses are used to denote open intervals of real numbers. For example, (6, 9) denotes the set {<em>x</em> &#x2208; &#x211D; &#x007C; 6 &#x003C; <em>x</em> &#x003C; 9}.</p>
<p class="ntx" id="endnote_11"><a epub:type="noteref" href="chapter007.html#endnote_ref_11"><sup>11</sup></a>This requirement is somewhat stringent, but it can be mitigated in a variety of ways. One such way would be to model the ability to hand off the experimental results to another person, who would then carry them forward. This could be done by defining a preorder structure on <em>A</em> to model who can hand off to whom (see Example <a href="chapter007.html#Exa_7-3-3-8">7.3.3.8</a>).</p>
<p class="ntx" id="endnote_12"><a epub:type="noteref" href="chapter007.html#endnote_ref_12"><sup>12</sup></a>Actually, Definition <a href="chapter003.html#Def_3-2-2-3">3.2.2.3</a> is about composing spans, but a relation <em>R</em> &#x2286; <em>A</em> &#x00D7; <em>B</em> is a kind of span, <em>R</em> &#x2192; <em>A</em> &#x00D7; <em>B</em>.</p>
<p class="ntx" id="endnote_13"><a epub:type="noteref" href="chapter007.html#endnote_ref_13"><sup>13</sup></a>There are three abuses of notation when writing <epub:switch id="mathmlSwitch2182"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><msub><mi>x</mi><mi>n</mi></msub><mo>;</mo><mi>y</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>. First, it confuses the set <em>n</em> &#x2208; Ob(<strong>Fin</strong>) with its cardinality &#x007C;<em>n</em>&#x007C; &#x2208; &#x2115;. But rather than writing <epub:switch id="mathmlSwitch2183"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><msub><mi>x</mi><mrow><mo>&#x007C;</mo><mi>n</mi><mo>&#x007C;</mo></mrow></msub><mo>;</mo><mi>y</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch>, it would be more consistent to write <epub:switch id="mathmlSwitch2184"><epub:case required-namespace="http://www.w3.org/1998/Math/MathML"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi mathvariant='script'>O</mi><mo stretchy='false'>(</mo><mi>x</mi><mo stretchy='false'>(</mo><mn>1</mn><mo stretchy='false'>)</mo><mo>,</mo><mo>&#x2026;</mo><mo>,</mo><mi>x</mi><mo stretchy='false'>(</mo><mo>&#x007C;</mo><mi>n</mi><mo>&#x007C;</mo><mo stretchy='false'>)</mo><mo>;</mo><mi>y</mi><mo stretchy='false'>)</mo></mrow></math></epub:case><epub:default></epub:default></epub:switch> because we have assigned subscripts another meaning in part D. But even this notation unfoundedly suggests that the set <em>n</em> has been endowed with a linear ordering, which it has not. This may be seen as a more serious abuse, but see Remark <a href="chapter007.html#Rem_7-4-1-2">7.4.1.2</a>.</p>
<p class="ntx" id="endnote_14"><a epub:type="noteref" href="chapter007.html#endnote_ref_14"><sup>14</sup></a>Thanks to Professor Sandra Shefelbine for explaining the hierarchical nature of collagen to me. Any errors are my own.</p>
</section>
</section>
</section>
<p><div class=navigation>[Go to <span><a href="index.html">first</a>, <a href="chapter006.html">previous</a></span><span>, <a href="reference.html">next</a></span> page<span>; &nbsp;&nbsp;</span><span><a href="toc.html">contents</a></span><span><span>; &nbsp;&nbsp;</span><a href="bookindex.html">index</a></span>]</div><p>
</div>
</body>
</html>